<?xml version="1.0" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
   "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8" />
  <meta name="author" content="Matěj Zábský" />
  <title>GeoGen Documentation</title>
  <style type="text/css">
    body{
      font-family: calibri, sans-serif
    }
  
    h1{
      font-size:70px;
      text-align:center;
      font-weight:bold;
    }
    
    h2{
      width:100%;
      border-top:1px black solid;
      border-bottom:1px black solid;
      background: #EEEEEE;
      font-size:40px;
      text-align:center;
      font-weight:bold;
    }
    
    h3{
      font-size:30px;
      width:100%;
      border-bottom:1px gray solid;
      font-weight:bold;
      text-align:center;
    }
    
    h4{
      font-size: 23px;
      font-weight:bold;
      text-align:center;
    }
    
    h5{
      font-size: 20px;
      padding-left:120px;
      text-decoration:underline;
    }

    h6{
      font-weight:bold;
      font-size:105%;
      padding-left:20px;
      font-family:monospace;
    }
    
    h6 a{
      text-decoration:none;
    }

    h6 a:hover{
      text-decoration:underline;
    }
  
    pre{
      padding-left:50px;
    }
    
    a:link,a:visited{
      color:rgb(0,153,255);
    }
    
    dl{
      margin:0;
      padding:0;
    }
    
    dt{
      margin-left:30px;
      font-family:monospace;
    }
  
    dd{
      margin-left:80px;
      padding-bottom:10px;
    }

    

  </style>
  </head>
  <body>
  <h1>GeoGen Documentation</h1>
  
  <h2><a name="introduction">Introduction</a></h2>
  
  <p>
    GeoGen (shortly GGen) is an open-source procedural heightmap generator. Scripting support is provided by <a href="http://www.squirrel-lang.org">Squirrel</a> engine. GeoGen grants the scripts ability to generate the most various terrain shapes while keeping them simple and easy to read.
  </p>
  
  <h2><a name="contents">Contents</a></h2>
  
  <ul>
    <li><a href="#introduction">Introduction</a></li>
    <li><a href="#contents">Contents</a></li>
    <li><a href="#console">Using the console interface</a></li>
    <li><a href="#syntax">Script syntax</a></li>
    <li><a href="#api">Script API</a>
      <ul>
        <li><a href="#layout">Script layout</a></li>
        <li><a href="#stdlib">Standard library</a></li>
        <li><a href="#reference">API Reference</a>
          <ul>
            <li><a href="#ggen_data_1d">GGen_Data_1D</a>
              <ul>
                <li><a href="#1d_constructors">Constructors</a></li>
                <li><a href="#1d_values">Basic I/O</a></li>
                <li><a href="#1d_arithmetic">Artithmetical and logical operations</a></li>
                <li><a href="#1d_advanced">Advanced data manipulation</a></li>
              </ul>
            </li> 
            <li><a href="#ggen_data_2d">GGen_Data_2D</a>
              <ul>
                <li><a href="#2d_constructors">Constructors</a></li>
                <li><a href="#2d_values">Basic I/O</a></li>
                <li><a href="#2d_arithmetic">Artithmetical and logical operations</a></li>
                <li><a href="#2d_advanced">Advanced data manipulation</a></li>
                <li><a href="#2d_interaction">API interaction</a></li>
              </ul>            
            </li>  
            <li><a href="#ggen_amplitudes">GGen_Amplitudes</a></li> 
            <li><a href="#interaction">API interaction</a>
              <ul>
                <li><a href="#interaction_args">Script argument support</a></li>
                <li><a href="#progress">Proggress reporting</a></li>
              </ul>
            </li>
            <li><a href="#presets">Presets</a></li> 
            <li><a href="#constants_and_enums">Support constants and enumerations</a></li> 
          </ul>       
        </li>  
      </ul>      
    </li>
    <li><a href="#license">License</a></li>
  </ul>
  <h2><a name="console">Using the console interface</a></h2>
    <p>The command line syntax for the geogen.exe is basically this:</p>
    <pre>geogen -i path_to_script -o path_to_output [options] [script_arguments]</pre>
    <p>Neither argument is really obligatory - GeoGen can be ran directly from Windows.</p>
    <p><em>script_file</em> indicates relative path to a Squirrel script file. <em>output_file</em> will be the place where the output bitmap is saved. If this file already exists, it will be overwritten.</p>
    <p><em>script_arguments</em> is a space-separated list of arguments in the order script requests them. If a script requests an argument value and you don't set it, default value proposed by the script is used. You can use "r" instead of any value to pick it randomly.</p>
    <p><em>options</em> can be used to adjust more advanced aspects of the generator. Complete list of options:</p>
    <dl>
        <dt>-i FILE, --input FILE</dt>
        <dd>Input squirrel script to be executed.<dd>
        <dt>-o FILE, --output FILE</dt>
        <dd>Output file, the extension determines file type of the output (*.bmp for Windows Bitmap and *.shd for GeoGen Short Height Data are allowed). Set to "../temp/out.bmp" by default.</dd>
        <dt>-d DIRECTORY, --output-directory DIRECTORY</dt>
        <dd>Directory where secondary maps will be saved. Set to "../temp/" by default.</dd>
        <dt>-v FILE, --overlay FILE</dt>
        <dd>Overlay file to be mapped on the output. This file must be a Windows Bitmap file one pixel high and 256 pixels wide.</dd>
        <dt>-s SEED, --seed SEED</dt>
        <dd>Pseudo-random generator seed. Maps generated with same seed, map script, arguments and generator version are always the same.</dd>
        <dt>-a, --all-random</dt>
        <dd>All unset script arguments are generated randomly.</dd>
        <dt>-z, --ignore-zero</dt>
        <dd>Height data range will be rescaled to fit the output file format including negative value. Zero level will probably not be preserved.</dd>
        <dt>-n, --no-rescaling</dt>
        <dd>The height data will not be rescaled at all. Might cause color overflows if the format's value range is lower than <-32787, 32787>.</dd>
        <dt>-?, --help</dt>
        <dd>Displays this help.</dd>
        <dt>-x, --syntax-check</dt>
        <dd>Will print OKAY if script is compilable or descibe the error found.</dd>
        <dt>-p, --param-list</dt>
        <dd>Lists the script's parameters in machine-readable format.</dd>
        <dt>-e, --simple</dt>
        <dd>Mode which allows all necessary data to be entered interactively. This mode is automatically activaded if no params were entered.</dd>
        <dt>-m, --manual</dt>
        <dd>Script arguments will be entered interactively.</dd>
        <dt>-D, --disable-secondary-maps</dt>
        <dd>All secondary maps will be immediately discarded, ReturnAs calls will be effectively skipped.</dd>
        <dt>-V, --overlay-as-copy</dt>
        <dd>Color files with overlays will be saved as copies.</dd>
    </dl>
  <h2><a name="syntax">Script syntax</a></h2>
    <p>For Squirrel syntax, please refer to the language's <a href="http://squirrel-lang.org/doc/squirrel2.html#d0e44">official documentation</a>.</p>
  <h2><a name="api">Script API</a></h2>
    <h3><a name="layout">Script layout</a></h3>
      <p>
        The first function script must contain is named "GetInfo" taking one string argument and also returning a string. This function will be repeatedly called by the API requesting various information. Typical content of this function is a switch statement responding to individual request strings.
      </p>
      <pre>function GetInfo(info_type){
	switch(info_type){
		case "name":
			return "name_the_map";
		case "description":
			return "Long and hopefully not boring description of the map";
		case "args":
			GGen_AddIntArg("width","Width","Width of the map.", 1024, 128, 20000, 1);
			GGen_AddIntArg("height","Height","Width of the map.", 1024, 128, 20000, 1);
			// some more arguments
			return 0;
	}
	return 0;
}</pre>
      <p>
        For information about the argument manipulation functions refer to the <a href="#interaction_args">Script argument support</a> section.
      </p>
      <p>
        The script must also contain a function named "Generate" with body of the script logic. The function must return one <a href="#ggen_data_2d">GGen_Data_2D</a> object.
      </p>
      <p> 
        A very simple function "generating" an empty heightmap (all zeroes) could look like this:
      </p>
      <pre>function Generate(){
	// load values of the arguments
	local width = GGen_GetParam("width");
	local height = GGen_GetParam("height");
	
	// Create a new 2D data array with given width and height
	return GGen_Data_2D(width, height);
<!--   -->}</pre>
    <h3><a name="stdlib">Standard library</a></h3>
      <p>GeoGen API utilizes the Math module from the Squirrel Standard Library, you can find reference of these functions in its <a href="http://squirrel-lang.org/doc/sqstdlib2.html#d0e1527">documentation</a>.</p>
    <h3><a name="reference">API Reference</a></h3>
      <p>
        This section contains full listing of everything exposed to the scripts by GeoGen.
      </p>
      <h4><a name="ggen_data_1d">GGen_Data_1D</a></h4>
        <p>
          GGen_Data_1D represents a simple 1D array of values. Though its simple nature, it can be used to create more complex 2D maps using methods like <a href="#2d_project">GGen_Data_2D::Project</a>, <a href="#2d_gradient">GGen_Data_2D::Gradient</a> or <a href="#2d_radialgradient">GGen_Data_2D::RadialGradient</a>. 
        </p>
        <h5><a name="1d_constructors">Constructors</a></h5>
          <h6>GGen_Data_1D(int length)</h6>
          <p>Creates new <a href="#ggen_data_1d">GGen_Data_1D</a> object of given <em>length</em>. All values are set to 0.</p>
          <h6>GGen_Data_1D(int length, int value)</h6>
          <p>Creates new <a href="#ggen_data_1d">GGen_Data_1D</a> object of given <em>length</em>. All values are set to <em>value</em>.</p>
          <h6>GGen_Data_1D(<a href="#ggen_data_1d">GGen_Data_1D</a> original)</h6>
          <p>Creates a 1:1 copy of <em>original</em>.</p>
        <h5><a name="1d_values">Basic I/O</a></h5>
          <h6>GGen_Data_1D::GetLength()</h6>
          <p>Returns length of the array.</p>
          <h6>GGen_Data_1D::GetValue(int x)</h6>
          <p>Returns value on coordinate <em>x</em>.</p>
          <h6>GGen_Data_1D::GetValue(int x, int length)</h6>
          <p>Returns interpolated value on coordinate <em>x</em> as if the array had length <em>length</em>.</p>
          <h6>GGen_Data_1D::SetValue(int x, int value)</h6>
          <p>Sets value on coordinate <em>x</em> to <em>value</em>.</p>
          <h6>GGen_Data_1D::SetValueInRange(int start, int end, int value)</h6>
          <p>Sets value on all coordinates between <em>start</em> and <em>end</em> to <em>value</em>. Both points are included in the range.</p>
        <h5><a name="1d_arithmetic">Arithmetical and logical data operations</a></h5>
          <h6>GGen_Data_1D::Add(int value)</h6>
          <p>Adds <em>value</em> to all values in the array.</p>
          <h6>GGen_Data_1D::Add(<a href="#ggen_data_1d">GGen_Data_1D</a> addend)</h6>
          <p>Adds  <em>addend</em> to current array - values from respective coordinates are added together. Values from <em>addend</em> will be interpolated to fit the current array.</p>
          <h6>GGen_Data_1D::AddTo(int offset, <a href="#ggen_data_1d">GGen_Data_1D</a> addend)</h6>
          <p>Adds values from <em>addend</em> to their respective coordinates in current array offset by <em>offset</em>. <em>Addend</em> won't be interpolated.</p>
          <h6>GGen_Data_1D::AddMasked(<a href="#ggen_data_1d">GGen_Data_1D</a> addend, <a href="#ggen_data_1d">GGen_Data_1D</a> mask, bool relative_mode)</h6>
          <p>Adds values from <em>addend</em> to their respective coordinates in current array. The percentage of value added depends on respective value in <em>mask</em>. In <em>relative_mode</em>, the <em>mask</em> is interh6ted as <em>mask</em> minimum = 0% of value and <em>mask</em> maximum = 100%, otherwise 0 = 0% of value and 255 = 100%. Both <em>addend</em> and <em>mask</em> will be interpolated to fit the current array.</p>
          <h6>GGen_Data_1D::Multiply(int value)</h6>
          <p>Multiplies all values from the array by <em>value</em>.</p>
          <h6>GGen_Data_1D::Multiply(<a href="#ggen_data_1d">GGen_Data_1D</a> factor)</h6>
          <p>Multiplies all values from the current array by respective values from <em>factor</em>. Values from <em>factor</em> will be interpolated to fit the current array.</p>
          <h6>GGen_Data_1D::Invert()</h6>
          <p>Flips signs of all values in the array.</p>
          <h6>GGen_Data_1D::Scale(double ratio, bool scale_values)</h6>
          <p>Scales the size of the array by <em>ratio</em>. If <em>scale_values</em> is true, the values will be scaled too, otherwise they will be only interpolated.</p> 
          <h6>GGen_Data_1D::ScaleTo(int new_length, bool scale_values)</h6>
          <p>Scales the size of the array to new size <em>new_length</em>. If <em>scale_values</em> is true, the values will be scaled too, otherwise they will be only interpolated.</p>
          <h6>GGen_Data_1D::Fill(int value)</h6>
          <p>Sets all values in the array to <em>value</em>.</p>
          <h6>GGen_Data_1D::ResizeCanvas(int new_length, int new_zero)</h6>
          <p>Changes size of the array to <em>new_length</em>. The zero from the original array is shifted to <em>new_zero</em> (measured in the original array). Values won't be interpolated. Newly created values will be filled with zeros, values that would be outside the array will be discarded.</p>
          <p>Example:</p>
          <pre>
foo = GGen_Data_1D(20, 1); // Create a 20-long array of ones
foo.ResizeCanvas(10, 5); // Only middle 10 values will remain, 5 left and 5 right values will be cropped  </pre>
          <h6>GGen_Data_1D::Clamp(int new_min, int new_max)</h6>
          <p>Clamps all values in the array so the fit iinto the range <em>new_min</em>-<em>new_max</em>. Values lower than <em>new_min</em> will be set to <em>new_min</em>, values higher than <em>new_max</em> will be set to <em>new_max</em></p>
          <h6>GGen_Data_1D::Flip()</h6>
          <p>Flips the array, so the original first value is the last value.</p>
          <h6>GGen_Data_1D::Min()</h6>
          <p>Returns the lowest value in the array.</p>
          <h6>GGen_Data_1D::Max()</h6>
          <p>Returns the highest value in the array.</p>
          <h6>GGen_Data_1D::Shift(int offset, <a href="#ggen_overflow_mode">GGen_Overflow_Mode</a> overflow_mode)</h6>
          <p>Shifts all values in the array to right (if <em>offset</em> is positive) or to left (if <em>offset</em> is negative) by <em>offset</em> values. Values shifted out from the array and newly created values shifted into the array will be dealt with according to <em>overflow_mode</em></p>
          <h6>GGen_Data_1D::Union(<a href="#ggen_data_1d">GGen_Data_1D</a> victim)</h6>
          <p>Performs a set union of the array graphs (higher of two respective values is applied) of the current array and <em>victim</em>. The <em>victim</em> will be interpolated to fit the current array.</p>
          <h6>GGen_Data_1D::Intersection(<a href="#ggen_data_1d">GGen_Data_1D</a> victim)</h6>
          <p>Performs a set intersection of the array graphs (lower of two respective values is applied) of the current array and <em>victim</em>. The <em>victim</em> will be interpolated to fit the current array.</p>
          <h6>GGen_Data_1D::Abs()</h6>
          <p>Replaces each value in the array with its absolute value.</p>
        <h5><a name="1d_advanced">Advanced data manipulation</a></h5>
          <h6>GGen_Data_1D::Monochrome(int treshold)</h6>
          <p>Sets all vales lower than or equal to <em>treshold</em> to 0 and all values higher than <em>treshold</em> to 1.</p>
          <h6>GGen_Data_1D::Normalize(<a href="#ggen_normalization_mode">GGen_Normalization_Mode</a> mode)</h6>
          <p>Makes sure that there are no slopes steeper than 45? in the array. Steeper slopes will be dealt with according to <em>mode</em>.</p>
          <h6>GGen_Data_1D::SlopeMap()</h6>
          <p>Replaces values in the array with information about steepness of slope (change in value) in that particular value.</p>
          <h6>GGen_Data_1D::Gradient(int from, int to, int from_value, int to_value, bool fill_flat)</h6>
          <p>Creates a smooth gradient between coords <em>from</em> and <em>to</em>. The values will make transition between <em>from_value</em> and <em>to_value</em>. If <em>fill_flat</em> is set to true, values with coord lower than <em>from</em> will be filled with <em>from_value</em> and value with coord higher than <em>to</em> will be filled with <em>to_value</em>.</p>
          <h6>GGen_Data_1D::Noise(int min_feature_size, max_feature_size)</h6>
          <p>Fills the array with random <a href="http://freespace.virgin.net/hugo.elias/models/m_perlin.htm">perlin noise</a>. Uses preset amplitudes, for feature sizes (size of one cell in the noise grid) larger than <em>max_feature_size</em> or lower than <em>min_feature_size</em> are treated as zero. Computational complexity increases with <em>max_feature_size</em>.</p>         
          <h6>GGen_Data_1D::<a href="#2d_noise">Noise</a>(int min_feature_size, max_feature_size, <a href="#ggen_amplitudes">GGen_Amplitudes</a> amplitudes)</h6>
          <p>Fills the array with random <a href="http://freespace.virgin.net/hugo.elias/models/m_perlin.htm">perlin noise</a>. Amplitudes are taken from <em>amplitudes</em> object, for feature sizes (size of one cell in the noise grid) larger than <em>max_feature_size</em> or lower than <em>min_feature_size</em> are treated as zero. Computational complexity increases with <em>max_feature_size</em>.</p>
          <h6>GGen_Data_1D::Smooth(int radius)</h6>
          <p>Smooths differences between values in the array. Uses linear smoothing algorithm with kernel radius <em>radius</em>. Speed doesn't change with radius.</p>    
          <h6>GGen_Data_1D::Flood(double percentage)</h6>
          <p>Changes the values in the array so only <em>percentage</em> of values is above zero. Percentage is in range 0 (everything is under 0) - 1 (everything is above 0). "Shape" of tha values won't be changed, only one number will be calculated and added to all values in the array equally.</p> 
      <h4><a name="ggen_data_2d">GGen_Data_2D</a></h4>
        <p>GGen_Data_2D represents 2-dimensional array of values. Most straightforward interpretation of such array is a bitmap, where black represents some minimal value (usually 0) and white represents some maximal value (in case of 8 bit per channel bitmaps usually 255). You will probably realize many of the GGen_Data_2D functions strongly resemble functions from classical bitmap editors - <a href="#2d_add">adding</a> changes brightness, <a href="#2d_multiply">multiplying</a> changes contrast, <a href="#2d_transformvalues">curves</a>... Working with multiple 2D arrays with GGen is generally very similiar to working with layer enabled bitmap editor, just without a fancy GUI.</p>
        <h5><a name="2d_constructors">Constructors</a></h5>
          <h6>GGen_Data_2D(int width, int height)</h6>
          <p>Creates new <a href="#ggen_data_2d">GGen_Data_2D</a> object of given <em>width</em> and <em>height</em>. All values are set to 0.</p>
          <h6>GGen_Data_2D(int width, int height, int value)</h6>
          <p>Creates new <a href="#ggen_data_2d">GGen_Data_2D</a> object of given <em>width</em> and <em>height</em>. All values are set to <em>value</em>.</p>
          <h6>GGen_Data_2D(<a href="#ggen_data_2d">GGen_Data_2D</a> original)</h6>
          <p>Creates a 1:1 copy of <em>original</em>.</p>
        <h5><a name="2d_values">Basic I/O</a></h5>
          <h6>GGen_Data_2D::GetWidth()</h6>
          <p>Returns width of the array.</p>
          <h6>GGen_Data_2D::GetHeight()</h6>
          <p>Returns height of the array.</p>
          <h6>GGen_Data_2D::GetLength()</h6>
          <p>Returns length of the array (which is always equal to width*length).</p>
          <h6>GGen_Data_2D::GetValue(int x, int y)</h6>
          <p>Returns value on coordinates [<em>x</em>, <em>y</em>].</p>
          <h6>GGen_Data_2D::GetValue(int x, int y, int width, int height)</h6>
          <p>Returns interpolated value on coordinates [<em>x</em>, <em>y</em>] as if the array had width <em>width</em> and height <em>height</em>.</p>
          <h6>GGen_Data_2D::SetValue(int x, int y, int value)</h6>
          <p>Sets value on coordinates [<em>x</em>, <em>y</em>] to <em>value</em>.</p>
          <h6>GGen_Data_2D::SetValueInRect(uint x1, uint y1, uint x2, uint y2, int value)</h6>
          <p>Sets value on all coordinates in rect between [<em>x1</em>, <em>y1</em>] and [<em>x2</em>, <em>y2</em>] to <em>value</em>. All borders are included in the rect.</p>
        <h5><a name="2d_arithmetic">Arithmetical and logical data operations</a></h5>
          <h6><a name="2d_add">GGen_Data_2D::Add(int value)</a></h6>
          <p>Adds <em>value</em> to all values in the array.</p>
          <h6>GGen_Data_2D::Add(<a href="#ggen_data_2d">GGen_Data_2D</a> addend)</h6>
          <p>Adds  <em>addend</em> to current array - values from respective coordinates are added together. Values from <em>addend</em> will be interpolated to fit the current array.</p>
          <h6>GGen_Data_2D::AddTo(int offset_x, int offset_y, <a href="#ggen_data_2d">GGen_Data_2D</a> addend)</h6>
          <p>Adds values from <em>addend</em> to their respective coordinates in current array offset by <em>offset_x</em> on horizontal axis and <em>y</em> on vertical axis. <em>Addend</em> won't be interpolated.</p>
          <h6>GGen_Data_2D::AddMasked(int value, <a href="#ggen_data_2d">GGen_Data_2D</a> mask, bool relative_mode)</h6>
          <p>Adds <em>value</em> to all values in the array. The percentage of value added depends on respective value in <em>mask</em>. In <em>relative_mode</em>, the <em>mask</em> is interh6ted as <em>mask</em> minimum = 0% of value and <em>mask</em> maximum = 100%, otherwise 0 = 0% of value and 255 = 100%. Both <em>addend</em> and <em>mask</em> will be interpolated to fit the current array.</p>
          <h6>GGen_Data_2D::AddMasked(<a href="#ggen_data_2d">GGen_Data_2D</a> addend, <a href="#ggen_data_2d">GGen_Data_2D</a> mask, bool relative_mode)</h6>
          <p>Adds values from <em>addend</em> to their respective coordinates in current array. The percentage of value added depends on respective value in <em>mask</em>. In <em>relative_mode</em>, the <em>mask</em> is interh6ted as <em>mask</em> minimum = 0% of value and <em>mask</em> maximum = 100%, otherwise 0 = 0% of value and 255 = 100%. Both <em>addend</em> and <em>mask</em> will be interpolated to fit the current array.</p>
          <h6><a name="2d_multiply">GGen_Data_2D::Multiply(int value)</a></h6>
          <p>Multiplies all values from the array by <em>value</em>.</p>
          <h6>GGen_Data_2D::Multiply(<a href="#ggen_data_2d">GGen_Data_2D</a> factor)</h6>
          <p>Multiplies all values from the current array by respective values from <em>factor</em>. Values from <em>factor</em> will be interpolated to fit the current array.</p>
          <h6>GGen_Data_2D::Invert()</h6>
          <p>Flips signs of all values in the array.</p>
          <h6>GGen_Data_2D::Scale(double ratio, bool scale_values)</h6>
          <p>Scales the size of the array by <em>ratio</em>. If <em>scale_values</em> is true, the values will be scaled too, otherwise they will be only interpolated.</p> 
          <h6>GGen_Data_2D::ScaleTo(int new_x, int new_y, bool scale_values)</h6>
          <p>Scales the size of the array to new width <em>new_width</em> and new height <em>new_height</em>. If <em>scale_values</em> is true, the values will be scaled too, otherwise they will be only interpolated.</p>
          <h6>GGen_Data_2D::Fill(int value)</h6>
          <p>Sets all values in the array to <em>value</em>.</p>      
          <h6>GGen_Data_1D::ResizeCanvas(int new_x, int new_y, int new_zero_x, int new_zero_y)</h6>
          <p>Scales the size of the array to new width <em>new_width</em> and new height <em>new_height</em>. The zero from the original array is shifted to [<em>new_zero_x</em>, <em>new_zero_y</em>] (measured in the original array). Values won't be interpolated. Newly created values will be filled with zeros, values that would be outside the array will be discarded.</p>
          <h6>GGen_Data_1D::Clamp(int new_min, int new_max)</h6>
          <p>Clamps all values in the array so the fit iinto the range <em>new_min</em>-<em>new_max</em>. Values lower than <em>new_min</em> will be set to <em>new_min</em>, values higher than <em>new_max</em> will be set to <em>new_max</em></p>
          <h6>GGen_Data_1D::Flip(<a href="#ggen_direction">GGen_Direction</a> direction)</h6>
          <p>Flips the array along axis given by <em>direction</em>.</p>
          <h6>GGen_Data_2D::Min()</h6>
          <p>Returns the lowest value in the array.</p>
          <h6>GGen_Data_2D::Max()</h6>
          <p>Returns the highest value in the array.</p>
          <h6>GGen_Data_2D::Shift(int offset, <a href="#ggen_overflow_mode">GGen_Overflow_Mode</a> overflow_mode)</h6>
          <p>Shifts all values in the array to <em>direction</em> by <em>offset</em> by <em>offset</em> values. Values shifted out from the array and newly created values shifted into the array will be dealt with according to <em>overflow_mode</em></p>
          <h6>GGen_Data_2D::Shift(<a href="#ggen_data_1d">GGen_Data_1D</a> profile, <a href="#ggen_overflow_mode">GGen_Overflow_Mode</a> overflow_mode)</h6>
          <p>Shifts all values in the array to <em>direction</em> by <em>offset</em> by respective value from <em>profile</em>. Values shifted out from the array and newly created values shifted into the array will be dealt with according to <em>overflow_mode</em></p>
          <h6>GGen_Data_2D::Union(<a href="#ggen_data_2d">GGen_Data_2D</a> victim)</h6>
          <p>Performs a set union of the array graphs (higher of two respective values is applied) of the current array and <em>victim</em>. The <em>victim</em> will be interpolated to fit the current array.</p>
          <h6>GGen_Data_2D::UnionTo(int offset_x, int offset_y, <a href="#ggen_data_2d">GGen_Data_2D</a> victim)</h6>
          <p>Performs a set union of the array graphs (higher of two respective values is applied) of the current array and <em>victim</em> using their respective coordinates in current array offset by <em>offset_x</em> on horizontal axis and <em>offset_y</em> on vertical axis. <em>Victim</em> won't be interpolated.</p>        
          <h6>GGen_Data_2D::Intersection(<a href="#ggen_data_2d">GGen_Data_2D</a> victim)</h6>
          <p>Performs a set intersection of the array graphs (lower of two respective values is applied) of the current array and <em>victim</em>. The <em>victim</em> will be interpolated to fit the current array.</p>
          <h6>GGen_Data_2D::IntersectionTo(int offset_x, int offset_y, <a href="#ggen_data_2d">GGen_Data_2D</a> victim)</h6>
          <p>Performs a set intersection of the array graphs (lower of two respective values is applied) of the current array and <em>victim</em> using their respective coordinates in current array offset by <em>offset_x</em> on horizontal axis and <em>offset_y</em> on vertical axis. <em>Victim</em> won't be interpolated.</p>
          <h6>GGen_Data_2D::Rotate(<a href="#ggen_angle">GGen_Angle</a> angle)</h6>
          <p>Rotates the array by <em>angle</em> degrees clockwise.</p>
          <h6>GGen_Data_2D::Combine(<a href="#ggen_data_2d">GGen_Data_2D</a> victim, <a href="#ggen_data_2d">GGen_Data_2D</a> mask)</h6>
          <p>Combines (combination of values from both arrays is used) values from <em>addend</em> with their respective coordinates in current array. The percentage of value added depends on respective value in <em>mask</em>. In <em>relative_mode</em>, the <em>mask</em> is interh6ted as <em>mask</em> minimum = 0% of value and <em>mask</em> maximum = 100%, otherwise 0 = 0% of value and 255 = 100%. Both <em>addend</em> and <em>mask</em> will be interpolated to fit the current array.</p>
          <h6>GGen_Data_2D::ReplaceValue(int needle, int replace)</h6>
          <p>Replaces all occurences of <em>needle</em> with <em>replace</em>.</p>
          <h6>GGen_Data_2D::Abs()</h6>
          <p>Replaces each value in the array with its absolute value.</p>
          <h6>GGen_Data_2D::Monochrome(int treshold)</h6>
          <p>Sets all values lower than or equal to <em>treshold</em> to 0 and all values higher than <em>treshold</em> to 1.</p>
          <h6>GGen_Data_2D::SelectValue(int value)</h6>
          <p>Sets all values equal to <em>value</em> to 1 and all other values to 0.</p>
          <h6>GGen_Data_2D::<a name="2d_project">Project</a>(<a href="#ggen_data_1d">GGen_Data_1D</a> profile, <a href="#ggen_direction">GGen_Direction</a> direction)</h6>
          <p>Extrudes <em>profile</em> across whole array in <em>direction</em>.</p> 
          <h6><a href="#ggen_data_1d">GGen_Data_1D</a> GGen_Data_2D::GetProfile(<a href="#ggen_direction">GGen_Direction</a> direction)</h6>
          <p>Returns one row (if <em>direction</em> is GGEN_HORIZONTAL) or one column (otherwise) as separate <a href="#ggen_data_1d">GGen_Data_1D</a> array (changing the returned array won't change the current object).</p> 
        <h5><a name="2d_advanced">Advanced data manipulation</a></h5>
          <h6>GGen_Data_2D::<a name="2d_transformvalues">TransformValues</a>(<a href="#ggen_data_1d">GGen_Data_1D</a> profile, bool relative)</h6>
          <p>Replaces each value with a corresponding value from <em>profile</em>. Coordinate of the corresponding value is determined by the original value - the higher the value, the higher the coordinate is. Only values higher than zero are affected. If <em>relative</em> is false, then maximum value corresponds to the rightmost coordinate (0 always corresponds to 0), else the values are treated in range &lt;0, 255&gt; only. The input profile will be smoothed to prevent sharp steps on the transformed terrain.</p>
          <h6>GGen_Data_2D::Gradient(int from_x, int form_y, int to_x, int to_y, int from_value, int to_value, bool fill_flat)</h6>
          <p>Creates a smooth gradient between coords [<em>from_x</em>, <em>from_y</em>] and [<em>to_x</em>, <em>to_y</em>]. The values will make transition between <em>from_value</em> and <em>to_value</em>. If <em>fill_flat</em> is set to true, values outside the gradient strip will be filled with <em>from_value</em> or <em>to_value</em>, whichever is closer.</p>
          <h6>GGen_Data_2D::<a name="2d_gradient">Gradient</a>(int from_x, int form_y, int to_x, int to_y, <a href="#ggen_data_1d">GGen_Data_1D</a> profile, bool fill_flat)</h6>
          <p>Creates a smooth gradient between coords [<em>from_x</em>, <em>from_y</em>] and [<em>to_x</em>, <em>to_y</em>]. The values will depend on respective values from <em>profile</em>, in the "from" point will the values be taken from the <em>profile</em> from coord 0 and value for the "to" point will be taken from the last value of the <em>profile</em>. If <em>fill_flat</em> is set to true, values outside the gradient strip will be filled with values from the start or end of the <em>profile</em>.</p>
          <h6>GGen_Data_2D::RadialGradient(int center_x, int center_y, int radius, int from_value, int to_value, bool fill_flat)</h6>
          <p>Creates a smooth radial gradient centered on coord [<em>center_x</em>, <em>center_y</em>]. The values will make transition between <em>from_value</em> in the center to <em>to_value</em> on the outer rim. If <em>fill_flat</em> is set to true, values outside the circle will be filled with <em>to_value</em>.</p>
          <h6>GGen_Data_2D::<a name="2d_radialgradient">RadialGradient</a>(int center_x, int center_y, int radius, <a href="#ggen_data_1d">GGen_Data_1D</a> profile, bool fill_flat)</h6>
          <p>Creates a smooth radial gradient centered on coord [<em>center_x</em>, <em>center_y</em>]. The values will depend on respective values from <em>profile</em>, in the center the values will be taken from the <em>profile</em> from coord 0 and values for the outer rim will be taken from the last value of the <em>profile</em>. If <em>fill_flat</em> is set to true, values outside the circle will be filled with <em>to_value</em>.</p>
          <h6>GGen_Data_2D::Noise(int min_feature_size, max_feature_size)</h6>
          <p>Fills the array with random <a href="http://freespace.virgin.net/hugo.elias/models/m_perlin.htm">perlin noise</a>. Uses preset amplitudes, for feature sizes (size of one cell in the noise grid) larger than <em>max_feature_size</em> or lower than <em>min_feature_size</em> are treated as zero. Computational complexity increases with <em>max_feature_size</em>.</p>         
          <h6>GGen_Data_2D::<a href="#2d_noise">Noise</a>(int min_feature_size, max_feature_size, <a href="#ggen_amplitudes">GGen_Amplitudes</a> amplitudes)</h6>
          <p>Fills the array with random <a href="http://freespace.virgin.net/hugo.elias/models/m_perlin.htm">perlin noise</a>. Amplitudes are taken from <em>amplitudes</em> object, for feature sizes (size of one cell in the noise grid) larger than <em>max_feature_size</em> or lower than <em>min_feature_size</em> are treated as zero. Computational complexity increases with <em>max_feature_size</em>.</p>
          <h6>GGen_Data_2D::Smooth(int radius)</h6>
          <p>Smooths differences between values in the array. Uses linear smoothing algorithm with kernel radius <em>radius</em>. Speed doesn't change with radius.</p>    
          <h6>GGen_Data_2D::Flood(double percentage)</h6>
          <p>Changes the values in the array so only <em>percentage</em> of values is above zero. Percentage is in range 0 (everything is under 0) - 1 (everything is above 0). "Shape" of tha values won't be changed, only one number will be calculated and added to all values in the array equally.</p>
          <h6>GGen_Data_2D::Pattern(<a href="#ggen_data_2d">GGen_Data_2D</a> pattern)</h6>
          <p>Fills the array with data from <em>pattern</em>. If <em>pattern</em> is smaller than the current array, it will be repeated as necessary to fit.</p> 
          <h6>GGen_Data_2D::Scatter(bool relative)</h6>
          <p>Replaces height information with only 0s and 1s. Each value has 1/(max - value) chance to become. If <em>relative</em> is true, max is 255.</p> 
          <h6>GGen_Data_2D::SlopeMap()</h6>
          <p>Replaces values in the array with information about steepness of slope (change in value) in that particular value.</p> 
          <h6>GGen_Data_2D::Normalize(<a href="#ggen_normalization_mode">GGen_Normalization_Mode</a> mode)</h6>
          <p>Replaces up/downhills steeper than 1 height level per tile with 1 height level per tile slope.</p> 
          <h6>GGen_Data_2D::Transform(int a11, int a12, int a21, int a22, bool preserve_size)</h6>
          <p>Applies a linear transformation matrix on the current array using to point [0, 0] as origin. The matrix must be invertible (the first row must not be multiple of  the second, neither row must be 0). If <em>preserve_size</em> is true the result will be resized to fit the transformed array.</p> 
          <h6>GGen_Data_2D::Rotate(int angle, bool preserve_size)</h6>
          <p>Rotates the array by <em>angle</em> degrees counter-clockwise. If <em>preserve_size</em> is true the result will be resized to fit the rotated array.</p> 
          <h6>GGen_Data_2D::Shear(int horizontal_shear, int vertical_shear, bool preserve_size)</h6>
          <p>Shears the array by <em>horizontal_shear</em>-multiple of its width horizontally and by <em>vertical_shear</em>-multiple of its height vertically. If <em>preserve_size</em> is true the result will be resized to fit the sheared array.</p> 
        <h5><a name="2d_interaction">API interaction</a></h5>
          <h6>GGen_Data_2D::<a name="2d_returnas">ReturnAs</a>(string label)</h6>
          <p>Exports current array labeled as <em>label</em> from the script. Return callback will be called by the API.</p> 
      <h4><a name="ggen_amplitudes">GGen_Amplitudes</a></h4>
        <p>GGen_Amplitudes is an object storing amplitude settings for <a href="#1d_noise">GGen_Data_1D::Noise</a> and <a href="#2d_noise">GGen_Data_2D::Noise</a>.</p>
        <p>All amplitudes are preset to 0.</p>
        <h6>GGen_Amplitudes(int max_feature_size)</h6>
        <p>Creates a GGen_Amplitudes object with space  for amplitudes for features size up to <em>max_feature_size</em>.</p>
        <h6>GGen_Amplitudes::AddAmplitude(int feature_size, in amplitude)</h6>
        <p>Adds one <em>amplitude</em> to the object. The amplitude will be paired with the <em>feature_size</em>.</p>
      <h4><a name="interaction">API Interaction</a></h4>
        <p>Interaction methods allow the scripts to communicate with the C-code outside GeoGen library.</p>
        <h5><a name="interaction_args">Script argument support</a></h5>
          <p>Arguments represent additional information requested by scripts. Each argument is represented by:</p>
          <ul>
            <li><em>name</em> - unique internal tag used to identify the argument. Used by <a href="#interaction_getparam">GGen_GetParam</a> to retieve the value of the argument.</li>
            <li><em>label</em> - Human-readable name used to represent the argument in (G)UI.</li>
            <li><em>description</em> - Detailed description describing the argument.</li>
            <li><em>default_value</em> - Value used in case user doesn't set the argument.</li>
          </ul>
          <p>Arguments can be inicialized only within the <a href="#layout">GetInfo</a> function when the engine requests "<em>args</em>" info.</p>
          <h6>GGen_AddIntArg(string name, string label, string description, int default_value, int min_value, int max_value, int step_size)</h6>
          <p>Requests integer in range <em>min_value</em>-<em>max_value</em>. Both boundaries are included. <em>step_size</em> denotes size of one step if slider is used in a GUI to represent this argument.</p>
          <h6>GGen_AddBoolArg(string name, string label, string description, int default_values)</h6>
          <p>Requests a boolean (either 0 or 1) value.</p>
          <h6>GGen_AddEnumArg(string name, string label, string description, int default_value, string values)</h6>
          <p>Requests one choice from a list of strings. Strings are defined in parameter <em>values</em>, individual items are separated by semicolon. Internal representation (used by <em>default_value</em> parameter and <a href="#interaction_getarg">GGen_GetArg</a> function) is integer in range 0-"number of values - 1" where 0 is the first value in the <em>values</em> list and "number of values - 1" is the last.</p>
          <h6><a name="interaction_getparam">GGen_GetParam</a>(string name)</h6>
          <p>Retrieves value of an argument named <em>name</em>. Default value is returned in case user did not set the value. This function can be used only within the body of the <a href="#layout">Generate</a> function. The value is always retrieved as integer.</p>
        <h5><a name="progress">Progress reporting</a></h5>
          <p>Scripts might sometimes take a lot of time to process. Showing some sort of progress to the user may help to mitigate the "what is happening in the magic box?" effect. Progress in GeoGen is defined by two integers: the <em>max_progress</em> and the <em>current_progress</em>. The <em>max_progress</em> represents the total length of the "progress bar" while the <em>current_progress</em> represents its finished portion.</p>
          <h6>GGen_InitProgress(int max_progress)</h6>
          <p>Sets the <em>max_progress</em>. If you are using only GGen_IncreaseProgress to change the counter, <em>max_progress</em> should be equal to number of GGen_IncreaseProgress calls + 1.</p>
          <h6>GGen_SetProgress(int current_progress)</h6>
          <p>Sets the <em>current_progress</em>.</p>
          <h6>GGen_IncreaseProgress()</h6>
          <p>Increases <em>current_progress</em> by 1.</p>
      <h4><a name="presets">Presets</a></h4>
      <p>Presets represent constant GeoGen objects hardcoded the source code. These objects are available in all scripts' <a href="#layout">Generate</a> function.</p>
        <h5>GGEN_STD_NOISE</h5>
        <p>Balanced amplitude setting suitable for most situations where you need to generate noise without too much code overhead.</p>
        <p>Equivalent Squirrel code:</p>
        <pre>
local ggen_std_noise = GGen_Amplitudes(4096);

ggen_std_noise.AddAmplitude(1, 3 * 15);
ggen_std_noise.AddAmplitude(2, 7 * 15);
ggen_std_noise.AddAmplitude(4, 10 * 15);
ggen_std_noise.AddAmplitude(8, 20 * 15);
ggen_std_noise.AddAmplitude(16, 50 * 15);
ggen_std_noise.AddAmplitude(32, 75 * 15);
ggen_std_noise.AddAmplitude(64, 150 * 15);
ggen_std_noise.AddAmplitude(128, 250 * 15);
ggen_std_noise.AddAmplitude(256, 400 * 15);
ggen_std_noise.AddAmplitude(512, 600 * 15);
ggen_std_noise.AddAmplitude(1024, 1000 * 15);
ggen_std_noise.AddAmplitude(2048, 1400 * 15);
ggen_std_noise.AddAmplitude(4096, 2000 * 15);        
        </pre>
        <h5>GGEN_NATURAL_PROFILE</h5>
        <p>Preset useful when used with <a href="#2d_transformvalues">TransformValues</a> function to create more natural height distribution.</p>
        <p>Equivalent Squirrel code:</p>
        <pre>
local ggen_natural_profile GGen_Data_1D(6);
ggen_natural_profile.SetValue(0, 1);
ggen_natural_profile.SetValue(1, 18 * 15);
ggen_natural_profile.SetValue(2, 43 * 15);
ggen_natural_profile.SetValue(3, 91 * 15);
ggen_natural_profile.SetValue(4, 163 * 15);
ggen_natural_profile.SetValue(5, 255 * 15);
        </pre>
      <h4><a name="constants_and_enums">Support constants and enumerations</a></h4>
        <h5><a name="constants">Constants</a></h5>
          <h6>GGEN_MAX_HEIGHT</h6>
          <p>The maximum value one cell can hold, preset to 32767.</p>
          <h6>GGEN_MIN_HEIGHT</h6>
          <p>The minimum value one cell can hold, preset to -32767.</p>
          <h6>GGEN_INVALID_HEIGHT</h6>
          <p>The value used to mark an invalid cell, preset to -32768.</p>
        <h5><a name="ggen_normalization_mode">GGen_Normalization_Mode</a></h5>
          <h6>GGEN_SUBSTRACTIVE</h6>
          <p>The normalization will be performed only by substracting from values (lowering steep uphills to 45&deg;).</p>
          <h6>GGEN_ADDITIVE</h6>
          <p>The normalization will be performed only by adding to values (heightening steep downhills to 45&deg;).</p>
        <h5><a name="ggen_overflow_mode">GGen_Overflow_Mode</a></h5>
          <h6>GGEN_CYCLE</h6>
          <p>Values disappearing on one side of the array will appear on the other side.</p>
          <h6>GGEN_DISCARD</h6>
          <p>Disappearing values will be discarded, newly appearing values will be set to 0.</p>
          <h6>GGEN_DISCARD_AND_FILL</h6>
          <p>Disappearing values will be discarded, newly appearing values will be set to closest valid value from the original array (only along the shift axis in 2D).</p>
        <h5><a name="ggen_direction">GGen_Direction</a></h5>
          <h6>GGEN_HORIZONTAL</h6>
          <p>Operation will be performed along the X axis.</p>
          <h6>GGEN_VERTICAL</h6>
          <p>Operation will be performed along the Y axis.</p>
  <h2><a name="license">License</a></h2>
    <p>Copyright Matěj Zábský, 2009.</p>
    <p>GeoGen is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 2 of the License, or (at your option) any later version.</p>
    <p>GeoGen is distributed in the hope that it will be useful,but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.</p>
    <p>You should have received a copy of the GNU General Public License along with GeoGen.  If not, see <a href="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</a>.</p>
  </body>
</html>