/** \file
 *  This C source file was generated by $ANTLR version 3.5.1
 *
 *     -  From the grammar source file : C:\\Users\\matej_000\\Source\\Repos\\geogen\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g
 *     -                            On : 2015-03-14 16:25:40
 *     -           for the tree parser : GeoGenScriptDeclsTreeParser
 *
 * Editing it, at least manually, is not wise.
 *
 * C language generator and runtime by Jim Idle, jimi|hereisanat|idle|dotgoeshere|ws.
 *
 *
*/
// [The "BSD license"]
// Copyright (c) 2005-2009 Jim Idle, Temporal Wave LLC
// http://www.temporal-wave.com
// http://www.linkedin.com/in/jimidle
//
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. The name of the author may not be used to endorse or promote products
//    derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

/* -----------------------------------------
 * Include the ANTLR3 generated header file.
 */
#include    "GeoGenScriptDecls.h"
/* ----------------------------------------- */





/* MACROS that hide the C interface implementations from the
 * generated code, which makes it a little more understandable to the human eye.
 * I am very much against using C pre-processor macros for function calls and bits
 * of code as you cannot see what is happening when single stepping in debuggers
 * and so on. The exception (in my book at least) is for generated code, where you are
 * not maintaining it, but may wish to read and understand it. If you single step it, you know that input()
 * hides some indirect calls, but is always referring to the input stream. This is
 * probably more readable than ctx->input->istream->input(snarfle0->blarg) and allows me to rejig
 * the runtime interfaces without changing the generated code too often, without
 * confusing the reader of the generated output, who may not wish to know the gory
 * details of the interface inheritance.
 */

#define		CTX	ctx

/* Aids in accessing scopes for grammar programmers
 */
#undef	SCOPE_TYPE
#undef	SCOPE_STACK
#undef	SCOPE_TOP
#define	SCOPE_TYPE(scope)   pGeoGenScriptDecls_##scope##_SCOPE
#define SCOPE_STACK(scope)  pGeoGenScriptDecls_##scope##Stack
#define	SCOPE_TOP(scope)    ctx->pGeoGenScriptDecls_##scope##Top
#define	SCOPE_SIZE(scope)		ctx->pGeoGenScriptDecls_##scope##Stack_limit
#define SCOPE_INSTANCE(scope, i)	(ctx->SCOPE_STACK(scope)->get(ctx->SCOPE_STACK(scope),i))

/* Macros for accessing things in the parser
 */

#undef	    PARSER
#undef	    RECOGNIZER
#undef	    HAVEPARSEDRULE
#undef	    INPUT
#undef	    STRSTREAM
#undef	    HASEXCEPTION
#undef	    EXCEPTION
#undef	    MATCHT
#undef	    MATCHANYT
#undef	    FOLLOWSTACK
#undef	    FOLLOWPUSH
#undef	    FOLLOWPOP
#undef	    PRECOVER
#undef	    PREPORTERROR
#undef	    LA
#undef	    LT
#undef	    CONSTRUCTEX
#undef	    CONSUME
#undef	    MARK
#undef	    REWIND
#undef	    REWINDLAST
#undef	    PERRORRECOVERY
#undef	    HASFAILED
#undef	    FAILEDFLAG
#undef	    RECOVERFROMMISMATCHEDSET
#undef	    RECOVERFROMMISMATCHEDELEMENT
#undef	    BACKTRACKING
#undef      ADAPTOR
#undef	    RULEMEMO
#undef		SEEK
#undef		INDEX
#undef		DBG

#define	    PARSER							ctx->pTreeParser
#define	    RECOGNIZER						PARSER->rec
#define		PSRSTATE						RECOGNIZER->state
#define	    HAVEPARSEDRULE(r)				RECOGNIZER->alreadyParsedRule(RECOGNIZER, r)
#define	    INPUT							PARSER->ctnstream
#define		ISTREAM							INPUT->tnstream->istream
#define	    STRSTREAM						INPUT->tnstream
#define	    HASEXCEPTION()					(PSRSTATE->error == ANTLR3_TRUE)
#define	    EXCEPTION						PSRSTATE->exception
#define	    MATCHT(t, fs)					RECOGNIZER->match(RECOGNIZER, t, fs)
#define	    MATCHANYT()						RECOGNIZER->matchAny(RECOGNIZER)
#define	    FOLLOWSTACK					    PSRSTATE->following
#define	    FOLLOWPUSH(x)					FOLLOWSTACK->push(FOLLOWSTACK, ((void *)(&(x))), NULL)
#define	    FOLLOWPOP()						FOLLOWSTACK->pop(FOLLOWSTACK)
#define	    PRECOVER()						RECOGNIZER->recover(RECOGNIZER)
#define	    PREPORTERROR()					RECOGNIZER->reportError(RECOGNIZER)
#define	    LA(n)							ISTREAM->_LA(ISTREAM, n)
#define	    LT(n)							INPUT->tnstream->_LT(INPUT->tnstream, n)
#define	    CONSTRUCTEX()					RECOGNIZER->exConstruct(RECOGNIZER)
#define	    CONSUME()						ISTREAM->consume(ISTREAM)
#define	    MARK()							ISTREAM->mark(ISTREAM)
#define	    REWIND(m)						ISTREAM->rewind(ISTREAM, m)
#define	    REWINDLAST()					ISTREAM->rewindLast(ISTREAM)
#define	    PERRORRECOVERY					PSRSTATE->errorRecovery
#define	    FAILEDFLAG						PSRSTATE->failed
#define	    HASFAILED()						(FAILEDFLAG == ANTLR3_TRUE)
#define	    BACKTRACKING					PSRSTATE->backtracking
#define	    RECOVERFROMMISMATCHEDSET(s)		RECOGNIZER->recoverFromMismatchedSet(RECOGNIZER, s)
#define	    RECOVERFROMMISMATCHEDELEMENT(e)	RECOGNIZER->recoverFromMismatchedElement(RECOGNIZER, s)
#define     ADAPTOR                         INPUT->adaptor
#define		RULEMEMO						PSRSTATE->ruleMemo
#define		SEEK(n)							ISTREAM->seek(ISTREAM, n)
#define		INDEX()							ISTREAM->index(ISTREAM)
#define		DBG								RECOGNIZER->debugger



#define		TOKTEXT(tok, txt)				tok, (pANTLR3_UINT8)txt

/* The 4 tokens defined below may well clash with your own #defines or token types. If so
 * then for the present you must use different names for your defines as these are hard coded
 * in the code generator. It would be better not to use such names internally, and maybe
 * we can change this in a forthcoming release. I deliberately do not #undef these
 * here as this will at least give you a redefined error somewhere if they clash.
 */
#define	    UP	    ANTLR3_TOKEN_UP
#define	    DOWN    ANTLR3_TOKEN_DOWN
#define	    EOR	    ANTLR3_TOKEN_EOR
#define	    INVALID ANTLR3_TOKEN_INVALID


/* =============================================================================
 * Functions to create and destroy scopes. First come the rule scopes, followed
 * by the global declared scopes.
 */


/* globalAttributeScopeFuncDecl(scope)
 */
/* -----------------------------------------------------------------------------
 * Function declaration for creating a GeoGenScriptDecls_BlockScope scope set
 */
static pGeoGenScriptDecls_BlockScope_SCOPE   pGeoGenScriptDecls_BlockScopePush(pGeoGenScriptDecls ctx);
static void ANTLR3_CDECL BlockScopeFree(pGeoGenScriptDecls_BlockScope_SCOPE scope);
/* ----------------------------------------------------------------------------- */


/* globalAttributeScopeFuncs(scope)
 */
/* attributeFuncs(scope)
 */

static void ANTLR3_CDECL BlockScopeFree(pGeoGenScriptDecls_BlockScope_SCOPE scope)
{
    ANTLR3_FREE(scope);
}

/** \brief Allocate initial memory for a GeoGenScriptDecls BlockScope scope variable stack entry and
 *         add it to the top of the stack.
 *
 * \remark
 * By default the structure is freed with ANTLR_FREE(), but you can use the
 * the \@init action to install a pointer to a custom free() routine by
 * adding the code:
 * \code
 *   ctx->pGeoGenScriptDecls_BlockScopeTop->free = myroutine;
 * \endcode
 *
 * With lots of comments of course! The routine should be declared in
 * \@members { } as:
 * \code
 *   void ANTLR3_CDECL myfunc( pGeoGenScriptDecls_BlockScope_SCOPE ptr).
 * \endcode
 *
 * It should perform any custom freeing stuff that you need (call ANTLR_FREE3, not free()
 * NB: It should not free the pointer it is given, which is the scope stack entry itself
 * and will be freed by the function that calls your custom free routine.
 *
 */
static pGeoGenScriptDecls_BlockScope_SCOPE
pGeoGenScriptDecls_BlockScopePush(pGeoGenScriptDecls ctx)
{
    /* Pointer used to create a new set of attributes
     */
    pGeoGenScriptDecls_BlockScope_SCOPE      newAttributes;

    /* Allocate the memory for a new structure if we need one.
     */
    if (ctx->pGeoGenScriptDecls_BlockScopeStack->size(ctx->pGeoGenScriptDecls_BlockScopeStack) > ctx->pGeoGenScriptDecls_BlockScopeStack_limit)
    {
        // The current limit value was less than the number of scopes available on the stack so
        // we can just reuse one. Our limit tracks the stack count, so the index of the entry we want
        // is one less than that, or conveniently, the current value of limit.
        //
        newAttributes = (pGeoGenScriptDecls_BlockScope_SCOPE)ctx->pGeoGenScriptDecls_BlockScopeStack->get(ctx->pGeoGenScriptDecls_BlockScopeStack, ctx->pGeoGenScriptDecls_BlockScopeStack_limit);
    }
    else
    {
        // Need a new allocation
        //
        newAttributes = (pGeoGenScriptDecls_BlockScope_SCOPE) ANTLR3_MALLOC(sizeof(GeoGenScriptDecls_BlockScope_SCOPE));
        if  (newAttributes != NULL)
        {
            /* Standard ANTLR3 library implementation
             */
            ctx->pGeoGenScriptDecls_BlockScopeStack->push(ctx->pGeoGenScriptDecls_BlockScopeStack, newAttributes, (void (*)(void *))BlockScopeFree);
        }
    }

    // Blank out any previous free pointer, the user might or might install a new one.
    //
    newAttributes->free = NULL;

    // Indicate the position in the available stack that the current level is at
    //
    ctx->pGeoGenScriptDecls_BlockScopeStack_limit++;

	/* Return value is the pointer to the new entry, which may be used locally
	 * without de-referencing via the context.
     */
    return  newAttributes;
}






/* ============================================================================= */

/* =============================================================================
 * Start of recognizer
 */


/** \brief Table of all token names in symbolic order, mainly used for
 *         error reporting.
 */
pANTLR3_UINT8   GeoGenScriptDeclsTokenNames[94+4]
     = {
        (pANTLR3_UINT8) "<invalid>",       /* String to print to indicate an invalid token */
        (pANTLR3_UINT8) "<EOR>",
        (pANTLR3_UINT8) "<DOWN>",
        (pANTLR3_UINT8) "<UP>",
        (pANTLR3_UINT8) "AS",
        (pANTLR3_UINT8) "BLOCK",
        (pANTLR3_UINT8) "BREAK",
        (pANTLR3_UINT8) "CASE",
        (pANTLR3_UINT8) "COLLECTION",
        (pANTLR3_UINT8) "COLLECTION_ITEM",
        (pANTLR3_UINT8) "COLON",
        (pANTLR3_UINT8) "COMMA",
        (pANTLR3_UINT8) "COMMENT",
        (pANTLR3_UINT8) "CONDITION_EXPRESSION",
        (pANTLR3_UINT8) "CONTINUE",
        (pANTLR3_UINT8) "COORDINATE",
        (pANTLR3_UINT8) "DECLARATIONS",
        (pANTLR3_UINT8) "DEFAULT",
        (pANTLR3_UINT8) "ELSE",
        (pANTLR3_UINT8) "ENUM",
        (pANTLR3_UINT8) "ESCAPED",
        (pANTLR3_UINT8) "FALSE_LIT",
        (pANTLR3_UINT8) "FOR",
        (pANTLR3_UINT8) "FUNCTION",
        (pANTLR3_UINT8) "GLOBAL",
        (pANTLR3_UINT8) "IDENTCHAIN",
        (pANTLR3_UINT8) "IDENTIFIER",
        (pANTLR3_UINT8) "IF",
        (pANTLR3_UINT8) "INCREMENT_EXPRESSION",
        (pANTLR3_UINT8) "INITIALIZATION_EXPRESSION",
        (pANTLR3_UINT8) "INTEGER",
        (pANTLR3_UINT8) "LEFT_BRACKET",
        (pANTLR3_UINT8) "LEFT_CURLY_BRACKET",
        (pANTLR3_UINT8) "LEFT_SQUARE_BRACKET",
        (pANTLR3_UINT8) "METADATA",
        (pANTLR3_UINT8) "NUMBER",
        (pANTLR3_UINT8) "OPERATOR_ASSIGN",
        (pANTLR3_UINT8) "OPERATOR_ASSIGN_AND",
        (pANTLR3_UINT8) "OPERATOR_ASSIGN_DIVIDE",
        (pANTLR3_UINT8) "OPERATOR_ASSIGN_LSHIFT",
        (pANTLR3_UINT8) "OPERATOR_ASSIGN_MINUS",
        (pANTLR3_UINT8) "OPERATOR_ASSIGN_MODULO",
        (pANTLR3_UINT8) "OPERATOR_ASSIGN_OR",
        (pANTLR3_UINT8) "OPERATOR_ASSIGN_PLUS",
        (pANTLR3_UINT8) "OPERATOR_ASSIGN_RSHIFT",
        (pANTLR3_UINT8) "OPERATOR_ASSIGN_TIMES",
        (pANTLR3_UINT8) "OPERATOR_ASSIGN_XOR",
        (pANTLR3_UINT8) "OPERATOR_BIT_AND",
        (pANTLR3_UINT8) "OPERATOR_BIT_OR",
        (pANTLR3_UINT8) "OPERATOR_BIT_XOR",
        (pANTLR3_UINT8) "OPERATOR_CALL",
        (pANTLR3_UINT8) "OPERATOR_DECREMENT",
        (pANTLR3_UINT8) "OPERATOR_DECREMENT_POST",
        (pANTLR3_UINT8) "OPERATOR_DECREMENT_PRE",
        (pANTLR3_UINT8) "OPERATOR_DIVIDE",
        (pANTLR3_UINT8) "OPERATOR_DOT",
        (pANTLR3_UINT8) "OPERATOR_EQUAL_TO",
        (pANTLR3_UINT8) "OPERATOR_EXPR_IF",
        (pANTLR3_UINT8) "OPERATOR_GREATER_THAN",
        (pANTLR3_UINT8) "OPERATOR_GREATER_THAN_OR_EQUAL_TO",
        (pANTLR3_UINT8) "OPERATOR_INCREMENT",
        (pANTLR3_UINT8) "OPERATOR_INCREMENT_POST",
        (pANTLR3_UINT8) "OPERATOR_INCREMENT_PRE",
        (pANTLR3_UINT8) "OPERATOR_IS",
        (pANTLR3_UINT8) "OPERATOR_LESS_THAN",
        (pANTLR3_UINT8) "OPERATOR_LESS_THAN_OR_EQUAL_TO",
        (pANTLR3_UINT8) "OPERATOR_LSHIFT",
        (pANTLR3_UINT8) "OPERATOR_MINUS",
        (pANTLR3_UINT8) "OPERATOR_MINUS_UN",
        (pANTLR3_UINT8) "OPERATOR_MODULO",
        (pANTLR3_UINT8) "OPERATOR_NOT",
        (pANTLR3_UINT8) "OPERATOR_NOT_EQUAL_TO",
        (pANTLR3_UINT8) "OPERATOR_PLUS",
        (pANTLR3_UINT8) "OPERATOR_PLUS_UN",
        (pANTLR3_UINT8) "OPERATOR_RELATIVE",
        (pANTLR3_UINT8) "OPERATOR_REL_AND",
        (pANTLR3_UINT8) "OPERATOR_REL_OR",
        (pANTLR3_UINT8) "OPERATOR_RSHIFT",
        (pANTLR3_UINT8) "OPERATOR_SUBSCRIPT",
        (pANTLR3_UINT8) "OPERATOR_TIMES",
        (pANTLR3_UINT8) "PARAMETERS",
        (pANTLR3_UINT8) "QUOTE",
        (pANTLR3_UINT8) "RETURN",
        (pANTLR3_UINT8) "RIGHT_BRACKET",
        (pANTLR3_UINT8) "RIGHT_CURLY_BRACKET",
        (pANTLR3_UINT8) "RIGHT_SQUARE_BRACKET",
        (pANTLR3_UINT8) "SCRIPT",
        (pANTLR3_UINT8) "SEMICOLON",
        (pANTLR3_UINT8) "SIMPLE_COLLECTION",
        (pANTLR3_UINT8) "STRING",
        (pANTLR3_UINT8) "SWITCH",
        (pANTLR3_UINT8) "TRUE_LIT",
        (pANTLR3_UINT8) "VALUES",
        (pANTLR3_UINT8) "VAR",
        (pANTLR3_UINT8) "WHILE",
        (pANTLR3_UINT8) "WHITESPACE",
        (pANTLR3_UINT8) "YIELD",
        (pANTLR3_UINT8) "'@'"
       };


/* globalAttributeScopeFuncMacro(scope)
 */
/** Function  for popping the top value from a pGeoGenScriptDecls_BlockScopeStack
 */
void
pGeoGenScriptDecls_BlockScopePop(pGeoGenScriptDecls ctx)
{
    // First see if the user defined a function they want to be called when a
    // scope is popped/freed.
    //
	// If the user supplied the scope entries with a free function,then call it first
	//
    if	(SCOPE_TOP(BlockScope)->free != NULL)
	{
        SCOPE_TOP(BlockScope)->free(SCOPE_TOP(BlockScope));
	}

    // Now we decrement the scope's upper limit bound. We do not actually pop the scope as
    // we want to reuse scope entries if we do continuous push and pops. Most scopes don't
    // next too far so we don't want to keep freeing and allocating them
    //
    ctx->pGeoGenScriptDecls_BlockScopeStack_limit--;
    SCOPE_TOP(BlockScope) = (pGeoGenScriptDecls_BlockScope_SCOPE)(ctx->pGeoGenScriptDecls_BlockScopeStack->get(ctx->pGeoGenScriptDecls_BlockScopeStack, ctx->pGeoGenScriptDecls_BlockScopeStack_limit - 1));
}


// Forward declare the locally static matching functions we have generated.
//
static 
 void
	script    (pGeoGenScriptDecls ctx);
static 
 void
	metadata    (pGeoGenScriptDecls ctx);
static 
 MetadataValue*
	metadataKeyValueCollection    (pGeoGenScriptDecls ctx);
static 
 MetadataValue*
	metadataList    (pGeoGenScriptDecls ctx);
static 
 GeoGenScriptDecls_metadataKeyValuePair_return
	metadataKeyValuePair    (pGeoGenScriptDecls ctx);
static 
 MetadataValue*
	metadataKeyValueValue    (pGeoGenScriptDecls ctx);
static 
 void
	declaration    (pGeoGenScriptDecls ctx);
static 
 void
	enumDeclaration    (pGeoGenScriptDecls ctx);
static 
 map<String, int>
	enumValues    (pGeoGenScriptDecls ctx);
static 
 void
	functionDeclaration    (pGeoGenScriptDecls ctx);
static 
 CodeBlock*
	block    (pGeoGenScriptDecls ctx);
static 
 CodeBlock*
	statement    (pGeoGenScriptDecls ctx);
static 
 CodeBlock*
	blockStatement    (pGeoGenScriptDecls ctx);
static 
 CodeBlock*
	variableDeclaration    (pGeoGenScriptDecls ctx);
static 
 CodeBlock*
	globalVariableDeclaration    (pGeoGenScriptDecls ctx);
static 
 CodeBlock*
	yieldStatement    (pGeoGenScriptDecls ctx);
static 
 CodeBlock*
	returnStatement    (pGeoGenScriptDecls ctx);
static 
 CodeBlock*
	whileStatement    (pGeoGenScriptDecls ctx);
static 
 CodeBlock*
	forStatement    (pGeoGenScriptDecls ctx);
static 
 CodeBlock*
	initExpression    (pGeoGenScriptDecls ctx);
static 
 CodeBlock*
	ifStatement    (pGeoGenScriptDecls ctx);
static 
 void
	switchStatement    (pGeoGenScriptDecls ctx);
static 
 void
	normalCase    (pGeoGenScriptDecls ctx);
static 
 void
	defaultCase    (pGeoGenScriptDecls ctx);
static 
 GeoGenScriptDecls_expression_return
	expression    (pGeoGenScriptDecls ctx);
static 
 CodeBlock*
	coordinateExpression    (pGeoGenScriptDecls ctx);
static 
 CodeBlock*
	callExpression    (pGeoGenScriptDecls ctx);
static 
 GeoGenScriptDecls_indexAccessExpression_return
	indexAccessExpression    (pGeoGenScriptDecls ctx);
static 
 CodeBlock*
	conditionalOperatorExpression    (pGeoGenScriptDecls ctx);
static 
 CodeBlock*
	lvalueExpression    (pGeoGenScriptDecls ctx);
static 
 CodeBlock*
	lvalueIndexAccessExpression    (pGeoGenScriptDecls ctx);
static 
 CodeBlock*
	collectionLiteral    (pGeoGenScriptDecls ctx);
static 
 CodeBlock*
	collectionLiteralItem    (pGeoGenScriptDecls ctx);
static 
 void
	label    (pGeoGenScriptDecls ctx);
static 
 GeoGenScriptDecls_stringLiteral_return
	stringLiteral    (pGeoGenScriptDecls ctx);
static void	GeoGenScriptDeclsFree(pGeoGenScriptDecls ctx);
static void     GeoGenScriptDeclsReset (pGeoGenScriptDecls ctx);

/* For use in tree output where we are accumulating rule labels via label += ruleRef
 * we need a function that knows how to free a return scope when the list is destroyed.
 * We cannot just use ANTLR3_FREE because in debug tracking mode, this is a macro.
 */
static	void ANTLR3_CDECL freeScope(void * scope)
{
    ANTLR3_FREE(scope);
}

/** \brief Name of the grammar file that generated this code
 */
static const char fileName[] = "C:\\Users\\matej_000\\Source\\Repos\\geogen\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g";

/** \brief Return the name of the grammar file that generated this code.
 */
static const char * getGrammarFileName()
{
	return fileName;
}
/** \brief Create a new GeoGenScriptDecls parser and return a context for it.
 *
 * \param[in] instream Pointer to an input stream interface.
 *
 * \return Pointer to new parser context upon success.
 */
ANTLR3_API pGeoGenScriptDecls
GeoGenScriptDeclsNew   (pANTLR3_COMMON_TREE_NODE_STREAM instream)
{
	// See if we can create a new parser with the standard constructor
	//
	return GeoGenScriptDeclsNewSSD(instream, NULL);
}

/** \brief Create a new GeoGenScriptDecls parser and return a context for it.
 *
 * \param[in] instream Pointer to an input stream interface.
 *
 * \return Pointer to new parser context upon success.
 */
ANTLR3_API pGeoGenScriptDecls
GeoGenScriptDeclsNewSSD   (pANTLR3_COMMON_TREE_NODE_STREAM instream, pANTLR3_RECOGNIZER_SHARED_STATE state)
{
    pGeoGenScriptDecls ctx;	    /* Context structure we will build and return   */

    ctx	= (pGeoGenScriptDecls) ANTLR3_CALLOC(1, sizeof(GeoGenScriptDecls));

    if	(ctx == NULL)
    {
		// Failed to allocate memory for parser context
		//
        return  NULL;
    }

    /* -------------------------------------------------------------------
     * Memory for basic structure is allocated, now to fill in
     * the base ANTLR3 structures. We initialize the function pointers
     * for the standard ANTLR3 parser function set, but upon return
     * from here, the programmer may set the pointers to provide custom
     * implementations of each function.
     *
     * We don't use the macros defined in GeoGenScriptDecls.h here, in order that you can get a sense
     * of what goes where.
     */

    /* Create a base Tree parser/recognizer, using the supplied tree node stream
     */
    ctx->pTreeParser		= antlr3TreeParserNewStream(ANTLR3_SIZE_HINT, instream, state);

    /* Install the implementation of our GeoGenScriptDecls interface
     */
    ctx->script	= script;
    ctx->metadata	= metadata;
    ctx->metadataKeyValueCollection	= metadataKeyValueCollection;
    ctx->metadataList	= metadataList;
    ctx->metadataKeyValuePair	= metadataKeyValuePair;
    ctx->metadataKeyValueValue	= metadataKeyValueValue;
    ctx->declaration	= declaration;
    ctx->enumDeclaration	= enumDeclaration;
    ctx->enumValues	= enumValues;
    ctx->functionDeclaration	= functionDeclaration;
    ctx->block	= block;
    ctx->statement	= statement;
    ctx->blockStatement	= blockStatement;
    ctx->variableDeclaration	= variableDeclaration;
    ctx->globalVariableDeclaration	= globalVariableDeclaration;
    ctx->yieldStatement	= yieldStatement;
    ctx->returnStatement	= returnStatement;
    ctx->whileStatement	= whileStatement;
    ctx->forStatement	= forStatement;
    ctx->initExpression	= initExpression;
    ctx->ifStatement	= ifStatement;
    ctx->switchStatement	= switchStatement;
    ctx->normalCase	= normalCase;
    ctx->defaultCase	= defaultCase;
    ctx->expression	= expression;
    ctx->coordinateExpression	= coordinateExpression;
    ctx->callExpression	= callExpression;
    ctx->indexAccessExpression	= indexAccessExpression;
    ctx->conditionalOperatorExpression	= conditionalOperatorExpression;
    ctx->lvalueExpression	= lvalueExpression;
    ctx->lvalueIndexAccessExpression	= lvalueIndexAccessExpression;
    ctx->collectionLiteral	= collectionLiteral;
    ctx->collectionLiteralItem	= collectionLiteralItem;
    ctx->label	= label;
    ctx->stringLiteral	= stringLiteral;
    ctx->free			= GeoGenScriptDeclsFree;
    ctx->reset			= GeoGenScriptDeclsReset;
    ctx->getGrammarFileName	= getGrammarFileName;

    /* Install the scope pushing methods.
     */
    /* globalAttributeScope(scope)
     */
    ctx->pGeoGenScriptDecls_BlockScopePush     = pGeoGenScriptDecls_BlockScopePush;
    ctx->pGeoGenScriptDecls_BlockScopeStack    = antlr3StackNew(0);
    ctx->pGeoGenScriptDecls_BlockScopeStack_limit    = 0;
    ctx->pGeoGenScriptDecls_BlockScopeTop      = NULL;





    	RECOGNIZER->displayRecognitionError = handleTreeWalkerError;

    /* Install the token table
     */
    PSRSTATE->tokenNames   = GeoGenScriptDeclsTokenNames;


    /* Return the newly built parser to the caller
     */
    return  ctx;
}

static void
GeoGenScriptDeclsReset (pGeoGenScriptDecls ctx)
{
    RECOGNIZER->reset(RECOGNIZER);
}

/** Free the parser resources
 */
 static void
 GeoGenScriptDeclsFree(pGeoGenScriptDecls ctx)
 {
    /* Free any scope memory
     */
    /* globalAttributeScope(scope)
     */
    ctx->pGeoGenScriptDecls_BlockScopeStack->free(ctx->pGeoGenScriptDecls_BlockScopeStack);



	// Free this parser
	//
    ctx->pTreeParser->free(ctx->pTreeParser);

    ANTLR3_FREE(ctx);

    /* Everything is released, so we can return
     */
    return;
 }

/** Return token names used by this 
tree parser

 *
 * The returned pointer is used as an index into the token names table (using the token
 * number as the index).
 *
 * \return Pointer to first char * in the table.
 */
static pANTLR3_UINT8    *getTokenNames()
{
        return GeoGenScriptDeclsTokenNames;
}


           	void handleTreeWalkerError (pANTLR3_BASE_RECOGNIZER recognizer, pANTLR3_UINT8 * tokenNames) { 
           	    pANTLR3_EXCEPTION ex = recognizer->state->exception;
           	    pANTLR3_BASE_TREE currentTree = (pANTLR3_BASE_TREE)(recognizer->state->exception->token);
           	    
           	    CodeLocation location(recognizer->state->exception->line, currentTree->getCharPositionInLine(currentTree));
           	    
           	    String expectedTokenName = GG_STR("");
           	    if(ex->expecting == ANTLR3_TOKEN_EOF)
           	    {
    				expectedTokenName = GG_STR("EOF");
           	    }
       			else if (ex->expecting > 0)
           	    {
           	    	expectedTokenName = (Char*)tokenNames[ex->expecting];
           	    }
           	    
           	    throw UnexpectedTokenException(GGE1201_UnexpectedToken, location, expectedTokenName/*, currentTokenName, currentTokenText*/);
           	    
           	    /*switch  (ex->type)
           	    {
           		case:			    
           		    throw GeoGenException(GGE1201_UnexpectedToken); 
           	    }*/
           	 }

    	void binaryOperator(pGeoGenScriptDecls ctx, pANTLR3_BASE_TREE operatorToken, CodeBlock* e1, CodeBlock* e2, CodeBlock* e1ref, CodeBlock* e2ref, CodeBlock* returnCodeBlock)
    	{
    		CodeLocation location(operatorToken->getLine(operatorToken), operatorToken->getCharPositionInLine(operatorToken));
    		
    		returnCodeBlock->MoveInstructionsFrom(*e1); 
    		delete e1; 
    		if(e1ref != NULL) delete e1ref;
    		
    		returnCodeBlock->MoveInstructionsFrom(*e2); 
    		delete e2;
    		if(e2ref != NULL) delete e2ref;		
    		
    		returnCodeBlock->AddInstruction(new instructions::CallGlobalInstruction(location, (Char*)operatorToken->getText(operatorToken)->chars, 2));
    	}
    	
    	void binaryRefOperator(pGeoGenScriptDecls ctx, pANTLR3_BASE_TREE operatorToken, CodeBlock* e1, CodeBlock* e2, CodeBlock* e1ref, CodeBlock* e2ref, CodeBlock* returnCodeBlock)
    	{
    		CodeLocation location(operatorToken->getLine(operatorToken), operatorToken->getCharPositionInLine(operatorToken));
    		
    		delete e1;
    		if(e1ref == NULL)
    		{
    			delete e1ref;
    			throw ReadOnlyExpressionWriteException(location);
    		}
    		returnCodeBlock->MoveInstructionsFrom(*e1ref); 
    		delete e1ref; 
    		
    		returnCodeBlock->MoveInstructionsFrom(*e2); 
    		delete e2;
    		if(e2ref != NULL) delete e2ref;

    		returnCodeBlock->AddInstruction(new instructions::CallGlobalInstruction(location, (Char*)operatorToken->getText(operatorToken)->chars, 2));
    	}
    	
    	void unaryOperator(pGeoGenScriptDecls ctx, pANTLR3_BASE_TREE operatorToken, string const& text, CodeBlock* e1, CodeBlock* e1ref, CodeBlock* returnCodeBlock)
    	{
    		CodeLocation location(operatorToken->getLine(operatorToken), operatorToken->getCharPositionInLine(operatorToken));
    	
    		returnCodeBlock->MoveInstructionsFrom(*e1); 
    		delete e1; 		
    		if(e1ref != NULL) delete e1ref;		
    		
    		returnCodeBlock->AddInstruction(new instructions::CallGlobalInstruction(location, AnyStringToString(text), 1));
    	}
    	
    	void unaryRefOperator(pGeoGenScriptDecls ctx, pANTLR3_BASE_TREE operatorToken, string const& text, CodeBlock* e1, CodeBlock* e1ref, CodeBlock* returnCodeBlock)
    	{
    		CodeLocation location(operatorToken->getLine(operatorToken), operatorToken->getCharPositionInLine(operatorToken));
    	
    		delete e1;
    		if(e1ref == NULL)
    		{
    			delete e1ref;
    			throw ReadOnlyExpressionWriteException(location);
    		}
    		returnCodeBlock->MoveInstructionsFrom(*e1ref); 
    		delete e1ref; 	
    		
    		returnCodeBlock->AddInstruction(new instructions::CallGlobalInstruction(location, AnyStringToString(text), 1));
    	}     	     	 


/* Declare the bitsets
 */
/** Bitset defining follow set for error recovery in rule state: FOLLOW_SCRIPT_in_script95  */
static	ANTLR3_BITWORD FOLLOW_SCRIPT_in_script95_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_SCRIPT_in_script95	= { FOLLOW_SCRIPT_in_script95_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_metadata_in_script97  */
static	ANTLR3_BITWORD FOLLOW_metadata_in_script97_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000010000) };
static  ANTLR3_BITSET_LIST FOLLOW_metadata_in_script97	= { FOLLOW_metadata_in_script97_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_DECLARATIONS_in_script101  */
static	ANTLR3_BITWORD FOLLOW_DECLARATIONS_in_script101_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_DECLARATIONS_in_script101	= { FOLLOW_DECLARATIONS_in_script101_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_declaration_in_script103  */
static	ANTLR3_BITWORD FOLLOW_declaration_in_script103_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000880008) };
static  ANTLR3_BITSET_LIST FOLLOW_declaration_in_script103	= { FOLLOW_declaration_in_script103_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_block_in_script107  */
static	ANTLR3_BITWORD FOLLOW_block_in_script107_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_block_in_script107	= { FOLLOW_block_in_script107_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_METADATA_in_metadata127  */
static	ANTLR3_BITWORD FOLLOW_METADATA_in_metadata127_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_METADATA_in_metadata127	= { FOLLOW_METADATA_in_metadata127_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_metadataKeyValueCollection_in_metadata129  */
static	ANTLR3_BITWORD FOLLOW_metadataKeyValueCollection_in_metadata129_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_metadataKeyValueCollection_in_metadata129	= { FOLLOW_metadataKeyValueCollection_in_metadata129_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_COLLECTION_in_metadataKeyValueCollection151  */
static	ANTLR3_BITWORD FOLLOW_COLLECTION_in_metadataKeyValueCollection151_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_COLLECTION_in_metadataKeyValueCollection151	= { FOLLOW_COLLECTION_in_metadataKeyValueCollection151_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_metadataKeyValuePair_in_metadataKeyValueCollection158  */
static	ANTLR3_BITWORD FOLLOW_metadataKeyValuePair_in_metadataKeyValueCollection158_bits[]	= { ANTLR3_UINT64_LIT(0x0000000804000008) };
static  ANTLR3_BITSET_LIST FOLLOW_metadataKeyValuePair_in_metadataKeyValueCollection158	= { FOLLOW_metadataKeyValuePair_in_metadataKeyValueCollection158_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_SIMPLE_COLLECTION_in_metadataList184  */
static	ANTLR3_BITWORD FOLLOW_SIMPLE_COLLECTION_in_metadataList184_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_SIMPLE_COLLECTION_in_metadataList184	= { FOLLOW_SIMPLE_COLLECTION_in_metadataList184_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_metadataKeyValueValue_in_metadataList191  */
static	ANTLR3_BITWORD FOLLOW_metadataKeyValueValue_in_metadataList191_bits[]	= { ANTLR3_UINT64_LIT(0x0000000804200108), ANTLR3_UINT64_LIT(0x000000000B000000) };
static  ANTLR3_BITSET_LIST FOLLOW_metadataKeyValueValue_in_metadataList191	= { FOLLOW_metadataKeyValueValue_in_metadataList191_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_IDENTIFIER_in_metadataKeyValuePair217  */
static	ANTLR3_BITWORD FOLLOW_IDENTIFIER_in_metadataKeyValuePair217_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_IDENTIFIER_in_metadataKeyValuePair217	= { FOLLOW_IDENTIFIER_in_metadataKeyValuePair217_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_metadataKeyValueValue_in_metadataKeyValuePair219  */
static	ANTLR3_BITWORD FOLLOW_metadataKeyValueValue_in_metadataKeyValuePair219_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_metadataKeyValueValue_in_metadataKeyValuePair219	= { FOLLOW_metadataKeyValueValue_in_metadataKeyValuePair219_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_NUMBER_in_metadataKeyValuePair228  */
static	ANTLR3_BITWORD FOLLOW_NUMBER_in_metadataKeyValuePair228_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_NUMBER_in_metadataKeyValuePair228	= { FOLLOW_NUMBER_in_metadataKeyValuePair228_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_metadataKeyValueValue_in_metadataKeyValuePair230  */
static	ANTLR3_BITWORD FOLLOW_metadataKeyValueValue_in_metadataKeyValuePair230_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008), ANTLR3_UINT64_LIT(0x0000000200000000) };
static  ANTLR3_BITSET_LIST FOLLOW_metadataKeyValueValue_in_metadataKeyValuePair230	= { FOLLOW_metadataKeyValueValue_in_metadataKeyValuePair230_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_97_in_metadataKeyValuePair232  */
static	ANTLR3_BITWORD FOLLOW_97_in_metadataKeyValuePair232_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_97_in_metadataKeyValuePair232	= { FOLLOW_97_in_metadataKeyValuePair232_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_stringLiteral_in_metadataKeyValueValue254  */
static	ANTLR3_BITWORD FOLLOW_stringLiteral_in_metadataKeyValueValue254_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_stringLiteral_in_metadataKeyValueValue254	= { FOLLOW_stringLiteral_in_metadataKeyValueValue254_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_TRUE_LIT_in_metadataKeyValueValue262  */
static	ANTLR3_BITWORD FOLLOW_TRUE_LIT_in_metadataKeyValueValue262_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_TRUE_LIT_in_metadataKeyValueValue262	= { FOLLOW_TRUE_LIT_in_metadataKeyValueValue262_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_FALSE_LIT_in_metadataKeyValueValue270  */
static	ANTLR3_BITWORD FOLLOW_FALSE_LIT_in_metadataKeyValueValue270_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_FALSE_LIT_in_metadataKeyValueValue270	= { FOLLOW_FALSE_LIT_in_metadataKeyValueValue270_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_NUMBER_in_metadataKeyValueValue278  */
static	ANTLR3_BITWORD FOLLOW_NUMBER_in_metadataKeyValueValue278_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_NUMBER_in_metadataKeyValueValue278	= { FOLLOW_NUMBER_in_metadataKeyValueValue278_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_IDENTIFIER_in_metadataKeyValueValue285  */
static	ANTLR3_BITWORD FOLLOW_IDENTIFIER_in_metadataKeyValueValue285_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_IDENTIFIER_in_metadataKeyValueValue285	= { FOLLOW_IDENTIFIER_in_metadataKeyValueValue285_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_metadataKeyValueCollection_in_metadataKeyValueValue292  */
static	ANTLR3_BITWORD FOLLOW_metadataKeyValueCollection_in_metadataKeyValueValue292_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_metadataKeyValueCollection_in_metadataKeyValueValue292	= { FOLLOW_metadataKeyValueCollection_in_metadataKeyValueValue292_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_metadataList_in_metadataKeyValueValue299  */
static	ANTLR3_BITWORD FOLLOW_metadataList_in_metadataKeyValueValue299_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_metadataList_in_metadataKeyValueValue299	= { FOLLOW_metadataList_in_metadataKeyValueValue299_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_enumDeclaration_in_declaration315  */
static	ANTLR3_BITWORD FOLLOW_enumDeclaration_in_declaration315_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_enumDeclaration_in_declaration315	= { FOLLOW_enumDeclaration_in_declaration315_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_functionDeclaration_in_declaration319  */
static	ANTLR3_BITWORD FOLLOW_functionDeclaration_in_declaration319_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_functionDeclaration_in_declaration319	= { FOLLOW_functionDeclaration_in_declaration319_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ENUM_in_enumDeclaration327  */
static	ANTLR3_BITWORD FOLLOW_ENUM_in_enumDeclaration327_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_ENUM_in_enumDeclaration327	= { FOLLOW_ENUM_in_enumDeclaration327_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_IDENTIFIER_in_enumDeclaration329  */
static	ANTLR3_BITWORD FOLLOW_IDENTIFIER_in_enumDeclaration329_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000010000000) };
static  ANTLR3_BITSET_LIST FOLLOW_IDENTIFIER_in_enumDeclaration329	= { FOLLOW_IDENTIFIER_in_enumDeclaration329_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_enumValues_in_enumDeclaration331  */
static	ANTLR3_BITWORD FOLLOW_enumValues_in_enumDeclaration331_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_enumValues_in_enumDeclaration331	= { FOLLOW_enumValues_in_enumDeclaration331_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_VALUES_in_enumValues352  */
static	ANTLR3_BITWORD FOLLOW_VALUES_in_enumValues352_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_VALUES_in_enumValues352	= { FOLLOW_VALUES_in_enumValues352_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_IDENTIFIER_in_enumValues356  */
static	ANTLR3_BITWORD FOLLOW_IDENTIFIER_in_enumValues356_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_IDENTIFIER_in_enumValues356	= { FOLLOW_IDENTIFIER_in_enumValues356_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_NUMBER_in_enumValues359  */
static	ANTLR3_BITWORD FOLLOW_NUMBER_in_enumValues359_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_NUMBER_in_enumValues359	= { FOLLOW_NUMBER_in_enumValues359_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_FUNCTION_in_functionDeclaration394  */
static	ANTLR3_BITWORD FOLLOW_FUNCTION_in_functionDeclaration394_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_FUNCTION_in_functionDeclaration394	= { FOLLOW_FUNCTION_in_functionDeclaration394_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_IDENTIFIER_in_functionDeclaration398  */
static	ANTLR3_BITWORD FOLLOW_IDENTIFIER_in_functionDeclaration398_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000010000) };
static  ANTLR3_BITSET_LIST FOLLOW_IDENTIFIER_in_functionDeclaration398	= { FOLLOW_IDENTIFIER_in_functionDeclaration398_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_PARAMETERS_in_functionDeclaration401  */
static	ANTLR3_BITWORD FOLLOW_PARAMETERS_in_functionDeclaration401_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_PARAMETERS_in_functionDeclaration401	= { FOLLOW_PARAMETERS_in_functionDeclaration401_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_IDENTIFIER_in_functionDeclaration405  */
static	ANTLR3_BITWORD FOLLOW_IDENTIFIER_in_functionDeclaration405_bits[]	= { ANTLR3_UINT64_LIT(0x0000000004000008) };
static  ANTLR3_BITSET_LIST FOLLOW_IDENTIFIER_in_functionDeclaration405	= { FOLLOW_IDENTIFIER_in_functionDeclaration405_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_block_in_functionDeclaration409  */
static	ANTLR3_BITWORD FOLLOW_block_in_functionDeclaration409_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_block_in_functionDeclaration409	= { FOLLOW_block_in_functionDeclaration409_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_BLOCK_in_block436  */
static	ANTLR3_BITWORD FOLLOW_BLOCK_in_block436_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_BLOCK_in_block436	= { FOLLOW_BLOCK_in_block436_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_statement_in_block439  */
static	ANTLR3_BITWORD FOLLOW_statement_in_block439_bits[]	= { ANTLR3_UINT64_LIT(0xEFF3BFFA8D60C168), ANTLR3_UINT64_LIT(0x000000016E04BFFF) };
static  ANTLR3_BITSET_LIST FOLLOW_statement_in_block439	= { FOLLOW_statement_in_block439_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_BREAK_in_statement470  */
static	ANTLR3_BITWORD FOLLOW_BREAK_in_statement470_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_BREAK_in_statement470	= { FOLLOW_BREAK_in_statement470_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_CONTINUE_in_statement485  */
static	ANTLR3_BITWORD FOLLOW_CONTINUE_in_statement485_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_CONTINUE_in_statement485	= { FOLLOW_CONTINUE_in_statement485_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_variableDeclaration_in_statement500  */
static	ANTLR3_BITWORD FOLLOW_variableDeclaration_in_statement500_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_variableDeclaration_in_statement500	= { FOLLOW_variableDeclaration_in_statement500_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_globalVariableDeclaration_in_statement510  */
static	ANTLR3_BITWORD FOLLOW_globalVariableDeclaration_in_statement510_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_globalVariableDeclaration_in_statement510	= { FOLLOW_globalVariableDeclaration_in_statement510_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_statement520  */
static	ANTLR3_BITWORD FOLLOW_expression_in_statement520_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_statement520	= { FOLLOW_expression_in_statement520_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_yieldStatement_in_statement535  */
static	ANTLR3_BITWORD FOLLOW_yieldStatement_in_statement535_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_yieldStatement_in_statement535	= { FOLLOW_yieldStatement_in_statement535_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_returnStatement_in_statement544  */
static	ANTLR3_BITWORD FOLLOW_returnStatement_in_statement544_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_returnStatement_in_statement544	= { FOLLOW_returnStatement_in_statement544_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_whileStatement_in_statement554  */
static	ANTLR3_BITWORD FOLLOW_whileStatement_in_statement554_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_whileStatement_in_statement554	= { FOLLOW_whileStatement_in_statement554_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_forStatement_in_statement564  */
static	ANTLR3_BITWORD FOLLOW_forStatement_in_statement564_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_forStatement_in_statement564	= { FOLLOW_forStatement_in_statement564_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ifStatement_in_statement574  */
static	ANTLR3_BITWORD FOLLOW_ifStatement_in_statement574_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_ifStatement_in_statement574	= { FOLLOW_ifStatement_in_statement574_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_switchStatement_in_statement584  */
static	ANTLR3_BITWORD FOLLOW_switchStatement_in_statement584_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_switchStatement_in_statement584	= { FOLLOW_switchStatement_in_statement584_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_blockStatement_in_statement594  */
static	ANTLR3_BITWORD FOLLOW_blockStatement_in_statement594_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_blockStatement_in_statement594	= { FOLLOW_blockStatement_in_statement594_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_block_in_blockStatement623  */
static	ANTLR3_BITWORD FOLLOW_block_in_blockStatement623_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_block_in_blockStatement623	= { FOLLOW_block_in_blockStatement623_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_VAR_in_variableDeclaration648  */
static	ANTLR3_BITWORD FOLLOW_VAR_in_variableDeclaration648_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_VAR_in_variableDeclaration648	= { FOLLOW_VAR_in_variableDeclaration648_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_IDENTIFIER_in_variableDeclaration650  */
static	ANTLR3_BITWORD FOLLOW_IDENTIFIER_in_variableDeclaration650_bits[]	= { ANTLR3_UINT64_LIT(0xEFF3BFFA84208108), ANTLR3_UINT64_LIT(0x000000000A00BFFF) };
static  ANTLR3_BITSET_LIST FOLLOW_IDENTIFIER_in_variableDeclaration650	= { FOLLOW_IDENTIFIER_in_variableDeclaration650_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_variableDeclaration653  */
static	ANTLR3_BITWORD FOLLOW_expression_in_variableDeclaration653_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_variableDeclaration653	= { FOLLOW_expression_in_variableDeclaration653_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_GLOBAL_in_globalVariableDeclaration681  */
static	ANTLR3_BITWORD FOLLOW_GLOBAL_in_globalVariableDeclaration681_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_GLOBAL_in_globalVariableDeclaration681	= { FOLLOW_GLOBAL_in_globalVariableDeclaration681_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_IDENTIFIER_in_globalVariableDeclaration683  */
static	ANTLR3_BITWORD FOLLOW_IDENTIFIER_in_globalVariableDeclaration683_bits[]	= { ANTLR3_UINT64_LIT(0xEFF3BFFA84208108), ANTLR3_UINT64_LIT(0x000000000A00BFFF) };
static  ANTLR3_BITSET_LIST FOLLOW_IDENTIFIER_in_globalVariableDeclaration683	= { FOLLOW_IDENTIFIER_in_globalVariableDeclaration683_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_globalVariableDeclaration686  */
static	ANTLR3_BITWORD FOLLOW_expression_in_globalVariableDeclaration686_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_globalVariableDeclaration686	= { FOLLOW_expression_in_globalVariableDeclaration686_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_YIELD_in_yieldStatement714  */
static	ANTLR3_BITWORD FOLLOW_YIELD_in_yieldStatement714_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_YIELD_in_yieldStatement714	= { FOLLOW_YIELD_in_yieldStatement714_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_yieldStatement716  */
static	ANTLR3_BITWORD FOLLOW_expression_in_yieldStatement716_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008), ANTLR3_UINT64_LIT(0x0000000002000000) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_yieldStatement716	= { FOLLOW_expression_in_yieldStatement716_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_STRING_in_yieldStatement718  */
static	ANTLR3_BITWORD FOLLOW_STRING_in_yieldStatement718_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_STRING_in_yieldStatement718	= { FOLLOW_STRING_in_yieldStatement718_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_RETURN_in_returnStatement742  */
static	ANTLR3_BITWORD FOLLOW_RETURN_in_returnStatement742_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_RETURN_in_returnStatement742	= { FOLLOW_RETURN_in_returnStatement742_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_returnStatement745  */
static	ANTLR3_BITWORD FOLLOW_expression_in_returnStatement745_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_returnStatement745	= { FOLLOW_expression_in_returnStatement745_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_WHILE_in_whileStatement781  */
static	ANTLR3_BITWORD FOLLOW_WHILE_in_whileStatement781_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_WHILE_in_whileStatement781	= { FOLLOW_WHILE_in_whileStatement781_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_whileStatement783  */
static	ANTLR3_BITWORD FOLLOW_expression_in_whileStatement783_bits[]	= { ANTLR3_UINT64_LIT(0xEFF3BFFA8D60C160), ANTLR3_UINT64_LIT(0x000000016E04BFFF) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_whileStatement783	= { FOLLOW_expression_in_whileStatement783_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_statement_in_whileStatement785  */
static	ANTLR3_BITWORD FOLLOW_statement_in_whileStatement785_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_statement_in_whileStatement785	= { FOLLOW_statement_in_whileStatement785_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_FOR_in_forStatement818  */
static	ANTLR3_BITWORD FOLLOW_FOR_in_forStatement818_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_FOR_in_forStatement818	= { FOLLOW_FOR_in_forStatement818_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_INITIALIZATION_EXPRESSION_in_forStatement824  */
static	ANTLR3_BITWORD FOLLOW_INITIALIZATION_EXPRESSION_in_forStatement824_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_INITIALIZATION_EXPRESSION_in_forStatement824	= { FOLLOW_INITIALIZATION_EXPRESSION_in_forStatement824_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_initExpression_in_forStatement826  */
static	ANTLR3_BITWORD FOLLOW_initExpression_in_forStatement826_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_initExpression_in_forStatement826	= { FOLLOW_initExpression_in_forStatement826_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_CONDITION_EXPRESSION_in_forStatement838  */
static	ANTLR3_BITWORD FOLLOW_CONDITION_EXPRESSION_in_forStatement838_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_CONDITION_EXPRESSION_in_forStatement838	= { FOLLOW_CONDITION_EXPRESSION_in_forStatement838_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_forStatement842  */
static	ANTLR3_BITWORD FOLLOW_expression_in_forStatement842_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_forStatement842	= { FOLLOW_expression_in_forStatement842_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_INCREMENT_EXPRESSION_in_forStatement854  */
static	ANTLR3_BITWORD FOLLOW_INCREMENT_EXPRESSION_in_forStatement854_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_INCREMENT_EXPRESSION_in_forStatement854	= { FOLLOW_INCREMENT_EXPRESSION_in_forStatement854_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_forStatement858  */
static	ANTLR3_BITWORD FOLLOW_expression_in_forStatement858_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_forStatement858	= { FOLLOW_expression_in_forStatement858_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_statement_in_forStatement868  */
static	ANTLR3_BITWORD FOLLOW_statement_in_forStatement868_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_statement_in_forStatement868	= { FOLLOW_statement_in_forStatement868_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_variableDeclaration_in_initExpression893  */
static	ANTLR3_BITWORD FOLLOW_variableDeclaration_in_initExpression893_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_variableDeclaration_in_initExpression893	= { FOLLOW_variableDeclaration_in_initExpression893_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_initExpression903  */
static	ANTLR3_BITWORD FOLLOW_expression_in_initExpression903_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_initExpression903	= { FOLLOW_expression_in_initExpression903_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_IF_in_ifStatement929  */
static	ANTLR3_BITWORD FOLLOW_IF_in_ifStatement929_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_IF_in_ifStatement929	= { FOLLOW_IF_in_ifStatement929_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_ifStatement931  */
static	ANTLR3_BITWORD FOLLOW_expression_in_ifStatement931_bits[]	= { ANTLR3_UINT64_LIT(0xEFF3BFFA8D60C160), ANTLR3_UINT64_LIT(0x000000016E04BFFF) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_ifStatement931	= { FOLLOW_expression_in_ifStatement931_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_statement_in_ifStatement935  */
static	ANTLR3_BITWORD FOLLOW_statement_in_ifStatement935_bits[]	= { ANTLR3_UINT64_LIT(0xEFF3BFFA8D60C160), ANTLR3_UINT64_LIT(0x000000016E04BFFF) };
static  ANTLR3_BITSET_LIST FOLLOW_statement_in_ifStatement935	= { FOLLOW_statement_in_ifStatement935_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_statement_in_ifStatement939  */
static	ANTLR3_BITWORD FOLLOW_statement_in_ifStatement939_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_statement_in_ifStatement939	= { FOLLOW_statement_in_ifStatement939_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_SWITCH_in_switchStatement951  */
static	ANTLR3_BITWORD FOLLOW_SWITCH_in_switchStatement951_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_SWITCH_in_switchStatement951	= { FOLLOW_SWITCH_in_switchStatement951_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_switchStatement953  */
static	ANTLR3_BITWORD FOLLOW_expression_in_switchStatement953_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000020088) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_switchStatement953	= { FOLLOW_expression_in_switchStatement953_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_normalCase_in_switchStatement955  */
static	ANTLR3_BITWORD FOLLOW_normalCase_in_switchStatement955_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000020088) };
static  ANTLR3_BITSET_LIST FOLLOW_normalCase_in_switchStatement955	= { FOLLOW_normalCase_in_switchStatement955_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_defaultCase_in_switchStatement958  */
static	ANTLR3_BITWORD FOLLOW_defaultCase_in_switchStatement958_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_defaultCase_in_switchStatement958	= { FOLLOW_defaultCase_in_switchStatement958_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_CASE_in_normalCase968  */
static	ANTLR3_BITWORD FOLLOW_CASE_in_normalCase968_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_CASE_in_normalCase968	= { FOLLOW_CASE_in_normalCase968_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_label_in_normalCase970  */
static	ANTLR3_BITWORD FOLLOW_label_in_normalCase970_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000020) };
static  ANTLR3_BITSET_LIST FOLLOW_label_in_normalCase970	= { FOLLOW_label_in_normalCase970_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_BLOCK_in_normalCase973  */
static	ANTLR3_BITWORD FOLLOW_BLOCK_in_normalCase973_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_BLOCK_in_normalCase973	= { FOLLOW_BLOCK_in_normalCase973_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_statement_in_normalCase975  */
static	ANTLR3_BITWORD FOLLOW_statement_in_normalCase975_bits[]	= { ANTLR3_UINT64_LIT(0xEFF3BFFA8D60C168), ANTLR3_UINT64_LIT(0x000000016E04BFFF) };
static  ANTLR3_BITSET_LIST FOLLOW_statement_in_normalCase975	= { FOLLOW_statement_in_normalCase975_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_DEFAULT_in_defaultCase985  */
static	ANTLR3_BITWORD FOLLOW_DEFAULT_in_defaultCase985_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_DEFAULT_in_defaultCase985	= { FOLLOW_DEFAULT_in_defaultCase985_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_BLOCK_in_defaultCase988  */
static	ANTLR3_BITWORD FOLLOW_BLOCK_in_defaultCase988_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_BLOCK_in_defaultCase988	= { FOLLOW_BLOCK_in_defaultCase988_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_statement_in_defaultCase990  */
static	ANTLR3_BITWORD FOLLOW_statement_in_defaultCase990_bits[]	= { ANTLR3_UINT64_LIT(0xEFF3BFFA8D60C168), ANTLR3_UINT64_LIT(0x000000016E04BFFF) };
static  ANTLR3_BITSET_LIST FOLLOW_statement_in_defaultCase990	= { FOLLOW_statement_in_defaultCase990_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_OPERATOR_ASSIGN_in_expression1013  */
static	ANTLR3_BITWORD FOLLOW_OPERATOR_ASSIGN_in_expression1013_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_OPERATOR_ASSIGN_in_expression1013	= { FOLLOW_OPERATOR_ASSIGN_in_expression1013_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_lvalueExpression_in_expression1015  */
static	ANTLR3_BITWORD FOLLOW_lvalueExpression_in_expression1015_bits[]	= { ANTLR3_UINT64_LIT(0xEFF3BFFA84208100), ANTLR3_UINT64_LIT(0x000000000A00BFFF) };
static  ANTLR3_BITSET_LIST FOLLOW_lvalueExpression_in_expression1015	= { FOLLOW_lvalueExpression_in_expression1015_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_expression1019  */
static	ANTLR3_BITWORD FOLLOW_expression_in_expression1019_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_expression1019	= { FOLLOW_expression_in_expression1019_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_OPERATOR_ASSIGN_PLUS_in_expression1031  */
static	ANTLR3_BITWORD FOLLOW_OPERATOR_ASSIGN_PLUS_in_expression1031_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_OPERATOR_ASSIGN_PLUS_in_expression1031	= { FOLLOW_OPERATOR_ASSIGN_PLUS_in_expression1031_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_expression1035  */
static	ANTLR3_BITWORD FOLLOW_expression_in_expression1035_bits[]	= { ANTLR3_UINT64_LIT(0xEFF3BFFA84208100), ANTLR3_UINT64_LIT(0x000000000A00BFFF) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_expression1035	= { FOLLOW_expression_in_expression1035_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_expression1039  */
static	ANTLR3_BITWORD FOLLOW_expression_in_expression1039_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_expression1039	= { FOLLOW_expression_in_expression1039_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_OPERATOR_ASSIGN_MINUS_in_expression1050  */
static	ANTLR3_BITWORD FOLLOW_OPERATOR_ASSIGN_MINUS_in_expression1050_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_OPERATOR_ASSIGN_MINUS_in_expression1050	= { FOLLOW_OPERATOR_ASSIGN_MINUS_in_expression1050_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_expression1054  */
static	ANTLR3_BITWORD FOLLOW_expression_in_expression1054_bits[]	= { ANTLR3_UINT64_LIT(0xEFF3BFFA84208100), ANTLR3_UINT64_LIT(0x000000000A00BFFF) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_expression1054	= { FOLLOW_expression_in_expression1054_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_expression1058  */
static	ANTLR3_BITWORD FOLLOW_expression_in_expression1058_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_expression1058	= { FOLLOW_expression_in_expression1058_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_OPERATOR_ASSIGN_TIMES_in_expression1069  */
static	ANTLR3_BITWORD FOLLOW_OPERATOR_ASSIGN_TIMES_in_expression1069_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_OPERATOR_ASSIGN_TIMES_in_expression1069	= { FOLLOW_OPERATOR_ASSIGN_TIMES_in_expression1069_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_expression1073  */
static	ANTLR3_BITWORD FOLLOW_expression_in_expression1073_bits[]	= { ANTLR3_UINT64_LIT(0xEFF3BFFA84208100), ANTLR3_UINT64_LIT(0x000000000A00BFFF) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_expression1073	= { FOLLOW_expression_in_expression1073_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_expression1077  */
static	ANTLR3_BITWORD FOLLOW_expression_in_expression1077_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_expression1077	= { FOLLOW_expression_in_expression1077_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_OPERATOR_ASSIGN_DIVIDE_in_expression1088  */
static	ANTLR3_BITWORD FOLLOW_OPERATOR_ASSIGN_DIVIDE_in_expression1088_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_OPERATOR_ASSIGN_DIVIDE_in_expression1088	= { FOLLOW_OPERATOR_ASSIGN_DIVIDE_in_expression1088_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_expression1092  */
static	ANTLR3_BITWORD FOLLOW_expression_in_expression1092_bits[]	= { ANTLR3_UINT64_LIT(0xEFF3BFFA84208100), ANTLR3_UINT64_LIT(0x000000000A00BFFF) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_expression1092	= { FOLLOW_expression_in_expression1092_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_expression1096  */
static	ANTLR3_BITWORD FOLLOW_expression_in_expression1096_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_expression1096	= { FOLLOW_expression_in_expression1096_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_OPERATOR_ASSIGN_MODULO_in_expression1107  */
static	ANTLR3_BITWORD FOLLOW_OPERATOR_ASSIGN_MODULO_in_expression1107_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_OPERATOR_ASSIGN_MODULO_in_expression1107	= { FOLLOW_OPERATOR_ASSIGN_MODULO_in_expression1107_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_expression1111  */
static	ANTLR3_BITWORD FOLLOW_expression_in_expression1111_bits[]	= { ANTLR3_UINT64_LIT(0xEFF3BFFA84208100), ANTLR3_UINT64_LIT(0x000000000A00BFFF) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_expression1111	= { FOLLOW_expression_in_expression1111_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_expression1115  */
static	ANTLR3_BITWORD FOLLOW_expression_in_expression1115_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_expression1115	= { FOLLOW_expression_in_expression1115_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_OPERATOR_ASSIGN_LSHIFT_in_expression1126  */
static	ANTLR3_BITWORD FOLLOW_OPERATOR_ASSIGN_LSHIFT_in_expression1126_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_OPERATOR_ASSIGN_LSHIFT_in_expression1126	= { FOLLOW_OPERATOR_ASSIGN_LSHIFT_in_expression1126_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_expression1130  */
static	ANTLR3_BITWORD FOLLOW_expression_in_expression1130_bits[]	= { ANTLR3_UINT64_LIT(0xEFF3BFFA84208100), ANTLR3_UINT64_LIT(0x000000000A00BFFF) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_expression1130	= { FOLLOW_expression_in_expression1130_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_expression1134  */
static	ANTLR3_BITWORD FOLLOW_expression_in_expression1134_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_expression1134	= { FOLLOW_expression_in_expression1134_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_OPERATOR_ASSIGN_RSHIFT_in_expression1145  */
static	ANTLR3_BITWORD FOLLOW_OPERATOR_ASSIGN_RSHIFT_in_expression1145_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_OPERATOR_ASSIGN_RSHIFT_in_expression1145	= { FOLLOW_OPERATOR_ASSIGN_RSHIFT_in_expression1145_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_expression1149  */
static	ANTLR3_BITWORD FOLLOW_expression_in_expression1149_bits[]	= { ANTLR3_UINT64_LIT(0xEFF3BFFA84208100), ANTLR3_UINT64_LIT(0x000000000A00BFFF) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_expression1149	= { FOLLOW_expression_in_expression1149_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_expression1153  */
static	ANTLR3_BITWORD FOLLOW_expression_in_expression1153_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_expression1153	= { FOLLOW_expression_in_expression1153_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_OPERATOR_ASSIGN_AND_in_expression1164  */
static	ANTLR3_BITWORD FOLLOW_OPERATOR_ASSIGN_AND_in_expression1164_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_OPERATOR_ASSIGN_AND_in_expression1164	= { FOLLOW_OPERATOR_ASSIGN_AND_in_expression1164_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_expression1168  */
static	ANTLR3_BITWORD FOLLOW_expression_in_expression1168_bits[]	= { ANTLR3_UINT64_LIT(0xEFF3BFFA84208100), ANTLR3_UINT64_LIT(0x000000000A00BFFF) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_expression1168	= { FOLLOW_expression_in_expression1168_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_expression1172  */
static	ANTLR3_BITWORD FOLLOW_expression_in_expression1172_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_expression1172	= { FOLLOW_expression_in_expression1172_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_OPERATOR_ASSIGN_OR_in_expression1183  */
static	ANTLR3_BITWORD FOLLOW_OPERATOR_ASSIGN_OR_in_expression1183_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_OPERATOR_ASSIGN_OR_in_expression1183	= { FOLLOW_OPERATOR_ASSIGN_OR_in_expression1183_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_expression1187  */
static	ANTLR3_BITWORD FOLLOW_expression_in_expression1187_bits[]	= { ANTLR3_UINT64_LIT(0xEFF3BFFA84208100), ANTLR3_UINT64_LIT(0x000000000A00BFFF) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_expression1187	= { FOLLOW_expression_in_expression1187_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_expression1191  */
static	ANTLR3_BITWORD FOLLOW_expression_in_expression1191_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_expression1191	= { FOLLOW_expression_in_expression1191_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_OPERATOR_IS_in_expression1202  */
static	ANTLR3_BITWORD FOLLOW_OPERATOR_IS_in_expression1202_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_OPERATOR_IS_in_expression1202	= { FOLLOW_OPERATOR_IS_in_expression1202_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_expression1206  */
static	ANTLR3_BITWORD FOLLOW_expression_in_expression1206_bits[]	= { ANTLR3_UINT64_LIT(0xEFF3BFFA84208100), ANTLR3_UINT64_LIT(0x000000000A00BFFF) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_expression1206	= { FOLLOW_expression_in_expression1206_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_expression1210  */
static	ANTLR3_BITWORD FOLLOW_expression_in_expression1210_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_expression1210	= { FOLLOW_expression_in_expression1210_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_conditionalOperatorExpression_in_expression1218  */
static	ANTLR3_BITWORD FOLLOW_conditionalOperatorExpression_in_expression1218_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_conditionalOperatorExpression_in_expression1218	= { FOLLOW_conditionalOperatorExpression_in_expression1218_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_OPERATOR_REL_OR_in_expression1229  */
static	ANTLR3_BITWORD FOLLOW_OPERATOR_REL_OR_in_expression1229_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_OPERATOR_REL_OR_in_expression1229	= { FOLLOW_OPERATOR_REL_OR_in_expression1229_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_expression1233  */
static	ANTLR3_BITWORD FOLLOW_expression_in_expression1233_bits[]	= { ANTLR3_UINT64_LIT(0xEFF3BFFA84208100), ANTLR3_UINT64_LIT(0x000000000A00BFFF) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_expression1233	= { FOLLOW_expression_in_expression1233_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_expression1237  */
static	ANTLR3_BITWORD FOLLOW_expression_in_expression1237_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_expression1237	= { FOLLOW_expression_in_expression1237_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_OPERATOR_REL_AND_in_expression1248  */
static	ANTLR3_BITWORD FOLLOW_OPERATOR_REL_AND_in_expression1248_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_OPERATOR_REL_AND_in_expression1248	= { FOLLOW_OPERATOR_REL_AND_in_expression1248_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_expression1252  */
static	ANTLR3_BITWORD FOLLOW_expression_in_expression1252_bits[]	= { ANTLR3_UINT64_LIT(0xEFF3BFFA84208100), ANTLR3_UINT64_LIT(0x000000000A00BFFF) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_expression1252	= { FOLLOW_expression_in_expression1252_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_expression1256  */
static	ANTLR3_BITWORD FOLLOW_expression_in_expression1256_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_expression1256	= { FOLLOW_expression_in_expression1256_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_OPERATOR_BIT_XOR_in_expression1267  */
static	ANTLR3_BITWORD FOLLOW_OPERATOR_BIT_XOR_in_expression1267_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_OPERATOR_BIT_XOR_in_expression1267	= { FOLLOW_OPERATOR_BIT_XOR_in_expression1267_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_expression1271  */
static	ANTLR3_BITWORD FOLLOW_expression_in_expression1271_bits[]	= { ANTLR3_UINT64_LIT(0xEFF3BFFA84208100), ANTLR3_UINT64_LIT(0x000000000A00BFFF) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_expression1271	= { FOLLOW_expression_in_expression1271_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_expression1275  */
static	ANTLR3_BITWORD FOLLOW_expression_in_expression1275_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_expression1275	= { FOLLOW_expression_in_expression1275_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_OPERATOR_BIT_AND_in_expression1286  */
static	ANTLR3_BITWORD FOLLOW_OPERATOR_BIT_AND_in_expression1286_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_OPERATOR_BIT_AND_in_expression1286	= { FOLLOW_OPERATOR_BIT_AND_in_expression1286_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_expression1290  */
static	ANTLR3_BITWORD FOLLOW_expression_in_expression1290_bits[]	= { ANTLR3_UINT64_LIT(0xEFF3BFFA84208100), ANTLR3_UINT64_LIT(0x000000000A00BFFF) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_expression1290	= { FOLLOW_expression_in_expression1290_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_expression1294  */
static	ANTLR3_BITWORD FOLLOW_expression_in_expression1294_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_expression1294	= { FOLLOW_expression_in_expression1294_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_OPERATOR_BIT_OR_in_expression1305  */
static	ANTLR3_BITWORD FOLLOW_OPERATOR_BIT_OR_in_expression1305_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_OPERATOR_BIT_OR_in_expression1305	= { FOLLOW_OPERATOR_BIT_OR_in_expression1305_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_expression1309  */
static	ANTLR3_BITWORD FOLLOW_expression_in_expression1309_bits[]	= { ANTLR3_UINT64_LIT(0xEFF3BFFA84208100), ANTLR3_UINT64_LIT(0x000000000A00BFFF) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_expression1309	= { FOLLOW_expression_in_expression1309_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_expression1313  */
static	ANTLR3_BITWORD FOLLOW_expression_in_expression1313_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_expression1313	= { FOLLOW_expression_in_expression1313_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_OPERATOR_EQUAL_TO_in_expression1324  */
static	ANTLR3_BITWORD FOLLOW_OPERATOR_EQUAL_TO_in_expression1324_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_OPERATOR_EQUAL_TO_in_expression1324	= { FOLLOW_OPERATOR_EQUAL_TO_in_expression1324_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_expression1328  */
static	ANTLR3_BITWORD FOLLOW_expression_in_expression1328_bits[]	= { ANTLR3_UINT64_LIT(0xEFF3BFFA84208100), ANTLR3_UINT64_LIT(0x000000000A00BFFF) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_expression1328	= { FOLLOW_expression_in_expression1328_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_expression1332  */
static	ANTLR3_BITWORD FOLLOW_expression_in_expression1332_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_expression1332	= { FOLLOW_expression_in_expression1332_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_OPERATOR_NOT_EQUAL_TO_in_expression1343  */
static	ANTLR3_BITWORD FOLLOW_OPERATOR_NOT_EQUAL_TO_in_expression1343_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_OPERATOR_NOT_EQUAL_TO_in_expression1343	= { FOLLOW_OPERATOR_NOT_EQUAL_TO_in_expression1343_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_expression1347  */
static	ANTLR3_BITWORD FOLLOW_expression_in_expression1347_bits[]	= { ANTLR3_UINT64_LIT(0xEFF3BFFA84208100), ANTLR3_UINT64_LIT(0x000000000A00BFFF) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_expression1347	= { FOLLOW_expression_in_expression1347_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_expression1351  */
static	ANTLR3_BITWORD FOLLOW_expression_in_expression1351_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_expression1351	= { FOLLOW_expression_in_expression1351_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_OPERATOR_LESS_THAN_in_expression1362  */
static	ANTLR3_BITWORD FOLLOW_OPERATOR_LESS_THAN_in_expression1362_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_OPERATOR_LESS_THAN_in_expression1362	= { FOLLOW_OPERATOR_LESS_THAN_in_expression1362_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_expression1366  */
static	ANTLR3_BITWORD FOLLOW_expression_in_expression1366_bits[]	= { ANTLR3_UINT64_LIT(0xEFF3BFFA84208100), ANTLR3_UINT64_LIT(0x000000000A00BFFF) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_expression1366	= { FOLLOW_expression_in_expression1366_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_expression1370  */
static	ANTLR3_BITWORD FOLLOW_expression_in_expression1370_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_expression1370	= { FOLLOW_expression_in_expression1370_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_OPERATOR_LESS_THAN_OR_EQUAL_TO_in_expression1381  */
static	ANTLR3_BITWORD FOLLOW_OPERATOR_LESS_THAN_OR_EQUAL_TO_in_expression1381_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_OPERATOR_LESS_THAN_OR_EQUAL_TO_in_expression1381	= { FOLLOW_OPERATOR_LESS_THAN_OR_EQUAL_TO_in_expression1381_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_expression1385  */
static	ANTLR3_BITWORD FOLLOW_expression_in_expression1385_bits[]	= { ANTLR3_UINT64_LIT(0xEFF3BFFA84208100), ANTLR3_UINT64_LIT(0x000000000A00BFFF) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_expression1385	= { FOLLOW_expression_in_expression1385_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_expression1389  */
static	ANTLR3_BITWORD FOLLOW_expression_in_expression1389_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_expression1389	= { FOLLOW_expression_in_expression1389_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_OPERATOR_GREATER_THAN_in_expression1400  */
static	ANTLR3_BITWORD FOLLOW_OPERATOR_GREATER_THAN_in_expression1400_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_OPERATOR_GREATER_THAN_in_expression1400	= { FOLLOW_OPERATOR_GREATER_THAN_in_expression1400_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_expression1404  */
static	ANTLR3_BITWORD FOLLOW_expression_in_expression1404_bits[]	= { ANTLR3_UINT64_LIT(0xEFF3BFFA84208100), ANTLR3_UINT64_LIT(0x000000000A00BFFF) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_expression1404	= { FOLLOW_expression_in_expression1404_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_expression1408  */
static	ANTLR3_BITWORD FOLLOW_expression_in_expression1408_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_expression1408	= { FOLLOW_expression_in_expression1408_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_OPERATOR_GREATER_THAN_OR_EQUAL_TO_in_expression1419  */
static	ANTLR3_BITWORD FOLLOW_OPERATOR_GREATER_THAN_OR_EQUAL_TO_in_expression1419_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_OPERATOR_GREATER_THAN_OR_EQUAL_TO_in_expression1419	= { FOLLOW_OPERATOR_GREATER_THAN_OR_EQUAL_TO_in_expression1419_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_expression1423  */
static	ANTLR3_BITWORD FOLLOW_expression_in_expression1423_bits[]	= { ANTLR3_UINT64_LIT(0xEFF3BFFA84208100), ANTLR3_UINT64_LIT(0x000000000A00BFFF) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_expression1423	= { FOLLOW_expression_in_expression1423_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_expression1427  */
static	ANTLR3_BITWORD FOLLOW_expression_in_expression1427_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_expression1427	= { FOLLOW_expression_in_expression1427_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_OPERATOR_LSHIFT_in_expression1438  */
static	ANTLR3_BITWORD FOLLOW_OPERATOR_LSHIFT_in_expression1438_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_OPERATOR_LSHIFT_in_expression1438	= { FOLLOW_OPERATOR_LSHIFT_in_expression1438_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_expression1442  */
static	ANTLR3_BITWORD FOLLOW_expression_in_expression1442_bits[]	= { ANTLR3_UINT64_LIT(0xEFF3BFFA84208100), ANTLR3_UINT64_LIT(0x000000000A00BFFF) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_expression1442	= { FOLLOW_expression_in_expression1442_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_expression1446  */
static	ANTLR3_BITWORD FOLLOW_expression_in_expression1446_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_expression1446	= { FOLLOW_expression_in_expression1446_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_OPERATOR_RSHIFT_in_expression1457  */
static	ANTLR3_BITWORD FOLLOW_OPERATOR_RSHIFT_in_expression1457_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_OPERATOR_RSHIFT_in_expression1457	= { FOLLOW_OPERATOR_RSHIFT_in_expression1457_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_expression1461  */
static	ANTLR3_BITWORD FOLLOW_expression_in_expression1461_bits[]	= { ANTLR3_UINT64_LIT(0xEFF3BFFA84208100), ANTLR3_UINT64_LIT(0x000000000A00BFFF) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_expression1461	= { FOLLOW_expression_in_expression1461_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_expression1465  */
static	ANTLR3_BITWORD FOLLOW_expression_in_expression1465_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_expression1465	= { FOLLOW_expression_in_expression1465_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_OPERATOR_PLUS_in_expression1476  */
static	ANTLR3_BITWORD FOLLOW_OPERATOR_PLUS_in_expression1476_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_OPERATOR_PLUS_in_expression1476	= { FOLLOW_OPERATOR_PLUS_in_expression1476_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_expression1480  */
static	ANTLR3_BITWORD FOLLOW_expression_in_expression1480_bits[]	= { ANTLR3_UINT64_LIT(0xEFF3BFFA84208100), ANTLR3_UINT64_LIT(0x000000000A00BFFF) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_expression1480	= { FOLLOW_expression_in_expression1480_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_expression1484  */
static	ANTLR3_BITWORD FOLLOW_expression_in_expression1484_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_expression1484	= { FOLLOW_expression_in_expression1484_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_OPERATOR_MINUS_in_expression1495  */
static	ANTLR3_BITWORD FOLLOW_OPERATOR_MINUS_in_expression1495_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_OPERATOR_MINUS_in_expression1495	= { FOLLOW_OPERATOR_MINUS_in_expression1495_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_expression1499  */
static	ANTLR3_BITWORD FOLLOW_expression_in_expression1499_bits[]	= { ANTLR3_UINT64_LIT(0xEFF3BFFA84208100), ANTLR3_UINT64_LIT(0x000000000A00BFFF) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_expression1499	= { FOLLOW_expression_in_expression1499_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_expression1503  */
static	ANTLR3_BITWORD FOLLOW_expression_in_expression1503_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_expression1503	= { FOLLOW_expression_in_expression1503_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_OPERATOR_TIMES_in_expression1514  */
static	ANTLR3_BITWORD FOLLOW_OPERATOR_TIMES_in_expression1514_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_OPERATOR_TIMES_in_expression1514	= { FOLLOW_OPERATOR_TIMES_in_expression1514_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_expression1518  */
static	ANTLR3_BITWORD FOLLOW_expression_in_expression1518_bits[]	= { ANTLR3_UINT64_LIT(0xEFF3BFFA84208100), ANTLR3_UINT64_LIT(0x000000000A00BFFF) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_expression1518	= { FOLLOW_expression_in_expression1518_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_expression1522  */
static	ANTLR3_BITWORD FOLLOW_expression_in_expression1522_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_expression1522	= { FOLLOW_expression_in_expression1522_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_OPERATOR_DIVIDE_in_expression1533  */
static	ANTLR3_BITWORD FOLLOW_OPERATOR_DIVIDE_in_expression1533_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_OPERATOR_DIVIDE_in_expression1533	= { FOLLOW_OPERATOR_DIVIDE_in_expression1533_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_expression1537  */
static	ANTLR3_BITWORD FOLLOW_expression_in_expression1537_bits[]	= { ANTLR3_UINT64_LIT(0xEFF3BFFA84208100), ANTLR3_UINT64_LIT(0x000000000A00BFFF) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_expression1537	= { FOLLOW_expression_in_expression1537_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_expression1541  */
static	ANTLR3_BITWORD FOLLOW_expression_in_expression1541_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_expression1541	= { FOLLOW_expression_in_expression1541_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_OPERATOR_MODULO_in_expression1552  */
static	ANTLR3_BITWORD FOLLOW_OPERATOR_MODULO_in_expression1552_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_OPERATOR_MODULO_in_expression1552	= { FOLLOW_OPERATOR_MODULO_in_expression1552_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_expression1556  */
static	ANTLR3_BITWORD FOLLOW_expression_in_expression1556_bits[]	= { ANTLR3_UINT64_LIT(0xEFF3BFFA84208100), ANTLR3_UINT64_LIT(0x000000000A00BFFF) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_expression1556	= { FOLLOW_expression_in_expression1556_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_expression1560  */
static	ANTLR3_BITWORD FOLLOW_expression_in_expression1560_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_expression1560	= { FOLLOW_expression_in_expression1560_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_OPERATOR_INCREMENT_PRE_in_expression1571  */
static	ANTLR3_BITWORD FOLLOW_OPERATOR_INCREMENT_PRE_in_expression1571_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_OPERATOR_INCREMENT_PRE_in_expression1571	= { FOLLOW_OPERATOR_INCREMENT_PRE_in_expression1571_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_expression1575  */
static	ANTLR3_BITWORD FOLLOW_expression_in_expression1575_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_expression1575	= { FOLLOW_expression_in_expression1575_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_OPERATOR_INCREMENT_POST_in_expression1587  */
static	ANTLR3_BITWORD FOLLOW_OPERATOR_INCREMENT_POST_in_expression1587_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_OPERATOR_INCREMENT_POST_in_expression1587	= { FOLLOW_OPERATOR_INCREMENT_POST_in_expression1587_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_expression1591  */
static	ANTLR3_BITWORD FOLLOW_expression_in_expression1591_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_expression1591	= { FOLLOW_expression_in_expression1591_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_OPERATOR_DECREMENT_PRE_in_expression1604  */
static	ANTLR3_BITWORD FOLLOW_OPERATOR_DECREMENT_PRE_in_expression1604_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_OPERATOR_DECREMENT_PRE_in_expression1604	= { FOLLOW_OPERATOR_DECREMENT_PRE_in_expression1604_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_expression1608  */
static	ANTLR3_BITWORD FOLLOW_expression_in_expression1608_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_expression1608	= { FOLLOW_expression_in_expression1608_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_OPERATOR_DECREMENT_POST_in_expression1620  */
static	ANTLR3_BITWORD FOLLOW_OPERATOR_DECREMENT_POST_in_expression1620_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_OPERATOR_DECREMENT_POST_in_expression1620	= { FOLLOW_OPERATOR_DECREMENT_POST_in_expression1620_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_expression1624  */
static	ANTLR3_BITWORD FOLLOW_expression_in_expression1624_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_expression1624	= { FOLLOW_expression_in_expression1624_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_OPERATOR_PLUS_UN_in_expression1639  */
static	ANTLR3_BITWORD FOLLOW_OPERATOR_PLUS_UN_in_expression1639_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_OPERATOR_PLUS_UN_in_expression1639	= { FOLLOW_OPERATOR_PLUS_UN_in_expression1639_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_expression1643  */
static	ANTLR3_BITWORD FOLLOW_expression_in_expression1643_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_expression1643	= { FOLLOW_expression_in_expression1643_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_OPERATOR_MINUS_UN_in_expression1658  */
static	ANTLR3_BITWORD FOLLOW_OPERATOR_MINUS_UN_in_expression1658_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_OPERATOR_MINUS_UN_in_expression1658	= { FOLLOW_OPERATOR_MINUS_UN_in_expression1658_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_expression1662  */
static	ANTLR3_BITWORD FOLLOW_expression_in_expression1662_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_expression1662	= { FOLLOW_expression_in_expression1662_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_OPERATOR_NOT_in_expression1678  */
static	ANTLR3_BITWORD FOLLOW_OPERATOR_NOT_in_expression1678_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_OPERATOR_NOT_in_expression1678	= { FOLLOW_OPERATOR_NOT_in_expression1678_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_expression1682  */
static	ANTLR3_BITWORD FOLLOW_expression_in_expression1682_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_expression1682	= { FOLLOW_expression_in_expression1682_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_OPERATOR_RELATIVE_in_expression1699  */
static	ANTLR3_BITWORD FOLLOW_OPERATOR_RELATIVE_in_expression1699_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_OPERATOR_RELATIVE_in_expression1699	= { FOLLOW_OPERATOR_RELATIVE_in_expression1699_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_expression1703  */
static	ANTLR3_BITWORD FOLLOW_expression_in_expression1703_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_expression1703	= { FOLLOW_expression_in_expression1703_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_OPERATOR_DOT_in_expression1719  */
static	ANTLR3_BITWORD FOLLOW_OPERATOR_DOT_in_expression1719_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_OPERATOR_DOT_in_expression1719	= { FOLLOW_OPERATOR_DOT_in_expression1719_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_expression1723  */
static	ANTLR3_BITWORD FOLLOW_expression_in_expression1723_bits[]	= { ANTLR3_UINT64_LIT(0x0000000004000000) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_expression1723	= { FOLLOW_expression_in_expression1723_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_IDENTIFIER_in_expression1725  */
static	ANTLR3_BITWORD FOLLOW_IDENTIFIER_in_expression1725_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_IDENTIFIER_in_expression1725	= { FOLLOW_IDENTIFIER_in_expression1725_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_callExpression_in_expression1735  */
static	ANTLR3_BITWORD FOLLOW_callExpression_in_expression1735_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_callExpression_in_expression1735	= { FOLLOW_callExpression_in_expression1735_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_indexAccessExpression_in_expression1743  */
static	ANTLR3_BITWORD FOLLOW_indexAccessExpression_in_expression1743_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_indexAccessExpression_in_expression1743	= { FOLLOW_indexAccessExpression_in_expression1743_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_IDENTIFIER_in_expression1753  */
static	ANTLR3_BITWORD FOLLOW_IDENTIFIER_in_expression1753_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_IDENTIFIER_in_expression1753	= { FOLLOW_IDENTIFIER_in_expression1753_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_TRUE_LIT_in_expression1764  */
static	ANTLR3_BITWORD FOLLOW_TRUE_LIT_in_expression1764_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_TRUE_LIT_in_expression1764	= { FOLLOW_TRUE_LIT_in_expression1764_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_FALSE_LIT_in_expression1772  */
static	ANTLR3_BITWORD FOLLOW_FALSE_LIT_in_expression1772_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_FALSE_LIT_in_expression1772	= { FOLLOW_FALSE_LIT_in_expression1772_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_NUMBER_in_expression1781  */
static	ANTLR3_BITWORD FOLLOW_NUMBER_in_expression1781_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_NUMBER_in_expression1781	= { FOLLOW_NUMBER_in_expression1781_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_stringLiteral_in_expression1790  */
static	ANTLR3_BITWORD FOLLOW_stringLiteral_in_expression1790_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_stringLiteral_in_expression1790	= { FOLLOW_stringLiteral_in_expression1790_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_coordinateExpression_in_expression1799  */
static	ANTLR3_BITWORD FOLLOW_coordinateExpression_in_expression1799_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_coordinateExpression_in_expression1799	= { FOLLOW_coordinateExpression_in_expression1799_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_collectionLiteral_in_expression1807  */
static	ANTLR3_BITWORD FOLLOW_collectionLiteral_in_expression1807_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_collectionLiteral_in_expression1807	= { FOLLOW_collectionLiteral_in_expression1807_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_COORDINATE_in_coordinateExpression1831  */
static	ANTLR3_BITWORD FOLLOW_COORDINATE_in_coordinateExpression1831_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_COORDINATE_in_coordinateExpression1831	= { FOLLOW_COORDINATE_in_coordinateExpression1831_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_coordinateExpression1834  */
static	ANTLR3_BITWORD FOLLOW_expression_in_coordinateExpression1834_bits[]	= { ANTLR3_UINT64_LIT(0xEFF3BFFA84208108), ANTLR3_UINT64_LIT(0x000000000A00BFFF) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_coordinateExpression1834	= { FOLLOW_expression_in_coordinateExpression1834_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LEFT_BRACKET_in_callExpression1862  */
static	ANTLR3_BITWORD FOLLOW_LEFT_BRACKET_in_callExpression1862_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_LEFT_BRACKET_in_callExpression1862	= { FOLLOW_LEFT_BRACKET_in_callExpression1862_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_IDENTIFIER_in_callExpression1864  */
static	ANTLR3_BITWORD FOLLOW_IDENTIFIER_in_callExpression1864_bits[]	= { ANTLR3_UINT64_LIT(0xEFF3BFFA84208108), ANTLR3_UINT64_LIT(0x000000000A00BFFF) };
static  ANTLR3_BITSET_LIST FOLLOW_IDENTIFIER_in_callExpression1864	= { FOLLOW_IDENTIFIER_in_callExpression1864_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_callExpression1867  */
static	ANTLR3_BITWORD FOLLOW_expression_in_callExpression1867_bits[]	= { ANTLR3_UINT64_LIT(0xEFF3BFFA84208108), ANTLR3_UINT64_LIT(0x000000000A00BFFF) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_callExpression1867	= { FOLLOW_expression_in_callExpression1867_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LEFT_BRACKET_in_callExpression1882  */
static	ANTLR3_BITWORD FOLLOW_LEFT_BRACKET_in_callExpression1882_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_LEFT_BRACKET_in_callExpression1882	= { FOLLOW_LEFT_BRACKET_in_callExpression1882_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_OPERATOR_DOT_in_callExpression1885  */
static	ANTLR3_BITWORD FOLLOW_OPERATOR_DOT_in_callExpression1885_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_OPERATOR_DOT_in_callExpression1885	= { FOLLOW_OPERATOR_DOT_in_callExpression1885_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_callExpression1889  */
static	ANTLR3_BITWORD FOLLOW_expression_in_callExpression1889_bits[]	= { ANTLR3_UINT64_LIT(0x0000000004000000) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_callExpression1889	= { FOLLOW_expression_in_callExpression1889_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_IDENTIFIER_in_callExpression1891  */
static	ANTLR3_BITWORD FOLLOW_IDENTIFIER_in_callExpression1891_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_IDENTIFIER_in_callExpression1891	= { FOLLOW_IDENTIFIER_in_callExpression1891_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_callExpression1897  */
static	ANTLR3_BITWORD FOLLOW_expression_in_callExpression1897_bits[]	= { ANTLR3_UINT64_LIT(0xEFF3BFFA84208108), ANTLR3_UINT64_LIT(0x000000000A00BFFF) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_callExpression1897	= { FOLLOW_expression_in_callExpression1897_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LEFT_SQUARE_BRACKET_in_indexAccessExpression1926  */
static	ANTLR3_BITWORD FOLLOW_LEFT_SQUARE_BRACKET_in_indexAccessExpression1926_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_LEFT_SQUARE_BRACKET_in_indexAccessExpression1926	= { FOLLOW_LEFT_SQUARE_BRACKET_in_indexAccessExpression1926_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_indexAccessExpression1930  */
static	ANTLR3_BITWORD FOLLOW_expression_in_indexAccessExpression1930_bits[]	= { ANTLR3_UINT64_LIT(0xEFF3BFFA84208108), ANTLR3_UINT64_LIT(0x000000000A00BFFF) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_indexAccessExpression1930	= { FOLLOW_expression_in_indexAccessExpression1930_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_indexAccessExpression1935  */
static	ANTLR3_BITWORD FOLLOW_expression_in_indexAccessExpression1935_bits[]	= { ANTLR3_UINT64_LIT(0xEFF3BFFA84208108), ANTLR3_UINT64_LIT(0x000000000A00BFFF) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_indexAccessExpression1935	= { FOLLOW_expression_in_indexAccessExpression1935_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_OPERATOR_EXPR_IF_in_conditionalOperatorExpression1963  */
static	ANTLR3_BITWORD FOLLOW_OPERATOR_EXPR_IF_in_conditionalOperatorExpression1963_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_OPERATOR_EXPR_IF_in_conditionalOperatorExpression1963	= { FOLLOW_OPERATOR_EXPR_IF_in_conditionalOperatorExpression1963_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_conditionalOperatorExpression1967  */
static	ANTLR3_BITWORD FOLLOW_expression_in_conditionalOperatorExpression1967_bits[]	= { ANTLR3_UINT64_LIT(0xEFF3BFFA84208100), ANTLR3_UINT64_LIT(0x000000000A00BFFF) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_conditionalOperatorExpression1967	= { FOLLOW_expression_in_conditionalOperatorExpression1967_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_conditionalOperatorExpression1971  */
static	ANTLR3_BITWORD FOLLOW_expression_in_conditionalOperatorExpression1971_bits[]	= { ANTLR3_UINT64_LIT(0xEFF3BFFA84208100), ANTLR3_UINT64_LIT(0x000000000A00BFFF) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_conditionalOperatorExpression1971	= { FOLLOW_expression_in_conditionalOperatorExpression1971_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_conditionalOperatorExpression1975  */
static	ANTLR3_BITWORD FOLLOW_expression_in_conditionalOperatorExpression1975_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_conditionalOperatorExpression1975	= { FOLLOW_expression_in_conditionalOperatorExpression1975_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_IDENTIFIER_in_lvalueExpression1998  */
static	ANTLR3_BITWORD FOLLOW_IDENTIFIER_in_lvalueExpression1998_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_IDENTIFIER_in_lvalueExpression1998	= { FOLLOW_IDENTIFIER_in_lvalueExpression1998_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_OPERATOR_DOT_in_lvalueExpression2008  */
static	ANTLR3_BITWORD FOLLOW_OPERATOR_DOT_in_lvalueExpression2008_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_OPERATOR_DOT_in_lvalueExpression2008	= { FOLLOW_OPERATOR_DOT_in_lvalueExpression2008_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_lvalueExpression2012  */
static	ANTLR3_BITWORD FOLLOW_expression_in_lvalueExpression2012_bits[]	= { ANTLR3_UINT64_LIT(0x0000000004000000) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_lvalueExpression2012	= { FOLLOW_expression_in_lvalueExpression2012_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_IDENTIFIER_in_lvalueExpression2014  */
static	ANTLR3_BITWORD FOLLOW_IDENTIFIER_in_lvalueExpression2014_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_IDENTIFIER_in_lvalueExpression2014	= { FOLLOW_IDENTIFIER_in_lvalueExpression2014_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_lvalueIndexAccessExpression_in_lvalueExpression2024  */
static	ANTLR3_BITWORD FOLLOW_lvalueIndexAccessExpression_in_lvalueExpression2024_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_lvalueIndexAccessExpression_in_lvalueExpression2024	= { FOLLOW_lvalueIndexAccessExpression_in_lvalueExpression2024_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LEFT_SQUARE_BRACKET_in_lvalueIndexAccessExpression2050  */
static	ANTLR3_BITWORD FOLLOW_LEFT_SQUARE_BRACKET_in_lvalueIndexAccessExpression2050_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_LEFT_SQUARE_BRACKET_in_lvalueIndexAccessExpression2050	= { FOLLOW_LEFT_SQUARE_BRACKET_in_lvalueIndexAccessExpression2050_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_lvalueIndexAccessExpression2054  */
static	ANTLR3_BITWORD FOLLOW_expression_in_lvalueIndexAccessExpression2054_bits[]	= { ANTLR3_UINT64_LIT(0xEFF3BFFA84208108), ANTLR3_UINT64_LIT(0x000000000A00BFFF) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_lvalueIndexAccessExpression2054	= { FOLLOW_expression_in_lvalueIndexAccessExpression2054_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_lvalueIndexAccessExpression2059  */
static	ANTLR3_BITWORD FOLLOW_expression_in_lvalueIndexAccessExpression2059_bits[]	= { ANTLR3_UINT64_LIT(0xEFF3BFFA84208108), ANTLR3_UINT64_LIT(0x000000000A00BFFF) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_lvalueIndexAccessExpression2059	= { FOLLOW_expression_in_lvalueIndexAccessExpression2059_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_COLLECTION_in_collectionLiteral2127  */
static	ANTLR3_BITWORD FOLLOW_COLLECTION_in_collectionLiteral2127_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_COLLECTION_in_collectionLiteral2127	= { FOLLOW_COLLECTION_in_collectionLiteral2127_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_collectionLiteralItem_in_collectionLiteral2130  */
static	ANTLR3_BITWORD FOLLOW_collectionLiteralItem_in_collectionLiteral2130_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000208) };
static  ANTLR3_BITSET_LIST FOLLOW_collectionLiteralItem_in_collectionLiteral2130	= { FOLLOW_collectionLiteralItem_in_collectionLiteral2130_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_COLLECTION_ITEM_in_collectionLiteralItem2162  */
static	ANTLR3_BITWORD FOLLOW_COLLECTION_ITEM_in_collectionLiteralItem2162_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_COLLECTION_ITEM_in_collectionLiteralItem2162	= { FOLLOW_COLLECTION_ITEM_in_collectionLiteralItem2162_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_collectionLiteralItem2166  */
static	ANTLR3_BITWORD FOLLOW_expression_in_collectionLiteralItem2166_bits[]	= { ANTLR3_UINT64_LIT(0xEFF3BFFA84208108), ANTLR3_UINT64_LIT(0x000000000A00BFFF) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_collectionLiteralItem2166	= { FOLLOW_expression_in_collectionLiteralItem2166_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_collectionLiteralItem2182  */
static	ANTLR3_BITWORD FOLLOW_expression_in_collectionLiteralItem2182_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_collectionLiteralItem2182	= { FOLLOW_expression_in_collectionLiteralItem2182_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_IDENTCHAIN_in_label2211  */
static	ANTLR3_BITWORD FOLLOW_IDENTCHAIN_in_label2211_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_IDENTCHAIN_in_label2211	= { FOLLOW_IDENTCHAIN_in_label2211_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_IDENTIFIER_in_label2213  */
static	ANTLR3_BITWORD FOLLOW_IDENTIFIER_in_label2213_bits[]	= { ANTLR3_UINT64_LIT(0x0000000004000008) };
static  ANTLR3_BITSET_LIST FOLLOW_IDENTIFIER_in_label2213	= { FOLLOW_IDENTIFIER_in_label2213_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_TRUE_LIT_in_label2220  */
static	ANTLR3_BITWORD FOLLOW_TRUE_LIT_in_label2220_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_TRUE_LIT_in_label2220	= { FOLLOW_TRUE_LIT_in_label2220_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_FALSE_LIT_in_label2232  */
static	ANTLR3_BITWORD FOLLOW_FALSE_LIT_in_label2232_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_FALSE_LIT_in_label2232	= { FOLLOW_FALSE_LIT_in_label2232_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_NUMBER_in_label2237  */
static	ANTLR3_BITWORD FOLLOW_NUMBER_in_label2237_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_NUMBER_in_label2237	= { FOLLOW_NUMBER_in_label2237_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_STRING_in_label2242  */
static	ANTLR3_BITWORD FOLLOW_STRING_in_label2242_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_STRING_in_label2242	= { FOLLOW_STRING_in_label2242_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_STRING_in_stringLiteral2255  */
static	ANTLR3_BITWORD FOLLOW_STRING_in_stringLiteral2255_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_STRING_in_stringLiteral2255	= { FOLLOW_STRING_in_stringLiteral2255_bits, 1	};


/* ==============================================
 * Parsing rules
 */
/**
 * $ANTLR start script
 * C:\\Users\\matej_000\\Source\\Repos\\geogen\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:204:1: script : ^( SCRIPT ( metadata )? ^( DECLARATIONS ( declaration )* ) block ) ;
 */
static void
script(pGeoGenScriptDecls ctx)
{
    CodeBlock* block1;
    #undef	RETURN_TYPE_block1
    #define	RETURN_TYPE_block1 CodeBlock*

    /* Initialize rule variables
     */

    {
        // C:\\Users\\matej_000\\Source\\Repos\\geogen\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:204:7: ( ^( SCRIPT ( metadata )? ^( DECLARATIONS ( declaration )* ) block ) )
        // C:\\Users\\matej_000\\Source\\Repos\\geogen\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:204:9: ^( SCRIPT ( metadata )? ^( DECLARATIONS ( declaration )* ) block )
        {
             MATCHT(SCRIPT, &FOLLOW_SCRIPT_in_script95);
            if  (HASEXCEPTION())
            {
                goto rulescriptEx;
            }


            MATCHT(ANTLR3_TOKEN_DOWN, NULL);
            if  (HASEXCEPTION())
            {
                goto rulescriptEx;
            }

            // C:\\Users\\matej_000\\Source\\Repos\\geogen\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:204:18: ( metadata )?
            {
                int alt1=2;
                switch ( LA(1) )
                {
                    case METADATA:
                    	{
                    		alt1=1;
                    	}
                        break;
                }

                switch (alt1)
                {
            	case 1:
            	    // C:\\Users\\matej_000\\Source\\Repos\\geogen\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:204:18: metadata
            	    {
            	        FOLLOWPUSH(FOLLOW_metadata_in_script97);
            	        metadata(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulescriptEx;
            	        }


            	    }
            	    break;

                }
            }

             MATCHT(DECLARATIONS, &FOLLOW_DECLARATIONS_in_script101);
            if  (HASEXCEPTION())
            {
                goto rulescriptEx;
            }


            if ( LA(1)==ANTLR3_TOKEN_DOWN ) {
                MATCHT(ANTLR3_TOKEN_DOWN, NULL);
                if  (HASEXCEPTION())
                {
                    goto rulescriptEx;
                }

                // C:\\Users\\matej_000\\Source\\Repos\\geogen\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:204:43: ( declaration )*

                for (;;)
                {
                    int alt2=2;
                    switch ( LA(1) )
                    {
                    case ENUM:
                    case FUNCTION:
                    	{
                    		alt2=1;
                    	}
                        break;

                    }

                    switch (alt2)
                    {
                	case 1:
                	    // C:\\Users\\matej_000\\Source\\Repos\\geogen\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:204:43: declaration
                	    {
                	        FOLLOWPUSH(FOLLOW_declaration_in_script103);
                	        declaration(ctx);

                	        FOLLOWPOP();
                	        if  (HASEXCEPTION())
                	        {
                	            goto rulescriptEx;
                	        }


                	    }
                	    break;

                	default:
                	    goto loop2;	/* break out of the loop */
                	    break;
                    }
                }
                loop2: ; /* Jump out to here if this rule does not match */


                MATCHT(ANTLR3_TOKEN_UP, NULL);
                if  (HASEXCEPTION())
                {
                    goto rulescriptEx;
                }

            }


            FOLLOWPUSH(FOLLOW_block_in_script107);
            block1=block(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulescriptEx;
            }


            MATCHT(ANTLR3_TOKEN_UP, NULL);
            if  (HASEXCEPTION())
            {
                goto rulescriptEx;
            }



            {
                 
                	ctx->rootCodeBlock->MoveInstructionsFrom(*block1
                ); 
                	ctx->rootCodeBlock->AddInstruction(new instructions::LoadNullInstruction(CodeLocation(0, 0)));
                	delete block1
                ; 

            }


        }

    }

    // This is where rules clean up and exit
    //
    goto rulescriptEx; /* Prevent compiler warnings */
    rulescriptEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end script */

/**
 * $ANTLR start metadata
 * C:\\Users\\matej_000\\Source\\Repos\\geogen\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:211:1: metadata : ^( METADATA metadataKeyValueCollection ) ;
 */
static void
metadata(pGeoGenScriptDecls ctx)
{
    MetadataValue* metadataKeyValueCollection2;
    #undef	RETURN_TYPE_metadataKeyValueCollection2
    #define	RETURN_TYPE_metadataKeyValueCollection2 MetadataValue*

    /* Initialize rule variables
     */

    {
        // C:\\Users\\matej_000\\Source\\Repos\\geogen\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:211:9: ( ^( METADATA metadataKeyValueCollection ) )
        // C:\\Users\\matej_000\\Source\\Repos\\geogen\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:211:11: ^( METADATA metadataKeyValueCollection )
        {
             MATCHT(METADATA, &FOLLOW_METADATA_in_metadata127);
            if  (HASEXCEPTION())
            {
                goto rulemetadataEx;
            }


            MATCHT(ANTLR3_TOKEN_DOWN, NULL);
            if  (HASEXCEPTION())
            {
                goto rulemetadataEx;
            }

            FOLLOWPUSH(FOLLOW_metadataKeyValueCollection_in_metadata129);
            metadataKeyValueCollection2=metadataKeyValueCollection(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulemetadataEx;
            }


            MATCHT(ANTLR3_TOKEN_UP, NULL);
            if  (HASEXCEPTION())
            {
                goto rulemetadataEx;
            }



            {
                 
                	ctx->compiledScript->GetMetadata().MoveKeyValuesFrom(*dynamic_cast<MetadataKeyValueCollection*>(metadataKeyValueCollection2
                ));
                	delete metadataKeyValueCollection2
                ;

            }


        }

    }

    // This is where rules clean up and exit
    //
    goto rulemetadataEx; /* Prevent compiler warnings */
    rulemetadataEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end metadata */

/**
 * $ANTLR start metadataKeyValueCollection
 * C:\\Users\\matej_000\\Source\\Repos\\geogen\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:217:1: metadataKeyValueCollection returns [MetadataValue* value] : ^( COLLECTION ( metadataKeyValuePair )* ) ;
 */
static MetadataValue*
metadataKeyValueCollection(pGeoGenScriptDecls ctx)
{
    MetadataValue* value;


    pANTLR3_BASE_TREE    COLLECTION3;
    GeoGenScriptDecls_metadataKeyValuePair_return metadataKeyValuePair4;
    #undef	RETURN_TYPE_metadataKeyValuePair4
    #define	RETURN_TYPE_metadataKeyValuePair4 GeoGenScriptDecls_metadataKeyValuePair_return

    /* Initialize rule variables
     */


    	MetadataKeyValueCollection* ret = NULL;
    	value= NULL;


    COLLECTION3       = NULL;

    {
        // C:\\Users\\matej_000\\Source\\Repos\\geogen\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:221:3: ( ^( COLLECTION ( metadataKeyValuePair )* ) )
        // C:\\Users\\matej_000\\Source\\Repos\\geogen\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:221:5: ^( COLLECTION ( metadataKeyValuePair )* )
        {
            COLLECTION3 = (pANTLR3_BASE_TREE) MATCHT(COLLECTION, &FOLLOW_COLLECTION_in_metadataKeyValueCollection151);
            if  (HASEXCEPTION())
            {
                goto rulemetadataKeyValueCollectionEx;
            }


            {

                		ret = new MetadataKeyValueCollection(CodeLocation((COLLECTION3->getLine(COLLECTION3)), (COLLECTION3->getCharPositionInLine(COLLECTION3))));
                		
                value= ret;
                	
                	
            }


            if ( LA(1)==ANTLR3_TOKEN_DOWN ) {
                MATCHT(ANTLR3_TOKEN_DOWN, NULL);
                if  (HASEXCEPTION())
                {
                    goto rulemetadataKeyValueCollectionEx;
                }

                // C:\\Users\\matej_000\\Source\\Repos\\geogen\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:225:4: ( metadataKeyValuePair )*

                for (;;)
                {
                    int alt3=2;
                    switch ( LA(1) )
                    {
                    case IDENTIFIER:
                    case NUMBER:
                    	{
                    		alt3=1;
                    	}
                        break;

                    }

                    switch (alt3)
                    {
                	case 1:
                	    // C:\\Users\\matej_000\\Source\\Repos\\geogen\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:225:5: metadataKeyValuePair
                	    {
                	        FOLLOWPUSH(FOLLOW_metadataKeyValuePair_in_metadataKeyValueCollection158);
                	        metadataKeyValuePair4=metadataKeyValuePair(ctx);

                	        FOLLOWPOP();
                	        if  (HASEXCEPTION())
                	        {
                	            goto rulemetadataKeyValueCollectionEx;
                	        }


                	        {
                	             
                	            		if(!ret->AddItem(metadataKeyValuePair4.name
                	            , metadataKeyValuePair4.value
                	            ))
                	            		{
                	            			CodeLocation location((COLLECTION3->getLine(COLLECTION3)), (COLLECTION3->getCharPositionInLine(COLLECTION3)));
                	            			throw MetadataKeyRedefinitionException(location, 
                	            metadataKeyValuePair4.name
                	            );
                	            		}
                	            		/*delete metadataKeyValuePair4.name
                	            ; */
                	            	
                	        }


                	    }
                	    break;

                	default:
                	    goto loop3;	/* break out of the loop */
                	    break;
                    }
                }
                loop3: ; /* Jump out to here if this rule does not match */


                MATCHT(ANTLR3_TOKEN_UP, NULL);
                if  (HASEXCEPTION())
                {
                    goto rulemetadataKeyValueCollectionEx;
                }

            }


        }

    }

    // This is where rules clean up and exit
    //
    goto rulemetadataKeyValueCollectionEx; /* Prevent compiler warnings */
    rulemetadataKeyValueCollectionEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return value;
}
/* $ANTLR end metadataKeyValueCollection */

/**
 * $ANTLR start metadataList
 * C:\\Users\\matej_000\\Source\\Repos\\geogen\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:235:1: metadataList returns [MetadataValue* value] : ^( SIMPLE_COLLECTION ( metadataKeyValueValue )* ) ;
 */
static MetadataValue*
metadataList(pGeoGenScriptDecls ctx)
{
    MetadataValue* value;


    pANTLR3_BASE_TREE    SIMPLE_COLLECTION5;
    MetadataValue* metadataKeyValueValue6;
    #undef	RETURN_TYPE_metadataKeyValueValue6
    #define	RETURN_TYPE_metadataKeyValueValue6 MetadataValue*

    /* Initialize rule variables
     */


    	MetadataList* ret = NULL;
    	value= NULL;


    SIMPLE_COLLECTION5       = NULL;

    {
        // C:\\Users\\matej_000\\Source\\Repos\\geogen\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:239:3: ( ^( SIMPLE_COLLECTION ( metadataKeyValueValue )* ) )
        // C:\\Users\\matej_000\\Source\\Repos\\geogen\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:239:5: ^( SIMPLE_COLLECTION ( metadataKeyValueValue )* )
        {
            SIMPLE_COLLECTION5 = (pANTLR3_BASE_TREE) MATCHT(SIMPLE_COLLECTION, &FOLLOW_SIMPLE_COLLECTION_in_metadataList184);
            if  (HASEXCEPTION())
            {
                goto rulemetadataListEx;
            }


            {

                		ret = new MetadataList(CodeLocation((SIMPLE_COLLECTION5->getLine(SIMPLE_COLLECTION5)), (SIMPLE_COLLECTION5->getCharPositionInLine(SIMPLE_COLLECTION5))));
                		
                value= ret;
                	
                	
            }


            if ( LA(1)==ANTLR3_TOKEN_DOWN ) {
                MATCHT(ANTLR3_TOKEN_DOWN, NULL);
                if  (HASEXCEPTION())
                {
                    goto rulemetadataListEx;
                }

                // C:\\Users\\matej_000\\Source\\Repos\\geogen\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:243:4: ( metadataKeyValueValue )*

                for (;;)
                {
                    int alt4=2;
                    switch ( LA(1) )
                    {
                    case COLLECTION:
                    case FALSE_LIT:
                    case IDENTIFIER:
                    case NUMBER:
                    case SIMPLE_COLLECTION:
                    case STRING:
                    case TRUE_LIT:
                    	{
                    		alt4=1;
                    	}
                        break;

                    }

                    switch (alt4)
                    {
                	case 1:
                	    // C:\\Users\\matej_000\\Source\\Repos\\geogen\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:243:5: metadataKeyValueValue
                	    {
                	        FOLLOWPUSH(FOLLOW_metadataKeyValueValue_in_metadataList191);
                	        metadataKeyValueValue6=metadataKeyValueValue(ctx);

                	        FOLLOWPOP();
                	        if  (HASEXCEPTION())
                	        {
                	            goto rulemetadataListEx;
                	        }


                	        {
                	             
                	            		ret->AddItem(metadataKeyValueValue6
                	            );
                	            	
                	        }


                	    }
                	    break;

                	default:
                	    goto loop4;	/* break out of the loop */
                	    break;
                    }
                }
                loop4: ; /* Jump out to here if this rule does not match */


                MATCHT(ANTLR3_TOKEN_UP, NULL);
                if  (HASEXCEPTION())
                {
                    goto rulemetadataListEx;
                }

            }


        }

    }

    // This is where rules clean up and exit
    //
    goto rulemetadataListEx; /* Prevent compiler warnings */
    rulemetadataListEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return value;
}
/* $ANTLR end metadataList */

/**
 * $ANTLR start metadataKeyValuePair
 * C:\\Users\\matej_000\\Source\\Repos\\geogen\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:248:1: metadataKeyValuePair returns [String name, MetadataValue* value] : ( ^( IDENTIFIER metadataKeyValueValue ) | ^( NUMBER metadataKeyValueValue ( '@' )? ) );
 */
static GeoGenScriptDecls_metadataKeyValuePair_return
metadataKeyValuePair(pGeoGenScriptDecls ctx)
{
    GeoGenScriptDecls_metadataKeyValuePair_return retval;


    pANTLR3_BASE_TREE    IDENTIFIER7;
    pANTLR3_BASE_TREE    NUMBER9;
    MetadataValue* metadataKeyValueValue8;
    #undef	RETURN_TYPE_metadataKeyValueValue8
    #define	RETURN_TYPE_metadataKeyValueValue8 MetadataValue*

    MetadataValue* metadataKeyValueValue10;
    #undef	RETURN_TYPE_metadataKeyValueValue10
    #define	RETURN_TYPE_metadataKeyValueValue10 MetadataValue*

    /* Initialize rule variables
     */

     retval.value= NULL;
     
    IDENTIFIER7       = NULL;
    NUMBER9       = NULL;
    retval.start = LT(1); retval.stop = retval.start;


    {
        {
            //  C:\\Users\\matej_000\\Source\\Repos\\geogen\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:248:89: ( ^( IDENTIFIER metadataKeyValueValue ) | ^( NUMBER metadataKeyValueValue ( '@' )? ) )

            ANTLR3_UINT32 alt6;

            alt6=2;

            switch ( LA(1) )
            {
            case IDENTIFIER:
            	{
            		alt6=1;
            	}
                break;
            case NUMBER:
            	{
            		alt6=2;
            	}
                break;

            default:
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 6;
                EXCEPTION->state        = 0;


                goto rulemetadataKeyValuePairEx;

            }

            switch (alt6)
            {
        	case 1:
        	    // C:\\Users\\matej_000\\Source\\Repos\\geogen\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:249:2: ^( IDENTIFIER metadataKeyValueValue )
        	    {
        	        IDENTIFIER7 = (pANTLR3_BASE_TREE) MATCHT(IDENTIFIER, &FOLLOW_IDENTIFIER_in_metadataKeyValuePair217);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulemetadataKeyValuePairEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_DOWN, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulemetadataKeyValuePairEx;
        	        }

        	        FOLLOWPUSH(FOLLOW_metadataKeyValueValue_in_metadataKeyValuePair219);
        	        metadataKeyValueValue8=metadataKeyValueValue(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulemetadataKeyValuePairEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_UP, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulemetadataKeyValuePairEx;
        	        }



        	        {
        	             retval.name= (Char*)(IDENTIFIER7->getText(IDENTIFIER7))->chars;
        	             retval.value= 
        	            metadataKeyValueValue8
        	            ;
        	             
        	        }


        	    }
        	    break;
        	case 2:
        	    // C:\\Users\\matej_000\\Source\\Repos\\geogen\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:250:4: ^( NUMBER metadataKeyValueValue ( '@' )? )
        	    {
        	        NUMBER9 = (pANTLR3_BASE_TREE) MATCHT(NUMBER, &FOLLOW_NUMBER_in_metadataKeyValuePair228);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulemetadataKeyValuePairEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_DOWN, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulemetadataKeyValuePairEx;
        	        }

        	        FOLLOWPUSH(FOLLOW_metadataKeyValueValue_in_metadataKeyValuePair230);
        	        metadataKeyValueValue10=metadataKeyValueValue(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulemetadataKeyValuePairEx;
        	        }


        	        // C:\\Users\\matej_000\\Source\\Repos\\geogen\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:250:35: ( '@' )?
        	        {
        	            int alt5=2;
        	            switch ( LA(1) )
        	            {
        	                case 97:
        	                	{
        	                		alt5=1;
        	                	}
        	                    break;
        	            }

        	            switch (alt5)
        	            {
        	        	case 1:
        	        	    // C:\\Users\\matej_000\\Source\\Repos\\geogen\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:250:35: '@'
        	        	    {
        	        	         MATCHT(97, &FOLLOW_97_in_metadataKeyValuePair232);
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto rulemetadataKeyValuePairEx;
        	        	        }


        	        	    }
        	        	    break;

        	            }
        	        }

        	        MATCHT(ANTLR3_TOKEN_UP, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulemetadataKeyValuePairEx;
        	        }



        	        {
        	             retval.name= (Char*)(NUMBER9->getText(NUMBER9))->chars;
        	             retval.value= 
        	            metadataKeyValueValue10
        	            ;
        	             
        	        }


        	    }
        	    break;

            }
        }
    }

    // This is where rules clean up and exit
    //
    goto rulemetadataKeyValuePairEx; /* Prevent compiler warnings */
    rulemetadataKeyValuePairEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return retval;
}
/* $ANTLR end metadataKeyValuePair */

/**
 * $ANTLR start metadataKeyValueValue
 * C:\\Users\\matej_000\\Source\\Repos\\geogen\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:252:1: metadataKeyValueValue returns [MetadataValue* value] : ( stringLiteral | TRUE_LIT | FALSE_LIT | NUMBER | IDENTIFIER | metadataKeyValueCollection | metadataList );
 */
static MetadataValue*
metadataKeyValueValue(pGeoGenScriptDecls ctx)
{
    MetadataValue* value;


    pANTLR3_BASE_TREE    TRUE_LIT12;
    pANTLR3_BASE_TREE    FALSE_LIT13;
    pANTLR3_BASE_TREE    NUMBER14;
    pANTLR3_BASE_TREE    IDENTIFIER15;
    GeoGenScriptDecls_stringLiteral_return stringLiteral11;
    #undef	RETURN_TYPE_stringLiteral11
    #define	RETURN_TYPE_stringLiteral11 GeoGenScriptDecls_stringLiteral_return

    MetadataValue* metadataKeyValueCollection16;
    #undef	RETURN_TYPE_metadataKeyValueCollection16
    #define	RETURN_TYPE_metadataKeyValueCollection16 MetadataValue*

    MetadataValue* metadataList17;
    #undef	RETURN_TYPE_metadataList17
    #define	RETURN_TYPE_metadataList17 MetadataValue*

    /* Initialize rule variables
     */

     value= NULL;
     
    TRUE_LIT12       = NULL;
    FALSE_LIT13       = NULL;
    NUMBER14       = NULL;
    IDENTIFIER15       = NULL;

    {
        {
            //  C:\\Users\\matej_000\\Source\\Repos\\geogen\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:252:77: ( stringLiteral | TRUE_LIT | FALSE_LIT | NUMBER | IDENTIFIER | metadataKeyValueCollection | metadataList )

            ANTLR3_UINT32 alt7;

            alt7=7;

            switch ( LA(1) )
            {
            case STRING:
            	{
            		alt7=1;
            	}
                break;
            case TRUE_LIT:
            	{
            		alt7=2;
            	}
                break;
            case FALSE_LIT:
            	{
            		alt7=3;
            	}
                break;
            case NUMBER:
            	{
            		alt7=4;
            	}
                break;
            case IDENTIFIER:
            	{
            		alt7=5;
            	}
                break;
            case COLLECTION:
            	{
            		alt7=6;
            	}
                break;
            case SIMPLE_COLLECTION:
            	{
            		alt7=7;
            	}
                break;

            default:
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 7;
                EXCEPTION->state        = 0;


                goto rulemetadataKeyValueValueEx;

            }

            switch (alt7)
            {
        	case 1:
        	    // C:\\Users\\matej_000\\Source\\Repos\\geogen\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:253:2: stringLiteral
        	    {
        	        FOLLOWPUSH(FOLLOW_stringLiteral_in_metadataKeyValueValue254);
        	        stringLiteral11=stringLiteral(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulemetadataKeyValueValueEx;
        	        }


        	        {
        	             value= new MetadataString(CodeLocation(
        	            stringLiteral11.line
        	            , stringLiteral11.pos
        	            ), stringLiteral11.value
        	            );
        	             
        	        }


        	    }
        	    break;
        	case 2:
        	    // C:\\Users\\matej_000\\Source\\Repos\\geogen\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:254:4: TRUE_LIT
        	    {
        	        TRUE_LIT12 = (pANTLR3_BASE_TREE) MATCHT(TRUE_LIT, &FOLLOW_TRUE_LIT_in_metadataKeyValueValue262);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulemetadataKeyValueValueEx;
        	        }


        	        {
        	             value= new MetadataBoolean(CodeLocation((TRUE_LIT12->getLine(TRUE_LIT12)), (TRUE_LIT12->getCharPositionInLine(TRUE_LIT12))), true);
        	             
        	        }


        	    }
        	    break;
        	case 3:
        	    // C:\\Users\\matej_000\\Source\\Repos\\geogen\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:255:4: FALSE_LIT
        	    {
        	        FALSE_LIT13 = (pANTLR3_BASE_TREE) MATCHT(FALSE_LIT, &FOLLOW_FALSE_LIT_in_metadataKeyValueValue270);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulemetadataKeyValueValueEx;
        	        }


        	        {
        	             value= new MetadataBoolean(CodeLocation((FALSE_LIT13->getLine(FALSE_LIT13)), (FALSE_LIT13->getCharPositionInLine(FALSE_LIT13))), false);
        	             
        	        }


        	    }
        	    break;
        	case 4:
        	    // C:\\Users\\matej_000\\Source\\Repos\\geogen\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:256:4: NUMBER
        	    {
        	        NUMBER14 = (pANTLR3_BASE_TREE) MATCHT(NUMBER, &FOLLOW_NUMBER_in_metadataKeyValueValue278);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulemetadataKeyValueValueEx;
        	        }


        	        {
        	             value= new MetadataNumber(CodeLocation((NUMBER14->getLine(NUMBER14)), (NUMBER14->getCharPositionInLine(NUMBER14))), StringToNumber((Char*)(NUMBER14->getText(NUMBER14))->chars));
        	             
        	        }


        	    }
        	    break;
        	case 5:
        	    // C:\\Users\\matej_000\\Source\\Repos\\geogen\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:257:4: IDENTIFIER
        	    {
        	        IDENTIFIER15 = (pANTLR3_BASE_TREE) MATCHT(IDENTIFIER, &FOLLOW_IDENTIFIER_in_metadataKeyValueValue285);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulemetadataKeyValueValueEx;
        	        }


        	        {
        	             value= new MetadataIdentifier(CodeLocation((IDENTIFIER15->getLine(IDENTIFIER15)), (IDENTIFIER15->getCharPositionInLine(IDENTIFIER15))), (Char*)(IDENTIFIER15->getText(IDENTIFIER15))->chars);
        	             
        	        }


        	    }
        	    break;
        	case 6:
        	    // C:\\Users\\matej_000\\Source\\Repos\\geogen\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:258:4: metadataKeyValueCollection
        	    {
        	        FOLLOWPUSH(FOLLOW_metadataKeyValueCollection_in_metadataKeyValueValue292);
        	        metadataKeyValueCollection16=metadataKeyValueCollection(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulemetadataKeyValueValueEx;
        	        }


        	        {
        	             value= 
        	            metadataKeyValueCollection16
        	            ;
        	             
        	        }


        	    }
        	    break;
        	case 7:
        	    // C:\\Users\\matej_000\\Source\\Repos\\geogen\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:259:4: metadataList
        	    {
        	        FOLLOWPUSH(FOLLOW_metadataList_in_metadataKeyValueValue299);
        	        metadataList17=metadataList(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulemetadataKeyValueValueEx;
        	        }


        	        {
        	             value= 
        	            metadataList17
        	            ;
        	             
        	        }


        	    }
        	    break;

            }
        }
    }

    // This is where rules clean up and exit
    //
    goto rulemetadataKeyValueValueEx; /* Prevent compiler warnings */
    rulemetadataKeyValueValueEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return value;
}
/* $ANTLR end metadataKeyValueValue */

/**
 * $ANTLR start declaration
 * C:\\Users\\matej_000\\Source\\Repos\\geogen\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:269:1: declaration : ( enumDeclaration | functionDeclaration );
 */
static void
declaration(pGeoGenScriptDecls ctx)
{
    /* Initialize rule variables
     */

    {
        {
            //  C:\\Users\\matej_000\\Source\\Repos\\geogen\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:269:12: ( enumDeclaration | functionDeclaration )

            ANTLR3_UINT32 alt8;

            alt8=2;

            switch ( LA(1) )
            {
            case ENUM:
            	{
            		alt8=1;
            	}
                break;
            case FUNCTION:
            	{
            		alt8=2;
            	}
                break;

            default:
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 8;
                EXCEPTION->state        = 0;


                goto ruledeclarationEx;

            }

            switch (alt8)
            {
        	case 1:
        	    // C:\\Users\\matej_000\\Source\\Repos\\geogen\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:269:14: enumDeclaration
        	    {
        	        FOLLOWPUSH(FOLLOW_enumDeclaration_in_declaration315);
        	        enumDeclaration(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruledeclarationEx;
        	        }


        	    }
        	    break;
        	case 2:
        	    // C:\\Users\\matej_000\\Source\\Repos\\geogen\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:269:32: functionDeclaration
        	    {
        	        FOLLOWPUSH(FOLLOW_functionDeclaration_in_declaration319);
        	        functionDeclaration(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruledeclarationEx;
        	        }


        	    }
        	    break;

            }
        }
    }

    // This is where rules clean up and exit
    //
    goto ruledeclarationEx; /* Prevent compiler warnings */
    ruledeclarationEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end declaration */

/**
 * $ANTLR start enumDeclaration
 * C:\\Users\\matej_000\\Source\\Repos\\geogen\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:271:1: enumDeclaration : ^( ENUM IDENTIFIER enumValues ) ;
 */
static void
enumDeclaration(pGeoGenScriptDecls ctx)
{
    pANTLR3_BASE_TREE    ENUM18;
    pANTLR3_BASE_TREE    IDENTIFIER19;
    map<String, int> enumValues20;
    #undef	RETURN_TYPE_enumValues20
    #define	RETURN_TYPE_enumValues20 map<String, int>

    /* Initialize rule variables
     */

    ENUM18       = NULL;
    IDENTIFIER19       = NULL;

    {
        // C:\\Users\\matej_000\\Source\\Repos\\geogen\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:271:16: ( ^( ENUM IDENTIFIER enumValues ) )
        // C:\\Users\\matej_000\\Source\\Repos\\geogen\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:271:18: ^( ENUM IDENTIFIER enumValues )
        {
            ENUM18 = (pANTLR3_BASE_TREE) MATCHT(ENUM, &FOLLOW_ENUM_in_enumDeclaration327);
            if  (HASEXCEPTION())
            {
                goto ruleenumDeclarationEx;
            }


            MATCHT(ANTLR3_TOKEN_DOWN, NULL);
            if  (HASEXCEPTION())
            {
                goto ruleenumDeclarationEx;
            }

            IDENTIFIER19 = (pANTLR3_BASE_TREE) MATCHT(IDENTIFIER, &FOLLOW_IDENTIFIER_in_enumDeclaration329);
            if  (HASEXCEPTION())
            {
                goto ruleenumDeclarationEx;
            }


            FOLLOWPUSH(FOLLOW_enumValues_in_enumDeclaration331);
            enumValues20=enumValues(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleenumDeclarationEx;
            }


            MATCHT(ANTLR3_TOKEN_UP, NULL);
            if  (HASEXCEPTION())
            {
                goto ruleenumDeclarationEx;
            }



            {

                	CodeLocation location((ENUM18->getLine(ENUM18)), (ENUM18->getCharPositionInLine(ENUM18)));
                		
                	EnumTypeDefinition* decl = new EnumTypeDefinition((Char*)(IDENTIFIER19->getText(IDENTIFIER19))->chars, 
                enumValues20
                );
                	
                	if (decl->GetName() == GG_STR("Type"))
                	{
                		String name = decl->GetName();
                		delete decl;
                		throw InvalidSymbolDefinitionException(GGE1311_ReservedTypeNameUsed, location, name);
                	}
                	
                	if (!ctx->compiledScript->AddTypeDefinition(decl))
                	{
                		String name = decl->GetName();
                		delete decl;
                		throw SymbolRedefinitionException(GGE1308_TypeAlreadyDefined, location, name);
                	}

            }


        }

    }

    // This is where rules clean up and exit
    //
    goto ruleenumDeclarationEx; /* Prevent compiler warnings */
    ruleenumDeclarationEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end enumDeclaration */

/**
 * $ANTLR start enumValues
 * C:\\Users\\matej_000\\Source\\Repos\\geogen\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:292:1: enumValues returns [map<String, int> returnEnumValues] : ^( VALUES ( ^( IDENTIFIER ( NUMBER )? ) )+ ) ;
 */
static map<String, int>
enumValues(pGeoGenScriptDecls ctx)
{
    map<String, int> returnEnumValues;


    pANTLR3_BASE_TREE    NUMBER21;
    pANTLR3_BASE_TREE    IDENTIFIER22;

    /* Initialize rule variables
     */

     map<String, int> tempEnumValues; double number = 0; int nextAutoNumber = 0; bool isNumberDefined = false;
    NUMBER21       = NULL;
    IDENTIFIER22       = NULL;

    {
        // C:\\Users\\matej_000\\Source\\Repos\\geogen\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:294:3: ( ^( VALUES ( ^( IDENTIFIER ( NUMBER )? ) )+ ) )
        // C:\\Users\\matej_000\\Source\\Repos\\geogen\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:294:3: ^( VALUES ( ^( IDENTIFIER ( NUMBER )? ) )+ )
        {
             MATCHT(VALUES, &FOLLOW_VALUES_in_enumValues352);
            if  (HASEXCEPTION())
            {
                goto ruleenumValuesEx;
            }


            MATCHT(ANTLR3_TOKEN_DOWN, NULL);
            if  (HASEXCEPTION())
            {
                goto ruleenumValuesEx;
            }

            // C:\\Users\\matej_000\\Source\\Repos\\geogen\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:294:12: ( ^( IDENTIFIER ( NUMBER )? ) )+
            {
                int cnt10=0;

                for (;;)
                {
                    int alt10=2;
            	switch ( LA(1) )
            	{
            	case IDENTIFIER:
            		{
            			alt10=1;
            		}
            	    break;

            	}

            	switch (alt10)
            	{
            	    case 1:
            	        // C:\\Users\\matej_000\\Source\\Repos\\geogen\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:294:13: ^( IDENTIFIER ( NUMBER )? )
            	        {
            	            IDENTIFIER22 = (pANTLR3_BASE_TREE) MATCHT(IDENTIFIER, &FOLLOW_IDENTIFIER_in_enumValues356);
            	            if  (HASEXCEPTION())
            	            {
            	                goto ruleenumValuesEx;
            	            }


            	            if ( LA(1)==ANTLR3_TOKEN_DOWN ) {
            	                MATCHT(ANTLR3_TOKEN_DOWN, NULL);
            	                if  (HASEXCEPTION())
            	                {
            	                    goto ruleenumValuesEx;
            	                }

            	                // C:\\Users\\matej_000\\Source\\Repos\\geogen\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:294:26: ( NUMBER )?
            	                {
            	                    int alt9=2;
            	                    switch ( LA(1) )
            	                    {
            	                        case NUMBER:
            	                        	{
            	                        		alt9=1;
            	                        	}
            	                            break;
            	                    }

            	                    switch (alt9)
            	                    {
            	                	case 1:
            	                	    // C:\\Users\\matej_000\\Source\\Repos\\geogen\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:294:27: NUMBER
            	                	    {
            	                	        NUMBER21 = (pANTLR3_BASE_TREE) MATCHT(NUMBER, &FOLLOW_NUMBER_in_enumValues359);
            	                	        if  (HASEXCEPTION())
            	                	        {
            	                	            goto ruleenumValuesEx;
            	                	        }


            	                	        {
            	                	             number = StringToNumber((Char*)(NUMBER21->getText(NUMBER21))->chars); isNumberDefined = true;
            	                	        }


            	                	    }
            	                	    break;

            	                    }
            	                }

            	                MATCHT(ANTLR3_TOKEN_UP, NULL);
            	                if  (HASEXCEPTION())
            	                {
            	                    goto ruleenumValuesEx;
            	                }

            	            }


            	            {
            	                 
            	                		String valueName = (Char*)(IDENTIFIER22->getText(IDENTIFIER22))->chars;
            	                	
            	                		CodeLocation enumValueLocation((IDENTIFIER22->getLine(IDENTIFIER22)), (IDENTIFIER22->getCharPositionInLine(IDENTIFIER22)));
            	                		
            	                		if(isNumberDefined && !IsNumberInt(number))
            	                		{
            	                			throw InvalidSymbolDefinitionException(GGE1310_EnumValueNotInteger, enumValueLocation, valueName);
            	                		}
            	                		
            	                		if(!isNumberDefined){
            	                			number = nextAutoNumber;
            	                		}
            	                		else {
            	                			number = NumberToInt(number);
            	                		}
            	                		
            	                		nextAutoNumber = NumberToInt(number) + 1;
            	                		
            	                		if(!returnEnumValues.insert(std::pair<String, int>(valueName, number)).second)
            	                		{		
            	                			throw SymbolRedefinitionException(GGE1309_EnumValueAlreadyDefined, enumValueLocation, valueName);
            	                		}
            	                		
            	                		isNumberDefined = false;
            	                		number = 0;
            	                	
            	            }


            	        }
            	        break;

            	    default:

            		if ( cnt10 >= 1 )
            		{
            		    goto loop10;
            		}
            		/* mismatchedSetEx()
            		 */
            		CONSTRUCTEX();
            		EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;
            		EXCEPTION->name = (void *)ANTLR3_EARLY_EXIT_NAME;


            		goto ruleenumValuesEx;
            	}
            	cnt10++;
                }
                loop10: ;	/* Jump to here if this rule does not match */
            }

            MATCHT(ANTLR3_TOKEN_UP, NULL);
            if  (HASEXCEPTION())
            {
                goto ruleenumValuesEx;
            }



        }

    }

    // This is where rules clean up and exit
    //
    goto ruleenumValuesEx; /* Prevent compiler warnings */
    ruleenumValuesEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return returnEnumValues;
}
/* $ANTLR end enumValues */

/**
 * $ANTLR start functionDeclaration
 * C:\\Users\\matej_000\\Source\\Repos\\geogen\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:325:1: functionDeclaration : ^( FUNCTION name= IDENTIFIER ^( PARAMETERS (formalParameters+= IDENTIFIER )* ) block ) ;
 */
static void
functionDeclaration(pGeoGenScriptDecls ctx)
{
    pANTLR3_BASE_TREE    name;
    pANTLR3_BASE_TREE    FUNCTION23;
    pANTLR3_BASE_TREE    formalParameters;
    pANTLR3_VECTOR    list_formalParameters;
    CodeBlock* block24;
    #undef	RETURN_TYPE_block24
    #define	RETURN_TYPE_block24 CodeBlock*

    /* Initialize rule variables
     */

     ctx->isInFunction = true; /*functionDeclaration::localVariableDefinitions = new SymbolDefinitionTable<VariableDefinition>();*/
    name       = NULL;
    FUNCTION23       = NULL;
    formalParameters       = NULL;
    list_formalParameters     = NULL;

    {
        // C:\\Users\\matej_000\\Source\\Repos\\geogen\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:330:3: ( ^( FUNCTION name= IDENTIFIER ^( PARAMETERS (formalParameters+= IDENTIFIER )* ) block ) )
        // C:\\Users\\matej_000\\Source\\Repos\\geogen\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:330:3: ^( FUNCTION name= IDENTIFIER ^( PARAMETERS (formalParameters+= IDENTIFIER )* ) block )
        {
            FUNCTION23 = (pANTLR3_BASE_TREE) MATCHT(FUNCTION, &FOLLOW_FUNCTION_in_functionDeclaration394);
            if  (HASEXCEPTION())
            {
                goto rulefunctionDeclarationEx;
            }


            MATCHT(ANTLR3_TOKEN_DOWN, NULL);
            if  (HASEXCEPTION())
            {
                goto rulefunctionDeclarationEx;
            }

            name = (pANTLR3_BASE_TREE) MATCHT(IDENTIFIER, &FOLLOW_IDENTIFIER_in_functionDeclaration398);
            if  (HASEXCEPTION())
            {
                goto rulefunctionDeclarationEx;
            }


             MATCHT(PARAMETERS, &FOLLOW_PARAMETERS_in_functionDeclaration401);
            if  (HASEXCEPTION())
            {
                goto rulefunctionDeclarationEx;
            }


            if ( LA(1)==ANTLR3_TOKEN_DOWN ) {
                MATCHT(ANTLR3_TOKEN_DOWN, NULL);
                if  (HASEXCEPTION())
                {
                    goto rulefunctionDeclarationEx;
                }

                // C:\\Users\\matej_000\\Source\\Repos\\geogen\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:330:59: (formalParameters+= IDENTIFIER )*

                for (;;)
                {
                    int alt11=2;
                    switch ( LA(1) )
                    {
                    case IDENTIFIER:
                    	{
                    		alt11=1;
                    	}
                        break;

                    }

                    switch (alt11)
                    {
                	case 1:
                	    // C:\\Users\\matej_000\\Source\\Repos\\geogen\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:330:59: formalParameters+= IDENTIFIER
                	    {
                	        formalParameters = (pANTLR3_BASE_TREE) MATCHT(IDENTIFIER, &FOLLOW_IDENTIFIER_in_functionDeclaration405);
                	        if  (HASEXCEPTION())
                	        {
                	            goto rulefunctionDeclarationEx;
                	        }

                	        if (list_formalParameters == NULL)
                	        {
                	            list_formalParameters=ctx->vectors->newVector(ctx->vectors);
                	        }
                	        list_formalParameters->add(list_formalParameters, formalParameters, NULL);

                	    }
                	    break;

                	default:
                	    goto loop11;	/* break out of the loop */
                	    break;
                    }
                }
                loop11: ; /* Jump out to here if this rule does not match */


                MATCHT(ANTLR3_TOKEN_UP, NULL);
                if  (HASEXCEPTION())
                {
                    goto rulefunctionDeclarationEx;
                }

            }


            FOLLOWPUSH(FOLLOW_block_in_functionDeclaration409);
            block24=block(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulefunctionDeclarationEx;
            }


            MATCHT(ANTLR3_TOKEN_UP, NULL);
            if  (HASEXCEPTION())
            {
                goto rulefunctionDeclarationEx;
            }



            {

                	CodeLocation location((FUNCTION23->getLine(FUNCTION23)), (FUNCTION23->getCharPositionInLine(FUNCTION23)));
                	ScriptFunctionDefinition* decl = new ScriptFunctionDefinition((Char*)(name->getText(name))->chars, location, list_formalParameters != NULL ? list_formalParameters->count : 0);

                	//SymbolDefinitionTable<VariableDefinition>& varDecls = decl->GetLocalVariableDefinitions();	
                	
                	CodeBlock& codeBlock = decl->GetRootCodeBlock();
                	if(list_formalParameters != NULL)
                	{

                	        
                	        for(int i = list_formalParameters->count - 1; i >= 0; i--)
                	        {
                			pANTLR3_BASE_TREE tree = (pANTLR3_BASE_TREE)list_formalParameters->elements[unsigned(i)].element;
                			CodeLocation parameterLocation(tree->getLine(tree), tree->getCharPositionInLine(tree));
                			//varDecls.AddItem(new ScriptVariableDefinition(String((char*)tree->getText(tree)->chars)));
                		        codeBlock.AddInstruction(new instructions::DeclareLocalValueInstruction(location, (Char*)tree->getText(tree)->chars));	
                		        codeBlock.AddInstruction(new instructions::StoreScopeValueInstruction(location, (Char*)tree->getText(tree)->chars));	
                		        codeBlock.AddInstruction(new instructions::PopInstruction(location));	
                		}
                	}
                	
                	codeBlock.MoveInstructionsFrom(*
                block24
                );
                	delete block24
                ;

                	// Add null to end of each function for case it had no return. If it has, this instruction will never be reached.
                	codeBlock.AddInstruction(new instructions::LoadNullInstruction(location));
                	
                	//SymbolDefinitionTable<VariableDefinition>* d = functionDeclaration::localVariableDefinitions;
                	//varDecls.MoveItemsFrom(*functionDeclaration::localVariableDefinitions);

                	if (!ctx->compiledScript->AddGlobalFunctionDefinition(decl)){
                		throw SymbolRedefinitionException(GGE1306_FunctionAlreadyDefined, location, decl->GetName());
                	}
                        
                        //ctx->compiledScript->GetSymbolNameTable().AddName(decl->GetName());

            }


        }

    }

    // This is where rules clean up and exit
    //
    goto rulefunctionDeclarationEx; /* Prevent compiler warnings */
    rulefunctionDeclarationEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
            else
            {
                {
                     ctx->isInFunction = false; /*functionDeclaration::localVariableDefinitions = NULL;*/ 
                }
            }


    return ;
}
/* $ANTLR end functionDeclaration */

/**
 * $ANTLR start block
 * C:\\Users\\matej_000\\Source\\Repos\\geogen\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:369:1: block returns [CodeBlock* returnCodeBlock] : ^( BLOCK ( statement )* ) ;
 */
static CodeBlock*
block(pGeoGenScriptDecls ctx)
{
    CodeBlock* returnCodeBlock;


    CodeBlock* statement25;
    #undef	RETURN_TYPE_statement25
    #define	RETURN_TYPE_statement25 CodeBlock*

    /* Initialize rule variables
     */

     auto_ptr<CodeBlock> codeBlock(new CodeBlock()); returnCodeBlock= NULL;
     
    {
        // C:\\Users\\matej_000\\Source\\Repos\\geogen\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:372:3: ( ^( BLOCK ( statement )* ) )
        // C:\\Users\\matej_000\\Source\\Repos\\geogen\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:372:3: ^( BLOCK ( statement )* )
        {
             MATCHT(BLOCK, &FOLLOW_BLOCK_in_block436);
            if  (HASEXCEPTION())
            {
                goto ruleblockEx;
            }


            if ( LA(1)==ANTLR3_TOKEN_DOWN ) {
                MATCHT(ANTLR3_TOKEN_DOWN, NULL);
                if  (HASEXCEPTION())
                {
                    goto ruleblockEx;
                }

                // C:\\Users\\matej_000\\Source\\Repos\\geogen\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:372:11: ( statement )*

                for (;;)
                {
                    int alt12=2;
                    switch ( LA(1) )
                    {
                    case BLOCK:
                    case BREAK:
                    case COLLECTION:
                    case CONTINUE:
                    case COORDINATE:
                    case FALSE_LIT:
                    case FOR:
                    case GLOBAL:
                    case IDENTIFIER:
                    case IF:
                    case LEFT_BRACKET:
                    case LEFT_SQUARE_BRACKET:
                    case NUMBER:
                    case OPERATOR_ASSIGN:
                    case OPERATOR_ASSIGN_AND:
                    case OPERATOR_ASSIGN_DIVIDE:
                    case OPERATOR_ASSIGN_LSHIFT:
                    case OPERATOR_ASSIGN_MINUS:
                    case OPERATOR_ASSIGN_MODULO:
                    case OPERATOR_ASSIGN_OR:
                    case OPERATOR_ASSIGN_PLUS:
                    case OPERATOR_ASSIGN_RSHIFT:
                    case OPERATOR_ASSIGN_TIMES:
                    case OPERATOR_BIT_AND:
                    case OPERATOR_BIT_OR:
                    case OPERATOR_BIT_XOR:
                    case OPERATOR_DECREMENT_POST:
                    case OPERATOR_DECREMENT_PRE:
                    case OPERATOR_DIVIDE:
                    case OPERATOR_DOT:
                    case OPERATOR_EQUAL_TO:
                    case OPERATOR_EXPR_IF:
                    case OPERATOR_GREATER_THAN:
                    case OPERATOR_GREATER_THAN_OR_EQUAL_TO:
                    case OPERATOR_INCREMENT_POST:
                    case OPERATOR_INCREMENT_PRE:
                    case OPERATOR_IS:
                    case OPERATOR_LESS_THAN:
                    case OPERATOR_LESS_THAN_OR_EQUAL_TO:
                    case OPERATOR_LSHIFT:
                    case OPERATOR_MINUS:
                    case OPERATOR_MINUS_UN:
                    case OPERATOR_MODULO:
                    case OPERATOR_NOT:
                    case OPERATOR_NOT_EQUAL_TO:
                    case OPERATOR_PLUS:
                    case OPERATOR_PLUS_UN:
                    case OPERATOR_RELATIVE:
                    case OPERATOR_REL_AND:
                    case OPERATOR_REL_OR:
                    case OPERATOR_RSHIFT:
                    case OPERATOR_TIMES:
                    case RETURN:
                    case STRING:
                    case SWITCH:
                    case TRUE_LIT:
                    case VAR:
                    case WHILE:
                    case YIELD:
                    	{
                    		alt12=1;
                    	}
                        break;

                    }

                    switch (alt12)
                    {
                	case 1:
                	    // C:\\Users\\matej_000\\Source\\Repos\\geogen\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:372:12: statement
                	    {
                	        FOLLOWPUSH(FOLLOW_statement_in_block439);
                	        statement25=statement(ctx);

                	        FOLLOWPOP();
                	        if  (HASEXCEPTION())
                	        {
                	            goto ruleblockEx;
                	        }


                	        {
                	             codeBlock.get()->MoveInstructionsFrom(*statement25
                	            ); delete statement25
                	            ; 
                	        }


                	    }
                	    break;

                	default:
                	    goto loop12;	/* break out of the loop */
                	    break;
                    }
                }
                loop12: ; /* Jump out to here if this rule does not match */


                MATCHT(ANTLR3_TOKEN_UP, NULL);
                if  (HASEXCEPTION())
                {
                    goto ruleblockEx;
                }

            }


        }

    }

    // This is where rules clean up and exit
    //
    goto ruleblockEx; /* Prevent compiler warnings */
    ruleblockEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
            else
            {
                {
                     returnCodeBlock= codeBlock.release();
                     
                }
            }


    return returnCodeBlock;
}
/* $ANTLR end block */

/**
 * $ANTLR start statement
 * C:\\Users\\matej_000\\Source\\Repos\\geogen\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:374:1: statement returns [CodeBlock* returnCodeBlock] : ( BREAK | CONTINUE | variableDeclaration | globalVariableDeclaration | expression | yieldStatement | returnStatement | whileStatement | forStatement | ifStatement | switchStatement | blockStatement );
 */
static CodeBlock*
statement(pGeoGenScriptDecls ctx)
{
    CodeBlock* returnCodeBlock;


    pANTLR3_BASE_TREE    BREAK26;
    pANTLR3_BASE_TREE    CONTINUE27;
    CodeBlock* variableDeclaration28;
    #undef	RETURN_TYPE_variableDeclaration28
    #define	RETURN_TYPE_variableDeclaration28 CodeBlock*

    CodeBlock* globalVariableDeclaration29;
    #undef	RETURN_TYPE_globalVariableDeclaration29
    #define	RETURN_TYPE_globalVariableDeclaration29 CodeBlock*

    GeoGenScriptDecls_expression_return expression30;
    #undef	RETURN_TYPE_expression30
    #define	RETURN_TYPE_expression30 GeoGenScriptDecls_expression_return

    CodeBlock* yieldStatement31;
    #undef	RETURN_TYPE_yieldStatement31
    #define	RETURN_TYPE_yieldStatement31 CodeBlock*

    CodeBlock* returnStatement32;
    #undef	RETURN_TYPE_returnStatement32
    #define	RETURN_TYPE_returnStatement32 CodeBlock*

    CodeBlock* whileStatement33;
    #undef	RETURN_TYPE_whileStatement33
    #define	RETURN_TYPE_whileStatement33 CodeBlock*

    CodeBlock* forStatement34;
    #undef	RETURN_TYPE_forStatement34
    #define	RETURN_TYPE_forStatement34 CodeBlock*

    CodeBlock* ifStatement35;
    #undef	RETURN_TYPE_ifStatement35
    #define	RETURN_TYPE_ifStatement35 CodeBlock*

    CodeBlock* blockStatement36;
    #undef	RETURN_TYPE_blockStatement36
    #define	RETURN_TYPE_blockStatement36 CodeBlock*

    /* Initialize rule variables
     */

     returnCodeBlock= NULL;
     
    BREAK26       = NULL;
    CONTINUE27       = NULL;

    {
        {
            //  C:\\Users\\matej_000\\Source\\Repos\\geogen\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:376:5: ( BREAK | CONTINUE | variableDeclaration | globalVariableDeclaration | expression | yieldStatement | returnStatement | whileStatement | forStatement | ifStatement | switchStatement | blockStatement )

            ANTLR3_UINT32 alt13;

            alt13=12;

            switch ( LA(1) )
            {
            case BREAK:
            	{
            		alt13=1;
            	}
                break;
            case CONTINUE:
            	{
            		alt13=2;
            	}
                break;
            case VAR:
            	{
            		alt13=3;
            	}
                break;
            case GLOBAL:
            	{
            		alt13=4;
            	}
                break;
            case COLLECTION:
            case COORDINATE:
            case FALSE_LIT:
            case IDENTIFIER:
            case LEFT_BRACKET:
            case LEFT_SQUARE_BRACKET:
            case NUMBER:
            case OPERATOR_ASSIGN:
            case OPERATOR_ASSIGN_AND:
            case OPERATOR_ASSIGN_DIVIDE:
            case OPERATOR_ASSIGN_LSHIFT:
            case OPERATOR_ASSIGN_MINUS:
            case OPERATOR_ASSIGN_MODULO:
            case OPERATOR_ASSIGN_OR:
            case OPERATOR_ASSIGN_PLUS:
            case OPERATOR_ASSIGN_RSHIFT:
            case OPERATOR_ASSIGN_TIMES:
            case OPERATOR_BIT_AND:
            case OPERATOR_BIT_OR:
            case OPERATOR_BIT_XOR:
            case OPERATOR_DECREMENT_POST:
            case OPERATOR_DECREMENT_PRE:
            case OPERATOR_DIVIDE:
            case OPERATOR_DOT:
            case OPERATOR_EQUAL_TO:
            case OPERATOR_EXPR_IF:
            case OPERATOR_GREATER_THAN:
            case OPERATOR_GREATER_THAN_OR_EQUAL_TO:
            case OPERATOR_INCREMENT_POST:
            case OPERATOR_INCREMENT_PRE:
            case OPERATOR_IS:
            case OPERATOR_LESS_THAN:
            case OPERATOR_LESS_THAN_OR_EQUAL_TO:
            case OPERATOR_LSHIFT:
            case OPERATOR_MINUS:
            case OPERATOR_MINUS_UN:
            case OPERATOR_MODULO:
            case OPERATOR_NOT:
            case OPERATOR_NOT_EQUAL_TO:
            case OPERATOR_PLUS:
            case OPERATOR_PLUS_UN:
            case OPERATOR_RELATIVE:
            case OPERATOR_REL_AND:
            case OPERATOR_REL_OR:
            case OPERATOR_RSHIFT:
            case OPERATOR_TIMES:
            case STRING:
            case TRUE_LIT:
            	{
            		alt13=5;
            	}
                break;
            case YIELD:
            	{
            		alt13=6;
            	}
                break;
            case RETURN:
            	{
            		alt13=7;
            	}
                break;
            case WHILE:
            	{
            		alt13=8;
            	}
                break;
            case FOR:
            	{
            		alt13=9;
            	}
                break;
            case IF:
            	{
            		alt13=10;
            	}
                break;
            case SWITCH:
            	{
            		alt13=11;
            	}
                break;
            case BLOCK:
            	{
            		alt13=12;
            	}
                break;

            default:
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 13;
                EXCEPTION->state        = 0;


                goto rulestatementEx;

            }

            switch (alt13)
            {
        	case 1:
        	    // C:\\Users\\matej_000\\Source\\Repos\\geogen\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:377:5: BREAK
        	    {
        	        BREAK26 = (pANTLR3_BASE_TREE) MATCHT(BREAK, &FOLLOW_BREAK_in_statement470);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulestatementEx;
        	        }


        	        {
        	             
        	            	CodeLocation location((BREAK26->getLine(BREAK26)), (BREAK26->getCharPositionInLine(BREAK26)));
        	                
        	                	if(!ctx->isInLoop)
        	                	{
        	                		throw InvalidBreakException(location);
        	                	}
        	                
        	                	int a = (SCOPE_TOP(BlockScope))->breakCodeBlockLevel;
        	                
        	                	
        	            returnCodeBlock= new CodeBlock();
        	              
        	                	returnCodeBlock
        	            ->AddInstruction(new instructions::BreakInstruction(location, ctx->codeBlockLevel - (SCOPE_TOP(BlockScope))->breakCodeBlockLevel + 1));
        	                
        	        }


        	    }
        	    break;
        	case 2:
        	    // C:\\Users\\matej_000\\Source\\Repos\\geogen\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:391:7: CONTINUE
        	    {
        	        CONTINUE27 = (pANTLR3_BASE_TREE) MATCHT(CONTINUE, &FOLLOW_CONTINUE_in_statement485);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulestatementEx;
        	        }


        	        {
        	             
        	                	CodeLocation location((CONTINUE27->getLine(CONTINUE27)), (CONTINUE27->getCharPositionInLine(CONTINUE27)));
        	                	
        	                	if(!ctx->isInLoop)
        	                	{
        	                		throw InvalidContinueException(location);
        	                	}
        	                
        	                	
        	            returnCodeBlock= new CodeBlock();
        	              
        	                	returnCodeBlock
        	            ->AddInstruction(new instructions::ContinueInstruction(location, ctx->codeBlockLevel - (SCOPE_TOP(BlockScope))->continueCodeBlockLevel + 1));
        	                
        	        }


        	    }
        	    break;
        	case 3:
        	    // C:\\Users\\matej_000\\Source\\Repos\\geogen\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:403:7: variableDeclaration
        	    {
        	        FOLLOWPUSH(FOLLOW_variableDeclaration_in_statement500);
        	        variableDeclaration28=variableDeclaration(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulestatementEx;
        	        }


        	        {
        	             returnCodeBlock= 
        	            variableDeclaration28
        	            ;
        	             
        	        }


        	    }
        	    break;
        	case 4:
        	    // C:\\Users\\matej_000\\Source\\Repos\\geogen\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:404:7: globalVariableDeclaration
        	    {
        	        FOLLOWPUSH(FOLLOW_globalVariableDeclaration_in_statement510);
        	        globalVariableDeclaration29=globalVariableDeclaration(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulestatementEx;
        	        }


        	        {
        	             returnCodeBlock= 
        	            globalVariableDeclaration29
        	            ;
        	             
        	        }


        	    }
        	    break;
        	case 5:
        	    // C:\\Users\\matej_000\\Source\\Repos\\geogen\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:405:7: expression
        	    {
        	        FOLLOWPUSH(FOLLOW_expression_in_statement520);
        	        expression30=expression(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulestatementEx;
        	        }


        	        {
        	             
        	                	returnCodeBlock= new CodeBlock();
        	             
        	                	returnCodeBlock
        	            ->MoveInstructionsFrom(*expression30.returnCodeBlock
        	            ); delete expression30.returnCodeBlock
        	            ; 
        	                	
        	                	returnCodeBlock
        	            ->AddInstruction(new instructions::PopInstruction((*(returnCodeBlock
        	            ->End() - 1))->GetLocation()));
        	                
        	        }


        	    }
        	    break;
        	case 6:
        	    // C:\\Users\\matej_000\\Source\\Repos\\geogen\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:412:7: yieldStatement
        	    {
        	        FOLLOWPUSH(FOLLOW_yieldStatement_in_statement535);
        	        yieldStatement31=yieldStatement(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulestatementEx;
        	        }


        	        {
        	             returnCodeBlock= 
        	            yieldStatement31
        	            ;
        	             
        	        }


        	    }
        	    break;
        	case 7:
        	    // C:\\Users\\matej_000\\Source\\Repos\\geogen\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:413:7: returnStatement
        	    {
        	        FOLLOWPUSH(FOLLOW_returnStatement_in_statement544);
        	        returnStatement32=returnStatement(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulestatementEx;
        	        }


        	        {
        	             returnCodeBlock= 
        	            returnStatement32
        	            ;
        	             
        	        }


        	    }
        	    break;
        	case 8:
        	    // C:\\Users\\matej_000\\Source\\Repos\\geogen\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:414:7: whileStatement
        	    {
        	        FOLLOWPUSH(FOLLOW_whileStatement_in_statement554);
        	        whileStatement33=whileStatement(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulestatementEx;
        	        }


        	        {
        	             returnCodeBlock= 
        	            whileStatement33
        	            ;
        	             
        	        }


        	    }
        	    break;
        	case 9:
        	    // C:\\Users\\matej_000\\Source\\Repos\\geogen\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:415:7: forStatement
        	    {
        	        FOLLOWPUSH(FOLLOW_forStatement_in_statement564);
        	        forStatement34=forStatement(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulestatementEx;
        	        }


        	        {
        	             returnCodeBlock= 
        	            forStatement34
        	            ;
        	             
        	        }


        	    }
        	    break;
        	case 10:
        	    // C:\\Users\\matej_000\\Source\\Repos\\geogen\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:416:7: ifStatement
        	    {
        	        FOLLOWPUSH(FOLLOW_ifStatement_in_statement574);
        	        ifStatement35=ifStatement(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulestatementEx;
        	        }


        	        {
        	             returnCodeBlock= 
        	            ifStatement35
        	            ;

        	        }


        	    }
        	    break;
        	case 11:
        	    // C:\\Users\\matej_000\\Source\\Repos\\geogen\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:417:7: switchStatement
        	    {
        	        FOLLOWPUSH(FOLLOW_switchStatement_in_statement584);
        	        switchStatement(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulestatementEx;
        	        }


        	        {
        	             returnCodeBlock= new CodeBlock();
        	             
        	        }


        	    }
        	    break;
        	case 12:
        	    // C:\\Users\\matej_000\\Source\\Repos\\geogen\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:418:7: blockStatement
        	    {
        	        FOLLOWPUSH(FOLLOW_blockStatement_in_statement594);
        	        blockStatement36=blockStatement(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulestatementEx;
        	        }


        	        {
        	             returnCodeBlock= 
        	            blockStatement36
        	            ;
        	             
        	        }


        	    }
        	    break;

            }
        }
    }

    // This is where rules clean up and exit
    //
    goto rulestatementEx; /* Prevent compiler warnings */
    rulestatementEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return returnCodeBlock;
}
/* $ANTLR end statement */

/**
 * $ANTLR start blockStatement
 * C:\\Users\\matej_000\\Source\\Repos\\geogen\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:420:1: blockStatement returns [CodeBlock* returnCodeBlock] : block ;
 */
static CodeBlock*
blockStatement(pGeoGenScriptDecls ctx)
{
    CodeBlock* returnCodeBlock;


    CodeBlock* block37;
    #undef	RETURN_TYPE_block37
    #define	RETURN_TYPE_block37 CodeBlock*

    /* Initialize rule variables
     */

     
    	returnCodeBlock= new CodeBlock();
     
    	ctx->codeBlockLevel++; 

    {
        // C:\\Users\\matej_000\\Source\\Repos\\geogen\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:426:34: ( block )
        // C:\\Users\\matej_000\\Source\\Repos\\geogen\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:427:1: block
        {
            FOLLOWPUSH(FOLLOW_block_in_blockStatement623);
            block37=block(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleblockStatementEx;
            }


            {

                	if(block37
                ->Begin() != block37
                ->End())
                	{	
                		instructions::CallBlockInstruction* instr = new instructions::CallBlockInstruction((*block37
                ->Begin())->GetLocation());
                	
                		instr->GetCodeBlock().MoveInstructionsFrom(*block37
                );
                		delete block37
                ;
                		
                		returnCodeBlock
                ->AddInstruction(instr);	
                	}
                	else {
                		delete block37
                ;	
                	}


            }


        }

    }

    // This is where rules clean up and exit
    //
    goto ruleblockStatementEx; /* Prevent compiler warnings */
    ruleblockStatementEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
            else
            {
                {
                     ctx->codeBlockLevel--; 
                }
            }


    return returnCodeBlock;
}
/* $ANTLR end blockStatement */

/**
 * $ANTLR start variableDeclaration
 * C:\\Users\\matej_000\\Source\\Repos\\geogen\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:444:1: variableDeclaration returns [CodeBlock* returnCodeBlock] : ^( VAR IDENTIFIER ( expression )? ) ;
 */
static CodeBlock*
variableDeclaration(pGeoGenScriptDecls ctx)
{
    CodeBlock* returnCodeBlock;


    pANTLR3_BASE_TREE    VAR38;
    pANTLR3_BASE_TREE    IDENTIFIER40;
    GeoGenScriptDecls_expression_return expression39;
    #undef	RETURN_TYPE_expression39
    #define	RETURN_TYPE_expression39 GeoGenScriptDecls_expression_return

    /* Initialize rule variables
     */

     returnCodeBlock= new CodeBlock();
     bool hadValue = false; 
    VAR38       = NULL;
    IDENTIFIER40       = NULL;

    {
        // C:\\Users\\matej_000\\Source\\Repos\\geogen\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:446:3: ( ^( VAR IDENTIFIER ( expression )? ) )
        // C:\\Users\\matej_000\\Source\\Repos\\geogen\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:446:3: ^( VAR IDENTIFIER ( expression )? )
        {
            VAR38 = (pANTLR3_BASE_TREE) MATCHT(VAR, &FOLLOW_VAR_in_variableDeclaration648);
            if  (HASEXCEPTION())
            {
                goto rulevariableDeclarationEx;
            }


            MATCHT(ANTLR3_TOKEN_DOWN, NULL);
            if  (HASEXCEPTION())
            {
                goto rulevariableDeclarationEx;
            }

            IDENTIFIER40 = (pANTLR3_BASE_TREE) MATCHT(IDENTIFIER, &FOLLOW_IDENTIFIER_in_variableDeclaration650);
            if  (HASEXCEPTION())
            {
                goto rulevariableDeclarationEx;
            }


            // C:\\Users\\matej_000\\Source\\Repos\\geogen\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:446:20: ( expression )?
            {
                int alt14=2;
                switch ( LA(1) )
                {
                    case COLLECTION:
                    case COORDINATE:
                    case FALSE_LIT:
                    case IDENTIFIER:
                    case LEFT_BRACKET:
                    case LEFT_SQUARE_BRACKET:
                    case NUMBER:
                    case OPERATOR_ASSIGN:
                    case OPERATOR_ASSIGN_AND:
                    case OPERATOR_ASSIGN_DIVIDE:
                    case OPERATOR_ASSIGN_LSHIFT:
                    case OPERATOR_ASSIGN_MINUS:
                    case OPERATOR_ASSIGN_MODULO:
                    case OPERATOR_ASSIGN_OR:
                    case OPERATOR_ASSIGN_PLUS:
                    case OPERATOR_ASSIGN_RSHIFT:
                    case OPERATOR_ASSIGN_TIMES:
                    case OPERATOR_BIT_AND:
                    case OPERATOR_BIT_OR:
                    case OPERATOR_BIT_XOR:
                    case OPERATOR_DECREMENT_POST:
                    case OPERATOR_DECREMENT_PRE:
                    case OPERATOR_DIVIDE:
                    case OPERATOR_DOT:
                    case OPERATOR_EQUAL_TO:
                    case OPERATOR_EXPR_IF:
                    case OPERATOR_GREATER_THAN:
                    case OPERATOR_GREATER_THAN_OR_EQUAL_TO:
                    case OPERATOR_INCREMENT_POST:
                    case OPERATOR_INCREMENT_PRE:
                    case OPERATOR_IS:
                    case OPERATOR_LESS_THAN:
                    case OPERATOR_LESS_THAN_OR_EQUAL_TO:
                    case OPERATOR_LSHIFT:
                    case OPERATOR_MINUS:
                    case OPERATOR_MINUS_UN:
                    case OPERATOR_MODULO:
                    case OPERATOR_NOT:
                    case OPERATOR_NOT_EQUAL_TO:
                    case OPERATOR_PLUS:
                    case OPERATOR_PLUS_UN:
                    case OPERATOR_RELATIVE:
                    case OPERATOR_REL_AND:
                    case OPERATOR_REL_OR:
                    case OPERATOR_RSHIFT:
                    case OPERATOR_TIMES:
                    case STRING:
                    case TRUE_LIT:
                    	{
                    		alt14=1;
                    	}
                        break;
                }

                switch (alt14)
                {
            	case 1:
            	    // C:\\Users\\matej_000\\Source\\Repos\\geogen\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:446:21: expression
            	    {
            	        FOLLOWPUSH(FOLLOW_expression_in_variableDeclaration653);
            	        expression39=expression(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulevariableDeclarationEx;
            	        }


            	        {

            	            		hadValue = true;
            	            	
            	                		CodeLocation location((VAR38->getLine(VAR38)), (VAR38->getCharPositionInLine(VAR38)));
            	                		
            	            		
            	            returnCodeBlock
            	            ->MoveInstructionsFrom(*expression39.returnCodeBlock
            	            ); 
            	            		delete expression39.returnCodeBlock
            	            ; 
            	            		
            	            		/*returnCodeBlock
            	            ->AddInstruction(new instructions::CallGlobalInstruction(location, "=", 1));*/
            	            		returnCodeBlock
            	            ->AddInstruction(new instructions::DeclareLocalValueInstruction(location, (Char*)(IDENTIFIER40->getText(IDENTIFIER40))->chars));
            	            		
            	            returnCodeBlock
            	            ->AddInstruction(new instructions::StoreScopeValueInstruction(location, (Char*)(IDENTIFIER40->getText(IDENTIFIER40))->chars));
            	            		
            	            returnCodeBlock
            	            ->AddInstruction(new instructions::PopInstruction(location));
            	            	
            	        }


            	    }
            	    break;

                }
            }

            MATCHT(ANTLR3_TOKEN_UP, NULL);
            if  (HASEXCEPTION())
            {
                goto rulevariableDeclarationEx;
            }



            {

                    	CodeLocation location((VAR38->getLine(VAR38)), (VAR38->getCharPositionInLine(VAR38)));
                	if(!hadValue){
                		
                returnCodeBlock
                ->AddInstruction(new instructions::DeclareLocalValueInstruction(location, (Char*)(IDENTIFIER40->getText(IDENTIFIER40))->chars));
                	}

            }


        }

    }

    // This is where rules clean up and exit
    //
    goto rulevariableDeclarationEx; /* Prevent compiler warnings */
    rulevariableDeclarationEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return returnCodeBlock;
}
/* $ANTLR end variableDeclaration */

/**
 * $ANTLR start globalVariableDeclaration
 * C:\\Users\\matej_000\\Source\\Repos\\geogen\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:467:1: globalVariableDeclaration returns [CodeBlock* returnCodeBlock] : ^( GLOBAL IDENTIFIER ( expression )? ) ;
 */
static CodeBlock*
globalVariableDeclaration(pGeoGenScriptDecls ctx)
{
    CodeBlock* returnCodeBlock;


    pANTLR3_BASE_TREE    GLOBAL41;
    pANTLR3_BASE_TREE    IDENTIFIER43;
    GeoGenScriptDecls_expression_return expression42;
    #undef	RETURN_TYPE_expression42
    #define	RETURN_TYPE_expression42 GeoGenScriptDecls_expression_return

    /* Initialize rule variables
     */

     returnCodeBlock= new CodeBlock();
     bool hadValue = false; 
    GLOBAL41       = NULL;
    IDENTIFIER43       = NULL;

    {
        // C:\\Users\\matej_000\\Source\\Repos\\geogen\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:469:3: ( ^( GLOBAL IDENTIFIER ( expression )? ) )
        // C:\\Users\\matej_000\\Source\\Repos\\geogen\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:469:3: ^( GLOBAL IDENTIFIER ( expression )? )
        {
            GLOBAL41 = (pANTLR3_BASE_TREE) MATCHT(GLOBAL, &FOLLOW_GLOBAL_in_globalVariableDeclaration681);
            if  (HASEXCEPTION())
            {
                goto ruleglobalVariableDeclarationEx;
            }


            MATCHT(ANTLR3_TOKEN_DOWN, NULL);
            if  (HASEXCEPTION())
            {
                goto ruleglobalVariableDeclarationEx;
            }

            IDENTIFIER43 = (pANTLR3_BASE_TREE) MATCHT(IDENTIFIER, &FOLLOW_IDENTIFIER_in_globalVariableDeclaration683);
            if  (HASEXCEPTION())
            {
                goto ruleglobalVariableDeclarationEx;
            }


            // C:\\Users\\matej_000\\Source\\Repos\\geogen\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:469:23: ( expression )?
            {
                int alt15=2;
                switch ( LA(1) )
                {
                    case COLLECTION:
                    case COORDINATE:
                    case FALSE_LIT:
                    case IDENTIFIER:
                    case LEFT_BRACKET:
                    case LEFT_SQUARE_BRACKET:
                    case NUMBER:
                    case OPERATOR_ASSIGN:
                    case OPERATOR_ASSIGN_AND:
                    case OPERATOR_ASSIGN_DIVIDE:
                    case OPERATOR_ASSIGN_LSHIFT:
                    case OPERATOR_ASSIGN_MINUS:
                    case OPERATOR_ASSIGN_MODULO:
                    case OPERATOR_ASSIGN_OR:
                    case OPERATOR_ASSIGN_PLUS:
                    case OPERATOR_ASSIGN_RSHIFT:
                    case OPERATOR_ASSIGN_TIMES:
                    case OPERATOR_BIT_AND:
                    case OPERATOR_BIT_OR:
                    case OPERATOR_BIT_XOR:
                    case OPERATOR_DECREMENT_POST:
                    case OPERATOR_DECREMENT_PRE:
                    case OPERATOR_DIVIDE:
                    case OPERATOR_DOT:
                    case OPERATOR_EQUAL_TO:
                    case OPERATOR_EXPR_IF:
                    case OPERATOR_GREATER_THAN:
                    case OPERATOR_GREATER_THAN_OR_EQUAL_TO:
                    case OPERATOR_INCREMENT_POST:
                    case OPERATOR_INCREMENT_PRE:
                    case OPERATOR_IS:
                    case OPERATOR_LESS_THAN:
                    case OPERATOR_LESS_THAN_OR_EQUAL_TO:
                    case OPERATOR_LSHIFT:
                    case OPERATOR_MINUS:
                    case OPERATOR_MINUS_UN:
                    case OPERATOR_MODULO:
                    case OPERATOR_NOT:
                    case OPERATOR_NOT_EQUAL_TO:
                    case OPERATOR_PLUS:
                    case OPERATOR_PLUS_UN:
                    case OPERATOR_RELATIVE:
                    case OPERATOR_REL_AND:
                    case OPERATOR_REL_OR:
                    case OPERATOR_RSHIFT:
                    case OPERATOR_TIMES:
                    case STRING:
                    case TRUE_LIT:
                    	{
                    		alt15=1;
                    	}
                        break;
                }

                switch (alt15)
                {
            	case 1:
            	    // C:\\Users\\matej_000\\Source\\Repos\\geogen\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:469:24: expression
            	    {
            	        FOLLOWPUSH(FOLLOW_expression_in_globalVariableDeclaration686);
            	        expression42=expression(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleglobalVariableDeclarationEx;
            	        }


            	        {

            	            		hadValue = true;
            	            	
            	                		CodeLocation location((GLOBAL41->getLine(GLOBAL41)), (GLOBAL41->getCharPositionInLine(GLOBAL41)));
            	                		
            	            		
            	            returnCodeBlock
            	            ->MoveInstructionsFrom(*expression42.returnCodeBlock
            	            ); 
            	            		delete expression42.returnCodeBlock
            	            ; 
            	            		
            	            		/*returnCodeBlock
            	            ->AddInstruction(new instructions::CallGlobalInstruction(location, "=", 1));*/
            	            		returnCodeBlock
            	            ->AddInstruction(new instructions::DeclareGlobalValueInstruction(location, (Char*)(IDENTIFIER43->getText(IDENTIFIER43))->chars));
            	            		
            	            returnCodeBlock
            	            ->AddInstruction(new instructions::StoreGlobalValueInstruction(location, (Char*)(IDENTIFIER43->getText(IDENTIFIER43))->chars));
            	            		
            	            returnCodeBlock
            	            ->AddInstruction(new instructions::PopInstruction(location));
            	            	
            	        }


            	    }
            	    break;

                }
            }

            MATCHT(ANTLR3_TOKEN_UP, NULL);
            if  (HASEXCEPTION())
            {
                goto ruleglobalVariableDeclarationEx;
            }



            {

                    	CodeLocation location((GLOBAL41->getLine(GLOBAL41)), (GLOBAL41->getCharPositionInLine(GLOBAL41)));
                	if(!hadValue){
                		
                returnCodeBlock
                ->AddInstruction(new instructions::DeclareGlobalValueInstruction(location, (Char*)(IDENTIFIER43->getText(IDENTIFIER43))->chars));
                	}

            }


        }

    }

    // This is where rules clean up and exit
    //
    goto ruleglobalVariableDeclarationEx; /* Prevent compiler warnings */
    ruleglobalVariableDeclarationEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return returnCodeBlock;
}
/* $ANTLR end globalVariableDeclaration */

/**
 * $ANTLR start yieldStatement
 * C:\\Users\\matej_000\\Source\\Repos\\geogen\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:490:1: yieldStatement returns [CodeBlock* returnCodeBlock] : ^( YIELD expression ( STRING )? ) ;
 */
static CodeBlock*
yieldStatement(pGeoGenScriptDecls ctx)
{
    CodeBlock* returnCodeBlock;


    pANTLR3_BASE_TREE    YIELD44;
    pANTLR3_BASE_TREE    STRING46;
    GeoGenScriptDecls_expression_return expression45;
    #undef	RETURN_TYPE_expression45
    #define	RETURN_TYPE_expression45 GeoGenScriptDecls_expression_return

    /* Initialize rule variables
     */

     returnCodeBlock= new CodeBlock();
     
    YIELD44       = NULL;
    STRING46       = NULL;

    {
        // C:\\Users\\matej_000\\Source\\Repos\\geogen\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:492:3: ( ^( YIELD expression ( STRING )? ) )
        // C:\\Users\\matej_000\\Source\\Repos\\geogen\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:492:3: ^( YIELD expression ( STRING )? )
        {
            YIELD44 = (pANTLR3_BASE_TREE) MATCHT(YIELD, &FOLLOW_YIELD_in_yieldStatement714);
            if  (HASEXCEPTION())
            {
                goto ruleyieldStatementEx;
            }


            MATCHT(ANTLR3_TOKEN_DOWN, NULL);
            if  (HASEXCEPTION())
            {
                goto ruleyieldStatementEx;
            }

            FOLLOWPUSH(FOLLOW_expression_in_yieldStatement716);
            expression45=expression(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleyieldStatementEx;
            }


            // C:\\Users\\matej_000\\Source\\Repos\\geogen\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:492:22: ( STRING )?
            {
                int alt16=2;
                switch ( LA(1) )
                {
                    case STRING:
                    	{
                    		alt16=1;
                    	}
                        break;
                }

                switch (alt16)
                {
            	case 1:
            	    // C:\\Users\\matej_000\\Source\\Repos\\geogen\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:492:22: STRING
            	    {
            	        STRING46 = (pANTLR3_BASE_TREE) MATCHT(STRING, &FOLLOW_STRING_in_yieldStatement718);
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleyieldStatementEx;
            	        }


            	    }
            	    break;

                }
            }

            MATCHT(ANTLR3_TOKEN_UP, NULL);
            if  (HASEXCEPTION())
            {
                goto ruleyieldStatementEx;
            }



            {
                 
                	CodeLocation location((YIELD44->getLine(YIELD44)), (YIELD44->getCharPositionInLine(YIELD44)));
                	
                	
                returnCodeBlock
                ->MoveInstructionsFrom(*expression45.returnCodeBlock
                ); 
                	delete expression45.returnCodeBlock
                ; 
                	
                	
                	String mapName = STRING46 == NULL ? renderer::Renderer::MAP_NAME_MAIN : (Char*)(STRING46->getText(STRING46))->chars;
                	
                	
                returnCodeBlock
                ->AddInstruction(new instructions::YieldAsNamedInstruction(location, mapName));
                	
                	vector<String>& supportedMaps = ctx->compiledScript->GetSupportedMaps();
                	if (find(supportedMaps.begin(), supportedMaps.end(), mapName) == ctx->compiledScript->GetSupportedMaps().end()) ctx->compiledScript->GetSupportedMaps().push_back(mapName);

            }


        }

    }

    // This is where rules clean up and exit
    //
    goto ruleyieldStatementEx; /* Prevent compiler warnings */
    ruleyieldStatementEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return returnCodeBlock;
}
/* $ANTLR end yieldStatement */

/**
 * $ANTLR start returnStatement
 * C:\\Users\\matej_000\\Source\\Repos\\geogen\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:508:1: returnStatement returns [CodeBlock* returnCodeBlock] : ^( RETURN ( expression )? ) ;
 */
static CodeBlock*
returnStatement(pGeoGenScriptDecls ctx)
{
    CodeBlock* returnCodeBlock;


    pANTLR3_BASE_TREE    RETURN48;
    GeoGenScriptDecls_expression_return expression47;
    #undef	RETURN_TYPE_expression47
    #define	RETURN_TYPE_expression47 GeoGenScriptDecls_expression_return

    /* Initialize rule variables
     */

     returnCodeBlock= NULL;
     
    RETURN48       = NULL;

    {
        // C:\\Users\\matej_000\\Source\\Repos\\geogen\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:510:3: ( ^( RETURN ( expression )? ) )
        // C:\\Users\\matej_000\\Source\\Repos\\geogen\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:510:3: ^( RETURN ( expression )? )
        {
            RETURN48 = (pANTLR3_BASE_TREE) MATCHT(RETURN, &FOLLOW_RETURN_in_returnStatement742);
            if  (HASEXCEPTION())
            {
                goto rulereturnStatementEx;
            }


            if ( LA(1)==ANTLR3_TOKEN_DOWN ) {
                MATCHT(ANTLR3_TOKEN_DOWN, NULL);
                if  (HASEXCEPTION())
                {
                    goto rulereturnStatementEx;
                }

                // C:\\Users\\matej_000\\Source\\Repos\\geogen\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:510:12: ( expression )?
                {
                    int alt17=2;
                    switch ( LA(1) )
                    {
                        case COLLECTION:
                        case COORDINATE:
                        case FALSE_LIT:
                        case IDENTIFIER:
                        case LEFT_BRACKET:
                        case LEFT_SQUARE_BRACKET:
                        case NUMBER:
                        case OPERATOR_ASSIGN:
                        case OPERATOR_ASSIGN_AND:
                        case OPERATOR_ASSIGN_DIVIDE:
                        case OPERATOR_ASSIGN_LSHIFT:
                        case OPERATOR_ASSIGN_MINUS:
                        case OPERATOR_ASSIGN_MODULO:
                        case OPERATOR_ASSIGN_OR:
                        case OPERATOR_ASSIGN_PLUS:
                        case OPERATOR_ASSIGN_RSHIFT:
                        case OPERATOR_ASSIGN_TIMES:
                        case OPERATOR_BIT_AND:
                        case OPERATOR_BIT_OR:
                        case OPERATOR_BIT_XOR:
                        case OPERATOR_DECREMENT_POST:
                        case OPERATOR_DECREMENT_PRE:
                        case OPERATOR_DIVIDE:
                        case OPERATOR_DOT:
                        case OPERATOR_EQUAL_TO:
                        case OPERATOR_EXPR_IF:
                        case OPERATOR_GREATER_THAN:
                        case OPERATOR_GREATER_THAN_OR_EQUAL_TO:
                        case OPERATOR_INCREMENT_POST:
                        case OPERATOR_INCREMENT_PRE:
                        case OPERATOR_IS:
                        case OPERATOR_LESS_THAN:
                        case OPERATOR_LESS_THAN_OR_EQUAL_TO:
                        case OPERATOR_LSHIFT:
                        case OPERATOR_MINUS:
                        case OPERATOR_MINUS_UN:
                        case OPERATOR_MODULO:
                        case OPERATOR_NOT:
                        case OPERATOR_NOT_EQUAL_TO:
                        case OPERATOR_PLUS:
                        case OPERATOR_PLUS_UN:
                        case OPERATOR_RELATIVE:
                        case OPERATOR_REL_AND:
                        case OPERATOR_REL_OR:
                        case OPERATOR_RSHIFT:
                        case OPERATOR_TIMES:
                        case STRING:
                        case TRUE_LIT:
                        	{
                        		alt17=1;
                        	}
                            break;
                    }

                    switch (alt17)
                    {
                	case 1:
                	    // C:\\Users\\matej_000\\Source\\Repos\\geogen\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:510:13: expression
                	    {
                	        FOLLOWPUSH(FOLLOW_expression_in_returnStatement745);
                	        expression47=expression(ctx);

                	        FOLLOWPOP();
                	        if  (HASEXCEPTION())
                	        {
                	            goto rulereturnStatementEx;
                	        }


                	        {
                	             returnCodeBlock= new CodeBlock();
                	             returnCodeBlock
                	            ->MoveInstructionsFrom(*expression47.returnCodeBlock
                	            ); delete expression47.returnCodeBlock
                	            ; 
                	        }


                	    }
                	    break;

                    }
                }

                MATCHT(ANTLR3_TOKEN_UP, NULL);
                if  (HASEXCEPTION())
                {
                    goto rulereturnStatementEx;
                }

            }


            {

                	CodeLocation location((RETURN48->getLine(RETURN48)), (RETURN48->getCharPositionInLine(RETURN48)));
                	
                	if(
                returnCodeBlock
                 == NULL)
                	{
                		returnCodeBlock= new CodeBlock();
                	
                		returnCodeBlock
                ->AddInstruction(new instructions::LoadNullInstruction(location));
                	}

                	if(!ctx->isInFunction)
                	{		
                		throw InvalidReturnException(location);
                	}

                	returnCodeBlock
                ->AddInstruction(new instructions::BreakInstruction(location, ctx->codeBlockLevel + 1));

            }


        }

    }

    // This is where rules clean up and exit
    //
    goto rulereturnStatementEx; /* Prevent compiler warnings */
    rulereturnStatementEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return returnCodeBlock;
}
/* $ANTLR end returnStatement */

/**
 * $ANTLR start whileStatement
 * C:\\Users\\matej_000\\Source\\Repos\\geogen\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:528:1: whileStatement returns [CodeBlock* returnCodeBlock] : ^( WHILE expression statement ) ;
 */
static CodeBlock*
whileStatement(pGeoGenScriptDecls ctx)
{
    CodeBlock* returnCodeBlock;


    pANTLR3_BASE_TREE    WHILE49;
    GeoGenScriptDecls_expression_return expression50;
    #undef	RETURN_TYPE_expression50
    #define	RETURN_TYPE_expression50 GeoGenScriptDecls_expression_return

    CodeBlock* statement51;
    #undef	RETURN_TYPE_statement51
    #define	RETURN_TYPE_statement51 CodeBlock*

    /* Initialize rule variables
     */
    ctx->pGeoGenScriptDecls_BlockScopeTop = pGeoGenScriptDecls_BlockScopePush(ctx);

     
    	returnCodeBlock= new CodeBlock();
     
    	ctx->codeBlockLevel++; 
    	(SCOPE_TOP(BlockScope))->breakCodeBlockLevel= ctx->codeBlockLevel; 
    	(SCOPE_TOP(BlockScope))->continueCodeBlockLevel= ctx->codeBlockLevel; 
    	ctx->isInLoop = true; 

    WHILE49       = NULL;

    {
        // C:\\Users\\matej_000\\Source\\Repos\\geogen\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:538:3: ( ^( WHILE expression statement ) )
        // C:\\Users\\matej_000\\Source\\Repos\\geogen\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:538:3: ^( WHILE expression statement )
        {
            WHILE49 = (pANTLR3_BASE_TREE) MATCHT(WHILE, &FOLLOW_WHILE_in_whileStatement781);
            if  (HASEXCEPTION())
            {
                goto rulewhileStatementEx;
            }


            MATCHT(ANTLR3_TOKEN_DOWN, NULL);
            if  (HASEXCEPTION())
            {
                goto rulewhileStatementEx;
            }

            FOLLOWPUSH(FOLLOW_expression_in_whileStatement783);
            expression50=expression(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulewhileStatementEx;
            }


            FOLLOWPUSH(FOLLOW_statement_in_whileStatement785);
            statement51=statement(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulewhileStatementEx;
            }


            MATCHT(ANTLR3_TOKEN_UP, NULL);
            if  (HASEXCEPTION())
            {
                goto rulewhileStatementEx;
            }



            {

                	CodeLocation location((WHILE49->getLine(WHILE49)), (WHILE49->getCharPositionInLine(WHILE49)));

                	instructions::WhileInstruction* whileInstr = new instructions::WhileInstruction(location);
                	CodeBlock& whileCodeBlock = whileInstr->GetCodeBlock();
                	
                	whileCodeBlock.MoveInstructionsFrom(*
                expression50.returnCodeBlock
                );
                	delete expression50.returnCodeBlock
                ;
                	
                	instructions::IfInstruction* ifInstr = new instructions::IfInstruction(location);
                	ifInstr->GetElseBranchCodeBlock().AddInstruction(new instructions::BreakInstruction(location, 2));
                	whileCodeBlock.AddInstruction(ifInstr);
                	
                	whileCodeBlock.MoveInstructionsFrom(*statement51
                );
                	delete statement51
                ;
                	
                	returnCodeBlock
                ->AddInstruction(whileInstr);

            }


        }

    }

    // This is where rules clean up and exit
    //
    goto rulewhileStatementEx; /* Prevent compiler warnings */
    rulewhileStatementEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
            else
            {
                {
                     ctx->codeBlockLevel--; ctx->isInLoop = false;
                }
            }


    pGeoGenScriptDecls_BlockScopePop(ctx);

    return returnCodeBlock;
}
/* $ANTLR end whileStatement */

/**
 * $ANTLR start forStatement
 * C:\\Users\\matej_000\\Source\\Repos\\geogen\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:558:1: forStatement returns [CodeBlock* returnCodeBlock] : ^( FOR ( ^( INITIALIZATION_EXPRESSION initExpression ) )? ( ^( CONDITION_EXPRESSION conditionExpression= expression ) )? ( ^( INCREMENT_EXPRESSION incrementExpression= expression ) )? statement ) ;
 */
static CodeBlock*
forStatement(pGeoGenScriptDecls ctx)
{
    CodeBlock* returnCodeBlock;


    pANTLR3_BASE_TREE    FOR53;
    GeoGenScriptDecls_expression_return conditionExpression;
    #undef	RETURN_TYPE_conditionExpression
    #define	RETURN_TYPE_conditionExpression GeoGenScriptDecls_expression_return

    GeoGenScriptDecls_expression_return incrementExpression;
    #undef	RETURN_TYPE_incrementExpression
    #define	RETURN_TYPE_incrementExpression GeoGenScriptDecls_expression_return

    CodeBlock* initExpression52;
    #undef	RETURN_TYPE_initExpression52
    #define	RETURN_TYPE_initExpression52 CodeBlock*

    CodeBlock* statement54;
    #undef	RETURN_TYPE_statement54
    #define	RETURN_TYPE_statement54 CodeBlock*

    /* Initialize rule variables
     */
    ctx->pGeoGenScriptDecls_BlockScopeTop = pGeoGenScriptDecls_BlockScopePush(ctx);

     
    	returnCodeBlock= new CodeBlock();
     
    	CodeBlock* initExpressionCodeBlock = NULL; 
    	CodeBlock* conditionExpressionCodeBlock = NULL; 
    	CodeBlock* incrementExpressionCodeBlock = NULL; 
    	ctx->codeBlockLevel++; 
    	ctx->isInLoop = true;
    	(SCOPE_TOP(BlockScope))->breakCodeBlockLevel= ctx->codeBlockLevel; 
    	(SCOPE_TOP(BlockScope))->continueCodeBlockLevel= ctx->codeBlockLevel; 

    FOR53       = NULL;

    {
        // C:\\Users\\matej_000\\Source\\Repos\\geogen\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:572:3: ( ^( FOR ( ^( INITIALIZATION_EXPRESSION initExpression ) )? ( ^( CONDITION_EXPRESSION conditionExpression= expression ) )? ( ^( INCREMENT_EXPRESSION incrementExpression= expression ) )? statement ) )
        // C:\\Users\\matej_000\\Source\\Repos\\geogen\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:572:3: ^( FOR ( ^( INITIALIZATION_EXPRESSION initExpression ) )? ( ^( CONDITION_EXPRESSION conditionExpression= expression ) )? ( ^( INCREMENT_EXPRESSION incrementExpression= expression ) )? statement )
        {
            FOR53 = (pANTLR3_BASE_TREE) MATCHT(FOR, &FOLLOW_FOR_in_forStatement818);
            if  (HASEXCEPTION())
            {
                goto ruleforStatementEx;
            }


            MATCHT(ANTLR3_TOKEN_DOWN, NULL);
            if  (HASEXCEPTION())
            {
                goto ruleforStatementEx;
            }

            // C:\\Users\\matej_000\\Source\\Repos\\geogen\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:573:2: ( ^( INITIALIZATION_EXPRESSION initExpression ) )?
            {
                int alt18=2;
                switch ( LA(1) )
                {
                    case INITIALIZATION_EXPRESSION:
                    	{
                    		alt18=1;
                    	}
                        break;
                }

                switch (alt18)
                {
            	case 1:
            	    // C:\\Users\\matej_000\\Source\\Repos\\geogen\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:573:3: ^( INITIALIZATION_EXPRESSION initExpression )
            	    {
            	         MATCHT(INITIALIZATION_EXPRESSION, &FOLLOW_INITIALIZATION_EXPRESSION_in_forStatement824);
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleforStatementEx;
            	        }


            	        MATCHT(ANTLR3_TOKEN_DOWN, NULL);
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleforStatementEx;
            	        }

            	        FOLLOWPUSH(FOLLOW_initExpression_in_forStatement826);
            	        initExpression52=initExpression(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleforStatementEx;
            	        }


            	        {
            	             initExpressionCodeBlock = initExpression52
            	            ; 
            	        }


            	        MATCHT(ANTLR3_TOKEN_UP, NULL);
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleforStatementEx;
            	        }



            	    }
            	    break;

                }
            }

            // C:\\Users\\matej_000\\Source\\Repos\\geogen\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:574:2: ( ^( CONDITION_EXPRESSION conditionExpression= expression ) )?
            {
                int alt19=2;
                switch ( LA(1) )
                {
                    case CONDITION_EXPRESSION:
                    	{
                    		alt19=1;
                    	}
                        break;
                }

                switch (alt19)
                {
            	case 1:
            	    // C:\\Users\\matej_000\\Source\\Repos\\geogen\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:574:3: ^( CONDITION_EXPRESSION conditionExpression= expression )
            	    {
            	         MATCHT(CONDITION_EXPRESSION, &FOLLOW_CONDITION_EXPRESSION_in_forStatement838);
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleforStatementEx;
            	        }


            	        MATCHT(ANTLR3_TOKEN_DOWN, NULL);
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleforStatementEx;
            	        }

            	        FOLLOWPUSH(FOLLOW_expression_in_forStatement842);
            	        conditionExpression=expression(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleforStatementEx;
            	        }


            	        {
            	             conditionExpressionCodeBlock = conditionExpression.returnCodeBlock
            	            ; 
            	        }


            	        MATCHT(ANTLR3_TOKEN_UP, NULL);
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleforStatementEx;
            	        }



            	    }
            	    break;

                }
            }

            // C:\\Users\\matej_000\\Source\\Repos\\geogen\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:575:2: ( ^( INCREMENT_EXPRESSION incrementExpression= expression ) )?
            {
                int alt20=2;
                switch ( LA(1) )
                {
                    case INCREMENT_EXPRESSION:
                    	{
                    		alt20=1;
                    	}
                        break;
                }

                switch (alt20)
                {
            	case 1:
            	    // C:\\Users\\matej_000\\Source\\Repos\\geogen\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:575:3: ^( INCREMENT_EXPRESSION incrementExpression= expression )
            	    {
            	         MATCHT(INCREMENT_EXPRESSION, &FOLLOW_INCREMENT_EXPRESSION_in_forStatement854);
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleforStatementEx;
            	        }


            	        MATCHT(ANTLR3_TOKEN_DOWN, NULL);
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleforStatementEx;
            	        }

            	        FOLLOWPUSH(FOLLOW_expression_in_forStatement858);
            	        incrementExpression=expression(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleforStatementEx;
            	        }


            	        {
            	             incrementExpressionCodeBlock = incrementExpression.returnCodeBlock
            	            ; 
            	        }


            	        MATCHT(ANTLR3_TOKEN_UP, NULL);
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleforStatementEx;
            	        }



            	    }
            	    break;

                }
            }

            FOLLOWPUSH(FOLLOW_statement_in_forStatement868);
            statement54=statement(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleforStatementEx;
            }


            MATCHT(ANTLR3_TOKEN_UP, NULL);
            if  (HASEXCEPTION())
            {
                goto ruleforStatementEx;
            }



            {

                	CodeLocation location((FOR53->getLine(FOR53)), (FOR53->getCharPositionInLine(FOR53)));
                	
                	std::auto_ptr<instructions::CallBlockInstruction> wrappingInstruction(new instructions::CallBlockInstruction(location));

                	if(initExpressionCodeBlock != NULL)
                	{
                		wrappingInstruction->GetCodeBlock().MoveInstructionsFrom(*initExpressionCodeBlock);
                		delete initExpressionCodeBlock;
                	}
                	
                	instructions::WhileInstruction* whileInstr = new instructions::WhileInstruction(location);
                	CodeBlock& whileCodeBlock = whileInstr->GetCodeBlock();
                	
                	if(conditionExpressionCodeBlock != NULL)
                	{
                		whileCodeBlock.MoveInstructionsFrom(*conditionExpressionCodeBlock);
                		delete conditionExpressionCodeBlock;
                		
                		instructions::IfInstruction* ifInstr = new instructions::IfInstruction(location);
                		ifInstr->GetElseBranchCodeBlock().AddInstruction(new instructions::BreakInstruction(location, 2));
                		whileCodeBlock.AddInstruction(ifInstr);
                	}

                	whileCodeBlock.MoveInstructionsFrom(*
                statement54
                );
                	delete statement54
                ;
                	
                	if(incrementExpressionCodeBlock != NULL)
                	{
                		whileCodeBlock.MoveInstructionsFrom(*incrementExpressionCodeBlock);
                		delete incrementExpressionCodeBlock;
                		
                		whileCodeBlock.AddInstruction(new instructions::PopInstruction(location));
                	}
                	
                	wrappingInstruction->GetCodeBlock().AddInstruction(whileInstr);
                	
                	returnCodeBlock
                ->AddInstruction(wrappingInstruction.release());

            }


        }

    }

    // This is where rules clean up and exit
    //
    goto ruleforStatementEx; /* Prevent compiler warnings */
    ruleforStatementEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
            else
            {
                {
                     ctx->codeBlockLevel--; ctx->isInLoop = false; 
                }
            }


    pGeoGenScriptDecls_BlockScopePop(ctx);

    return returnCodeBlock;
}
/* $ANTLR end forStatement */

/**
 * $ANTLR start initExpression
 * C:\\Users\\matej_000\\Source\\Repos\\geogen\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:617:1: initExpression returns [CodeBlock* returnCodeBlock] : ( variableDeclaration | expression );
 */
static CodeBlock*
initExpression(pGeoGenScriptDecls ctx)
{
    CodeBlock* returnCodeBlock;


    CodeBlock* variableDeclaration55;
    #undef	RETURN_TYPE_variableDeclaration55
    #define	RETURN_TYPE_variableDeclaration55 CodeBlock*

    GeoGenScriptDecls_expression_return expression56;
    #undef	RETURN_TYPE_expression56
    #define	RETURN_TYPE_expression56 GeoGenScriptDecls_expression_return

    /* Initialize rule variables
     */

     returnCodeBlock= NULL;
     
    {
        {
            //  C:\\Users\\matej_000\\Source\\Repos\\geogen\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:619:5: ( variableDeclaration | expression )

            ANTLR3_UINT32 alt21;

            alt21=2;

            switch ( LA(1) )
            {
            case VAR:
            	{
            		alt21=1;
            	}
                break;
            case COLLECTION:
            case COORDINATE:
            case FALSE_LIT:
            case IDENTIFIER:
            case LEFT_BRACKET:
            case LEFT_SQUARE_BRACKET:
            case NUMBER:
            case OPERATOR_ASSIGN:
            case OPERATOR_ASSIGN_AND:
            case OPERATOR_ASSIGN_DIVIDE:
            case OPERATOR_ASSIGN_LSHIFT:
            case OPERATOR_ASSIGN_MINUS:
            case OPERATOR_ASSIGN_MODULO:
            case OPERATOR_ASSIGN_OR:
            case OPERATOR_ASSIGN_PLUS:
            case OPERATOR_ASSIGN_RSHIFT:
            case OPERATOR_ASSIGN_TIMES:
            case OPERATOR_BIT_AND:
            case OPERATOR_BIT_OR:
            case OPERATOR_BIT_XOR:
            case OPERATOR_DECREMENT_POST:
            case OPERATOR_DECREMENT_PRE:
            case OPERATOR_DIVIDE:
            case OPERATOR_DOT:
            case OPERATOR_EQUAL_TO:
            case OPERATOR_EXPR_IF:
            case OPERATOR_GREATER_THAN:
            case OPERATOR_GREATER_THAN_OR_EQUAL_TO:
            case OPERATOR_INCREMENT_POST:
            case OPERATOR_INCREMENT_PRE:
            case OPERATOR_IS:
            case OPERATOR_LESS_THAN:
            case OPERATOR_LESS_THAN_OR_EQUAL_TO:
            case OPERATOR_LSHIFT:
            case OPERATOR_MINUS:
            case OPERATOR_MINUS_UN:
            case OPERATOR_MODULO:
            case OPERATOR_NOT:
            case OPERATOR_NOT_EQUAL_TO:
            case OPERATOR_PLUS:
            case OPERATOR_PLUS_UN:
            case OPERATOR_RELATIVE:
            case OPERATOR_REL_AND:
            case OPERATOR_REL_OR:
            case OPERATOR_RSHIFT:
            case OPERATOR_TIMES:
            case STRING:
            case TRUE_LIT:
            	{
            		alt21=2;
            	}
                break;

            default:
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 21;
                EXCEPTION->state        = 0;


                goto ruleinitExpressionEx;

            }

            switch (alt21)
            {
        	case 1:
        	    // C:\\Users\\matej_000\\Source\\Repos\\geogen\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:620:5: variableDeclaration
        	    {
        	        FOLLOWPUSH(FOLLOW_variableDeclaration_in_initExpression893);
        	        variableDeclaration55=variableDeclaration(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleinitExpressionEx;
        	        }


        	        {
        	             returnCodeBlock= 
        	            variableDeclaration55
        	            ;
        	             
        	        }


        	    }
        	    break;
        	case 2:
        	    // C:\\Users\\matej_000\\Source\\Repos\\geogen\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:621:7: expression
        	    {
        	        FOLLOWPUSH(FOLLOW_expression_in_initExpression903);
        	        expression56=expression(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleinitExpressionEx;
        	        }


        	        {
        	             returnCodeBlock= 
        	            expression56.returnCodeBlock
        	            ;
        	             
        	        }


        	    }
        	    break;

            }
        }
    }

    // This is where rules clean up and exit
    //
    goto ruleinitExpressionEx; /* Prevent compiler warnings */
    ruleinitExpressionEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return returnCodeBlock;
}
/* $ANTLR end initExpression */

/**
 * $ANTLR start ifStatement
 * C:\\Users\\matej_000\\Source\\Repos\\geogen\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:623:1: ifStatement returns [CodeBlock* returnCodeBlock] : ^( IF expression ifBranchStatement= statement elseBranchStatement= statement ) ;
 */
static CodeBlock*
ifStatement(pGeoGenScriptDecls ctx)
{
    CodeBlock* returnCodeBlock;


    pANTLR3_BASE_TREE    IF57;
    CodeBlock* ifBranchStatement;
    #undef	RETURN_TYPE_ifBranchStatement
    #define	RETURN_TYPE_ifBranchStatement CodeBlock*

    CodeBlock* elseBranchStatement;
    #undef	RETURN_TYPE_elseBranchStatement
    #define	RETURN_TYPE_elseBranchStatement CodeBlock*

    GeoGenScriptDecls_expression_return expression58;
    #undef	RETURN_TYPE_expression58
    #define	RETURN_TYPE_expression58 GeoGenScriptDecls_expression_return

    /* Initialize rule variables
     */

     
    	returnCodeBlock= new CodeBlock();
     
    	ctx->codeBlockLevel++; 

    IF57       = NULL;

    {
        // C:\\Users\\matej_000\\Source\\Repos\\geogen\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:629:34: ( ^( IF expression ifBranchStatement= statement elseBranchStatement= statement ) )
        // C:\\Users\\matej_000\\Source\\Repos\\geogen\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:630:3: ^( IF expression ifBranchStatement= statement elseBranchStatement= statement )
        {
            IF57 = (pANTLR3_BASE_TREE) MATCHT(IF, &FOLLOW_IF_in_ifStatement929);
            if  (HASEXCEPTION())
            {
                goto ruleifStatementEx;
            }


            MATCHT(ANTLR3_TOKEN_DOWN, NULL);
            if  (HASEXCEPTION())
            {
                goto ruleifStatementEx;
            }

            FOLLOWPUSH(FOLLOW_expression_in_ifStatement931);
            expression58=expression(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleifStatementEx;
            }


            FOLLOWPUSH(FOLLOW_statement_in_ifStatement935);
            ifBranchStatement=statement(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleifStatementEx;
            }


            FOLLOWPUSH(FOLLOW_statement_in_ifStatement939);
            elseBranchStatement=statement(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleifStatementEx;
            }


            MATCHT(ANTLR3_TOKEN_UP, NULL);
            if  (HASEXCEPTION())
            {
                goto ruleifStatementEx;
            }



            {

                	CodeLocation location((IF57->getLine(IF57)), (IF57->getCharPositionInLine(IF57)));

                	
                returnCodeBlock
                ->MoveInstructionsFrom(*expression58.returnCodeBlock
                );

                	instructions::IfInstruction* ifInstr = new instructions::IfInstruction(location);
                	
                	ifInstr->GetIfBranchCodeBlock().MoveInstructionsFrom(*ifBranchStatement
                );
                	delete ifBranchStatement
                ;
                	
                	ifInstr->GetElseBranchCodeBlock().MoveInstructionsFrom(*elseBranchStatement
                );
                	delete elseBranchStatement
                ;
                	
                	returnCodeBlock
                ->AddInstruction(ifInstr);

            }


        }

    }

    // This is where rules clean up and exit
    //
    goto ruleifStatementEx; /* Prevent compiler warnings */
    ruleifStatementEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
            else
            {
                {
                     ctx->codeBlockLevel--; 
                }
            }


    return returnCodeBlock;
}
/* $ANTLR end ifStatement */

/**
 * $ANTLR start switchStatement
 * C:\\Users\\matej_000\\Source\\Repos\\geogen\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:647:1: switchStatement : ^( SWITCH expression ( normalCase )* ( defaultCase )? ) ;
 */
static void
switchStatement(pGeoGenScriptDecls ctx)
{
    /* Initialize rule variables
     */

    {
        // C:\\Users\\matej_000\\Source\\Repos\\geogen\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:647:16: ( ^( SWITCH expression ( normalCase )* ( defaultCase )? ) )
        // C:\\Users\\matej_000\\Source\\Repos\\geogen\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:647:18: ^( SWITCH expression ( normalCase )* ( defaultCase )? )
        {
             MATCHT(SWITCH, &FOLLOW_SWITCH_in_switchStatement951);
            if  (HASEXCEPTION())
            {
                goto ruleswitchStatementEx;
            }


            MATCHT(ANTLR3_TOKEN_DOWN, NULL);
            if  (HASEXCEPTION())
            {
                goto ruleswitchStatementEx;
            }

            FOLLOWPUSH(FOLLOW_expression_in_switchStatement953);
            expression(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleswitchStatementEx;
            }


            // C:\\Users\\matej_000\\Source\\Repos\\geogen\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:647:38: ( normalCase )*

            for (;;)
            {
                int alt22=2;
                switch ( LA(1) )
                {
                case CASE:
                	{
                		alt22=1;
                	}
                    break;

                }

                switch (alt22)
                {
            	case 1:
            	    // C:\\Users\\matej_000\\Source\\Repos\\geogen\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:647:38: normalCase
            	    {
            	        FOLLOWPUSH(FOLLOW_normalCase_in_switchStatement955);
            	        normalCase(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleswitchStatementEx;
            	        }


            	    }
            	    break;

            	default:
            	    goto loop22;	/* break out of the loop */
            	    break;
                }
            }
            loop22: ; /* Jump out to here if this rule does not match */


            // C:\\Users\\matej_000\\Source\\Repos\\geogen\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:647:50: ( defaultCase )?
            {
                int alt23=2;
                switch ( LA(1) )
                {
                    case DEFAULT:
                    	{
                    		alt23=1;
                    	}
                        break;
                }

                switch (alt23)
                {
            	case 1:
            	    // C:\\Users\\matej_000\\Source\\Repos\\geogen\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:647:50: defaultCase
            	    {
            	        FOLLOWPUSH(FOLLOW_defaultCase_in_switchStatement958);
            	        defaultCase(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleswitchStatementEx;
            	        }


            	    }
            	    break;

                }
            }

            MATCHT(ANTLR3_TOKEN_UP, NULL);
            if  (HASEXCEPTION())
            {
                goto ruleswitchStatementEx;
            }



        }

    }

    // This is where rules clean up and exit
    //
    goto ruleswitchStatementEx; /* Prevent compiler warnings */
    ruleswitchStatementEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end switchStatement */

/**
 * $ANTLR start normalCase
 * C:\\Users\\matej_000\\Source\\Repos\\geogen\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:649:1: normalCase : ^( CASE label ^( BLOCK ( statement )* ) ) ;
 */
static void
normalCase(pGeoGenScriptDecls ctx)
{
    /* Initialize rule variables
     */

    {
        // C:\\Users\\matej_000\\Source\\Repos\\geogen\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:649:11: ( ^( CASE label ^( BLOCK ( statement )* ) ) )
        // C:\\Users\\matej_000\\Source\\Repos\\geogen\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:649:13: ^( CASE label ^( BLOCK ( statement )* ) )
        {
             MATCHT(CASE, &FOLLOW_CASE_in_normalCase968);
            if  (HASEXCEPTION())
            {
                goto rulenormalCaseEx;
            }


            MATCHT(ANTLR3_TOKEN_DOWN, NULL);
            if  (HASEXCEPTION())
            {
                goto rulenormalCaseEx;
            }

            FOLLOWPUSH(FOLLOW_label_in_normalCase970);
            label(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulenormalCaseEx;
            }


             MATCHT(BLOCK, &FOLLOW_BLOCK_in_normalCase973);
            if  (HASEXCEPTION())
            {
                goto rulenormalCaseEx;
            }


            if ( LA(1)==ANTLR3_TOKEN_DOWN ) {
                MATCHT(ANTLR3_TOKEN_DOWN, NULL);
                if  (HASEXCEPTION())
                {
                    goto rulenormalCaseEx;
                }

                // C:\\Users\\matej_000\\Source\\Repos\\geogen\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:649:34: ( statement )*

                for (;;)
                {
                    int alt24=2;
                    switch ( LA(1) )
                    {
                    case BLOCK:
                    case BREAK:
                    case COLLECTION:
                    case CONTINUE:
                    case COORDINATE:
                    case FALSE_LIT:
                    case FOR:
                    case GLOBAL:
                    case IDENTIFIER:
                    case IF:
                    case LEFT_BRACKET:
                    case LEFT_SQUARE_BRACKET:
                    case NUMBER:
                    case OPERATOR_ASSIGN:
                    case OPERATOR_ASSIGN_AND:
                    case OPERATOR_ASSIGN_DIVIDE:
                    case OPERATOR_ASSIGN_LSHIFT:
                    case OPERATOR_ASSIGN_MINUS:
                    case OPERATOR_ASSIGN_MODULO:
                    case OPERATOR_ASSIGN_OR:
                    case OPERATOR_ASSIGN_PLUS:
                    case OPERATOR_ASSIGN_RSHIFT:
                    case OPERATOR_ASSIGN_TIMES:
                    case OPERATOR_BIT_AND:
                    case OPERATOR_BIT_OR:
                    case OPERATOR_BIT_XOR:
                    case OPERATOR_DECREMENT_POST:
                    case OPERATOR_DECREMENT_PRE:
                    case OPERATOR_DIVIDE:
                    case OPERATOR_DOT:
                    case OPERATOR_EQUAL_TO:
                    case OPERATOR_EXPR_IF:
                    case OPERATOR_GREATER_THAN:
                    case OPERATOR_GREATER_THAN_OR_EQUAL_TO:
                    case OPERATOR_INCREMENT_POST:
                    case OPERATOR_INCREMENT_PRE:
                    case OPERATOR_IS:
                    case OPERATOR_LESS_THAN:
                    case OPERATOR_LESS_THAN_OR_EQUAL_TO:
                    case OPERATOR_LSHIFT:
                    case OPERATOR_MINUS:
                    case OPERATOR_MINUS_UN:
                    case OPERATOR_MODULO:
                    case OPERATOR_NOT:
                    case OPERATOR_NOT_EQUAL_TO:
                    case OPERATOR_PLUS:
                    case OPERATOR_PLUS_UN:
                    case OPERATOR_RELATIVE:
                    case OPERATOR_REL_AND:
                    case OPERATOR_REL_OR:
                    case OPERATOR_RSHIFT:
                    case OPERATOR_TIMES:
                    case RETURN:
                    case STRING:
                    case SWITCH:
                    case TRUE_LIT:
                    case VAR:
                    case WHILE:
                    case YIELD:
                    	{
                    		alt24=1;
                    	}
                        break;

                    }

                    switch (alt24)
                    {
                	case 1:
                	    // C:\\Users\\matej_000\\Source\\Repos\\geogen\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:649:34: statement
                	    {
                	        FOLLOWPUSH(FOLLOW_statement_in_normalCase975);
                	        statement(ctx);

                	        FOLLOWPOP();
                	        if  (HASEXCEPTION())
                	        {
                	            goto rulenormalCaseEx;
                	        }


                	    }
                	    break;

                	default:
                	    goto loop24;	/* break out of the loop */
                	    break;
                    }
                }
                loop24: ; /* Jump out to here if this rule does not match */


                MATCHT(ANTLR3_TOKEN_UP, NULL);
                if  (HASEXCEPTION())
                {
                    goto rulenormalCaseEx;
                }

            }


            MATCHT(ANTLR3_TOKEN_UP, NULL);
            if  (HASEXCEPTION())
            {
                goto rulenormalCaseEx;
            }



        }

    }

    // This is where rules clean up and exit
    //
    goto rulenormalCaseEx; /* Prevent compiler warnings */
    rulenormalCaseEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end normalCase */

/**
 * $ANTLR start defaultCase
 * C:\\Users\\matej_000\\Source\\Repos\\geogen\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:650:1: defaultCase : ^( DEFAULT ^( BLOCK ( statement )* ) ) ;
 */
static void
defaultCase(pGeoGenScriptDecls ctx)
{
    /* Initialize rule variables
     */

    {
        // C:\\Users\\matej_000\\Source\\Repos\\geogen\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:650:12: ( ^( DEFAULT ^( BLOCK ( statement )* ) ) )
        // C:\\Users\\matej_000\\Source\\Repos\\geogen\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:650:14: ^( DEFAULT ^( BLOCK ( statement )* ) )
        {
             MATCHT(DEFAULT, &FOLLOW_DEFAULT_in_defaultCase985);
            if  (HASEXCEPTION())
            {
                goto ruledefaultCaseEx;
            }


            MATCHT(ANTLR3_TOKEN_DOWN, NULL);
            if  (HASEXCEPTION())
            {
                goto ruledefaultCaseEx;
            }

             MATCHT(BLOCK, &FOLLOW_BLOCK_in_defaultCase988);
            if  (HASEXCEPTION())
            {
                goto ruledefaultCaseEx;
            }


            if ( LA(1)==ANTLR3_TOKEN_DOWN ) {
                MATCHT(ANTLR3_TOKEN_DOWN, NULL);
                if  (HASEXCEPTION())
                {
                    goto ruledefaultCaseEx;
                }

                // C:\\Users\\matej_000\\Source\\Repos\\geogen\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:650:32: ( statement )*

                for (;;)
                {
                    int alt25=2;
                    switch ( LA(1) )
                    {
                    case BLOCK:
                    case BREAK:
                    case COLLECTION:
                    case CONTINUE:
                    case COORDINATE:
                    case FALSE_LIT:
                    case FOR:
                    case GLOBAL:
                    case IDENTIFIER:
                    case IF:
                    case LEFT_BRACKET:
                    case LEFT_SQUARE_BRACKET:
                    case NUMBER:
                    case OPERATOR_ASSIGN:
                    case OPERATOR_ASSIGN_AND:
                    case OPERATOR_ASSIGN_DIVIDE:
                    case OPERATOR_ASSIGN_LSHIFT:
                    case OPERATOR_ASSIGN_MINUS:
                    case OPERATOR_ASSIGN_MODULO:
                    case OPERATOR_ASSIGN_OR:
                    case OPERATOR_ASSIGN_PLUS:
                    case OPERATOR_ASSIGN_RSHIFT:
                    case OPERATOR_ASSIGN_TIMES:
                    case OPERATOR_BIT_AND:
                    case OPERATOR_BIT_OR:
                    case OPERATOR_BIT_XOR:
                    case OPERATOR_DECREMENT_POST:
                    case OPERATOR_DECREMENT_PRE:
                    case OPERATOR_DIVIDE:
                    case OPERATOR_DOT:
                    case OPERATOR_EQUAL_TO:
                    case OPERATOR_EXPR_IF:
                    case OPERATOR_GREATER_THAN:
                    case OPERATOR_GREATER_THAN_OR_EQUAL_TO:
                    case OPERATOR_INCREMENT_POST:
                    case OPERATOR_INCREMENT_PRE:
                    case OPERATOR_IS:
                    case OPERATOR_LESS_THAN:
                    case OPERATOR_LESS_THAN_OR_EQUAL_TO:
                    case OPERATOR_LSHIFT:
                    case OPERATOR_MINUS:
                    case OPERATOR_MINUS_UN:
                    case OPERATOR_MODULO:
                    case OPERATOR_NOT:
                    case OPERATOR_NOT_EQUAL_TO:
                    case OPERATOR_PLUS:
                    case OPERATOR_PLUS_UN:
                    case OPERATOR_RELATIVE:
                    case OPERATOR_REL_AND:
                    case OPERATOR_REL_OR:
                    case OPERATOR_RSHIFT:
                    case OPERATOR_TIMES:
                    case RETURN:
                    case STRING:
                    case SWITCH:
                    case TRUE_LIT:
                    case VAR:
                    case WHILE:
                    case YIELD:
                    	{
                    		alt25=1;
                    	}
                        break;

                    }

                    switch (alt25)
                    {
                	case 1:
                	    // C:\\Users\\matej_000\\Source\\Repos\\geogen\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:650:32: statement
                	    {
                	        FOLLOWPUSH(FOLLOW_statement_in_defaultCase990);
                	        statement(ctx);

                	        FOLLOWPOP();
                	        if  (HASEXCEPTION())
                	        {
                	            goto ruledefaultCaseEx;
                	        }


                	    }
                	    break;

                	default:
                	    goto loop25;	/* break out of the loop */
                	    break;
                    }
                }
                loop25: ; /* Jump out to here if this rule does not match */


                MATCHT(ANTLR3_TOKEN_UP, NULL);
                if  (HASEXCEPTION())
                {
                    goto ruledefaultCaseEx;
                }

            }


            MATCHT(ANTLR3_TOKEN_UP, NULL);
            if  (HASEXCEPTION())
            {
                goto ruledefaultCaseEx;
            }



        }

    }

    // This is where rules clean up and exit
    //
    goto ruledefaultCaseEx; /* Prevent compiler warnings */
    ruledefaultCaseEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end defaultCase */

/**
 * $ANTLR start expression
 * C:\\Users\\matej_000\\Source\\Repos\\geogen\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:652:1: expression returns [CodeBlock* returnCodeBlock, CodeBlock* refCodeBlock] : ( ^( OPERATOR_ASSIGN lvalueExpression rvalueExpression= expression ) | ^(op= OPERATOR_ASSIGN_PLUS e1= expression e2= expression ) | ^(op= '-=' e1= expression e2= expression ) | ^(op= '*=' e1= expression e2= expression ) | ^(op= '/=' e1= expression e2= expression ) | ^(op= '%=' e1= expression e2= expression ) | ^(op= '<<=' e1= expression e2= expression ) | ^(op= '>>=' e1= expression e2= expression ) | ^(op= '&=' e1= expression e2= expression ) | ^(op= '|=' e1= expression e2= expression ) | ^(op= 'is' e1= expression e2= expression ) | conditionalOperatorExpression | ^(op= '||' e1= expression e2= expression ) | ^(op= '&&' e1= expression e2= expression ) | ^(op= '^' e1= expression e2= expression ) | ^(op= '&' e1= expression e2= expression ) | ^(op= '|' e1= expression e2= expression ) | ^(op= '==' e1= expression e2= expression ) | ^(op= '!=' e1= expression e2= expression ) | ^(op= '<' e1= expression e2= expression ) | ^(op= '<=' e1= expression e2= expression ) | ^(op= '>' e1= expression e2= expression ) | ^(op= '>=' e1= expression e2= expression ) | ^(op= '<<' e1= expression e2= expression ) | ^(op= '>>' e1= expression e2= expression ) | ^(op= OPERATOR_PLUS e1= expression e2= expression ) | ^(op= OPERATOR_MINUS e1= expression e2= expression ) | ^(op= OPERATOR_TIMES e1= expression e2= expression ) | ^(op= OPERATOR_DIVIDE e1= expression e2= expression ) | ^(op= OPERATOR_MODULO e1= expression e2= expression ) | ^(op= OPERATOR_INCREMENT_PRE e1= expression ) | ^(op= OPERATOR_INCREMENT_POST e1= expression ) | ^(op= OPERATOR_DECREMENT_PRE e1= expression ) | ^(op= OPERATOR_DECREMENT_POST e1= expression ) | ^(op= OPERATOR_PLUS_UN e1= expression ) | ^(op= OPERATOR_MINUS_UN e1= expression ) | ^(op= OPERATOR_NOT e1= expression ) | ^(op= OPERATOR_RELATIVE e1= expression ) | ^( OPERATOR_DOT e1= expression IDENTIFIER ) | callExpression | indexAccessExpression | IDENTIFIER | TRUE_LIT | FALSE_LIT | NUMBER | stringLiteral | coordinateExpression | collectionLiteral );
 */
static GeoGenScriptDecls_expression_return
expression(pGeoGenScriptDecls ctx)
{
    GeoGenScriptDecls_expression_return retval;


    pANTLR3_BASE_TREE    op;
    pANTLR3_BASE_TREE    OPERATOR_ASSIGN59;
    pANTLR3_BASE_TREE    OPERATOR_DOT62;
    pANTLR3_BASE_TREE    IDENTIFIER63;
    pANTLR3_BASE_TREE    IDENTIFIER66;
    pANTLR3_BASE_TREE    TRUE_LIT67;
    pANTLR3_BASE_TREE    FALSE_LIT68;
    pANTLR3_BASE_TREE    NUMBER69;
    GeoGenScriptDecls_expression_return rvalueExpression;
    #undef	RETURN_TYPE_rvalueExpression
    #define	RETURN_TYPE_rvalueExpression GeoGenScriptDecls_expression_return

    GeoGenScriptDecls_expression_return e1;
    #undef	RETURN_TYPE_e1
    #define	RETURN_TYPE_e1 GeoGenScriptDecls_expression_return

    GeoGenScriptDecls_expression_return e2;
    #undef	RETURN_TYPE_e2
    #define	RETURN_TYPE_e2 GeoGenScriptDecls_expression_return

    CodeBlock* lvalueExpression60;
    #undef	RETURN_TYPE_lvalueExpression60
    #define	RETURN_TYPE_lvalueExpression60 CodeBlock*

    CodeBlock* conditionalOperatorExpression61;
    #undef	RETURN_TYPE_conditionalOperatorExpression61
    #define	RETURN_TYPE_conditionalOperatorExpression61 CodeBlock*

    CodeBlock* callExpression64;
    #undef	RETURN_TYPE_callExpression64
    #define	RETURN_TYPE_callExpression64 CodeBlock*

    GeoGenScriptDecls_indexAccessExpression_return indexAccessExpression65;
    #undef	RETURN_TYPE_indexAccessExpression65
    #define	RETURN_TYPE_indexAccessExpression65 GeoGenScriptDecls_indexAccessExpression_return

    GeoGenScriptDecls_stringLiteral_return stringLiteral70;
    #undef	RETURN_TYPE_stringLiteral70
    #define	RETURN_TYPE_stringLiteral70 GeoGenScriptDecls_stringLiteral_return

    CodeBlock* coordinateExpression71;
    #undef	RETURN_TYPE_coordinateExpression71
    #define	RETURN_TYPE_coordinateExpression71 CodeBlock*

    CodeBlock* collectionLiteral72;
    #undef	RETURN_TYPE_collectionLiteral72
    #define	RETURN_TYPE_collectionLiteral72 CodeBlock*

    /* Initialize rule variables
     */

     retval.returnCodeBlock= new CodeBlock();
     retval.refCodeBlock= NULL;
     
    op       = NULL;
    OPERATOR_ASSIGN59       = NULL;
    OPERATOR_DOT62       = NULL;
    IDENTIFIER63       = NULL;
    IDENTIFIER66       = NULL;
    TRUE_LIT67       = NULL;
    FALSE_LIT68       = NULL;
    NUMBER69       = NULL;
    retval.start = LT(1); retval.stop = retval.start;


    {
        {
            //  C:\\Users\\matej_000\\Source\\Repos\\geogen\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:654:2: ( ^( OPERATOR_ASSIGN lvalueExpression rvalueExpression= expression ) | ^(op= OPERATOR_ASSIGN_PLUS e1= expression e2= expression ) | ^(op= '-=' e1= expression e2= expression ) | ^(op= '*=' e1= expression e2= expression ) | ^(op= '/=' e1= expression e2= expression ) | ^(op= '%=' e1= expression e2= expression ) | ^(op= '<<=' e1= expression e2= expression ) | ^(op= '>>=' e1= expression e2= expression ) | ^(op= '&=' e1= expression e2= expression ) | ^(op= '|=' e1= expression e2= expression ) | ^(op= 'is' e1= expression e2= expression ) | conditionalOperatorExpression | ^(op= '||' e1= expression e2= expression ) | ^(op= '&&' e1= expression e2= expression ) | ^(op= '^' e1= expression e2= expression ) | ^(op= '&' e1= expression e2= expression ) | ^(op= '|' e1= expression e2= expression ) | ^(op= '==' e1= expression e2= expression ) | ^(op= '!=' e1= expression e2= expression ) | ^(op= '<' e1= expression e2= expression ) | ^(op= '<=' e1= expression e2= expression ) | ^(op= '>' e1= expression e2= expression ) | ^(op= '>=' e1= expression e2= expression ) | ^(op= '<<' e1= expression e2= expression ) | ^(op= '>>' e1= expression e2= expression ) | ^(op= OPERATOR_PLUS e1= expression e2= expression ) | ^(op= OPERATOR_MINUS e1= expression e2= expression ) | ^(op= OPERATOR_TIMES e1= expression e2= expression ) | ^(op= OPERATOR_DIVIDE e1= expression e2= expression ) | ^(op= OPERATOR_MODULO e1= expression e2= expression ) | ^(op= OPERATOR_INCREMENT_PRE e1= expression ) | ^(op= OPERATOR_INCREMENT_POST e1= expression ) | ^(op= OPERATOR_DECREMENT_PRE e1= expression ) | ^(op= OPERATOR_DECREMENT_POST e1= expression ) | ^(op= OPERATOR_PLUS_UN e1= expression ) | ^(op= OPERATOR_MINUS_UN e1= expression ) | ^(op= OPERATOR_NOT e1= expression ) | ^(op= OPERATOR_RELATIVE e1= expression ) | ^( OPERATOR_DOT e1= expression IDENTIFIER ) | callExpression | indexAccessExpression | IDENTIFIER | TRUE_LIT | FALSE_LIT | NUMBER | stringLiteral | coordinateExpression | collectionLiteral )

            ANTLR3_UINT32 alt26;

            alt26=48;

            switch ( LA(1) )
            {
            case OPERATOR_ASSIGN:
            	{
            		alt26=1;
            	}
                break;
            case OPERATOR_ASSIGN_PLUS:
            	{
            		alt26=2;
            	}
                break;
            case OPERATOR_ASSIGN_MINUS:
            	{
            		alt26=3;
            	}
                break;
            case OPERATOR_ASSIGN_TIMES:
            	{
            		alt26=4;
            	}
                break;
            case OPERATOR_ASSIGN_DIVIDE:
            	{
            		alt26=5;
            	}
                break;
            case OPERATOR_ASSIGN_MODULO:
            	{
            		alt26=6;
            	}
                break;
            case OPERATOR_ASSIGN_LSHIFT:
            	{
            		alt26=7;
            	}
                break;
            case OPERATOR_ASSIGN_RSHIFT:
            	{
            		alt26=8;
            	}
                break;
            case OPERATOR_ASSIGN_AND:
            	{
            		alt26=9;
            	}
                break;
            case OPERATOR_ASSIGN_OR:
            	{
            		alt26=10;
            	}
                break;
            case OPERATOR_IS:
            	{
            		alt26=11;
            	}
                break;
            case OPERATOR_EXPR_IF:
            	{
            		alt26=12;
            	}
                break;
            case OPERATOR_REL_OR:
            	{
            		alt26=13;
            	}
                break;
            case OPERATOR_REL_AND:
            	{
            		alt26=14;
            	}
                break;
            case OPERATOR_BIT_XOR:
            	{
            		alt26=15;
            	}
                break;
            case OPERATOR_BIT_AND:
            	{
            		alt26=16;
            	}
                break;
            case OPERATOR_BIT_OR:
            	{
            		alt26=17;
            	}
                break;
            case OPERATOR_EQUAL_TO:
            	{
            		alt26=18;
            	}
                break;
            case OPERATOR_NOT_EQUAL_TO:
            	{
            		alt26=19;
            	}
                break;
            case OPERATOR_LESS_THAN:
            	{
            		alt26=20;
            	}
                break;
            case OPERATOR_LESS_THAN_OR_EQUAL_TO:
            	{
            		alt26=21;
            	}
                break;
            case OPERATOR_GREATER_THAN:
            	{
            		alt26=22;
            	}
                break;
            case OPERATOR_GREATER_THAN_OR_EQUAL_TO:
            	{
            		alt26=23;
            	}
                break;
            case OPERATOR_LSHIFT:
            	{
            		alt26=24;
            	}
                break;
            case OPERATOR_RSHIFT:
            	{
            		alt26=25;
            	}
                break;
            case OPERATOR_PLUS:
            	{
            		alt26=26;
            	}
                break;
            case OPERATOR_MINUS:
            	{
            		alt26=27;
            	}
                break;
            case OPERATOR_TIMES:
            	{
            		alt26=28;
            	}
                break;
            case OPERATOR_DIVIDE:
            	{
            		alt26=29;
            	}
                break;
            case OPERATOR_MODULO:
            	{
            		alt26=30;
            	}
                break;
            case OPERATOR_INCREMENT_PRE:
            	{
            		alt26=31;
            	}
                break;
            case OPERATOR_INCREMENT_POST:
            	{
            		alt26=32;
            	}
                break;
            case OPERATOR_DECREMENT_PRE:
            	{
            		alt26=33;
            	}
                break;
            case OPERATOR_DECREMENT_POST:
            	{
            		alt26=34;
            	}
                break;
            case OPERATOR_PLUS_UN:
            	{
            		alt26=35;
            	}
                break;
            case OPERATOR_MINUS_UN:
            	{
            		alt26=36;
            	}
                break;
            case OPERATOR_NOT:
            	{
            		alt26=37;
            	}
                break;
            case OPERATOR_RELATIVE:
            	{
            		alt26=38;
            	}
                break;
            case OPERATOR_DOT:
            	{
            		alt26=39;
            	}
                break;
            case LEFT_BRACKET:
            	{
            		alt26=40;
            	}
                break;
            case LEFT_SQUARE_BRACKET:
            	{
            		alt26=41;
            	}
                break;
            case IDENTIFIER:
            	{
            		alt26=42;
            	}
                break;
            case TRUE_LIT:
            	{
            		alt26=43;
            	}
                break;
            case FALSE_LIT:
            	{
            		alt26=44;
            	}
                break;
            case NUMBER:
            	{
            		alt26=45;
            	}
                break;
            case STRING:
            	{
            		alt26=46;
            	}
                break;
            case COORDINATE:
            	{
            		alt26=47;
            	}
                break;
            case COLLECTION:
            	{
            		alt26=48;
            	}
                break;

            default:
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 26;
                EXCEPTION->state        = 0;


                goto ruleexpressionEx;

            }

            switch (alt26)
            {
        	case 1:
        	    // C:\\Users\\matej_000\\Source\\Repos\\geogen\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:655:2: ^( OPERATOR_ASSIGN lvalueExpression rvalueExpression= expression )
        	    {
        	        OPERATOR_ASSIGN59 = (pANTLR3_BASE_TREE) MATCHT(OPERATOR_ASSIGN, &FOLLOW_OPERATOR_ASSIGN_in_expression1013);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_DOWN, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }

        	        FOLLOWPUSH(FOLLOW_lvalueExpression_in_expression1015);
        	        lvalueExpression60=lvalueExpression(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }


        	        FOLLOWPUSH(FOLLOW_expression_in_expression1019);
        	        rvalueExpression=expression(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_UP, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }



        	        {
        	             
        	            		CodeLocation location((OPERATOR_ASSIGN59->getLine(OPERATOR_ASSIGN59)), (OPERATOR_ASSIGN59->getCharPositionInLine(OPERATOR_ASSIGN59)));
        	            	
        	            		
        	            retval.returnCodeBlock
        	            ->MoveInstructionsFrom(*rvalueExpression.returnCodeBlock
        	            ); 
        	            		delete rvalueExpression.returnCodeBlock
        	            ; 
        	            		if(rvalueExpression.refCodeBlock
        	             != NULL) delete rvalueExpression.refCodeBlock
        	            ; 
        	            		
        	            /*		retval.returnCodeBlock
        	            ->AddInstruction(new instructions::CallGlobalInstruction(location, "=", 1));*/
        	            		retval.returnCodeBlock
        	            ->MoveInstructionsFrom(*lvalueExpression60
        	            ); 
        	            		delete lvalueExpression60
        	            ; 
        	            	
        	        }


        	    }
        	    break;
        	case 2:
        	    // C:\\Users\\matej_000\\Source\\Repos\\geogen\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:667:4: ^(op= OPERATOR_ASSIGN_PLUS e1= expression e2= expression )
        	    {
        	        op = (pANTLR3_BASE_TREE) MATCHT(OPERATOR_ASSIGN_PLUS, &FOLLOW_OPERATOR_ASSIGN_PLUS_in_expression1031);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_DOWN, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }

        	        FOLLOWPUSH(FOLLOW_expression_in_expression1035);
        	        e1=expression(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }


        	        FOLLOWPUSH(FOLLOW_expression_in_expression1039);
        	        e2=expression(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_UP, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }



        	        {
        	             binaryRefOperator(ctx, op, 
        	            e1.returnCodeBlock
        	            , e2.returnCodeBlock
        	            , e1.refCodeBlock
        	            , e2.refCodeBlock
        	            , retval.returnCodeBlock
        	            );
        	        }


        	    }
        	    break;
        	case 3:
        	    // C:\\Users\\matej_000\\Source\\Repos\\geogen\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:668:4: ^(op= '-=' e1= expression e2= expression )
        	    {
        	        op = (pANTLR3_BASE_TREE) MATCHT(OPERATOR_ASSIGN_MINUS, &FOLLOW_OPERATOR_ASSIGN_MINUS_in_expression1050);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_DOWN, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }

        	        FOLLOWPUSH(FOLLOW_expression_in_expression1054);
        	        e1=expression(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }


        	        FOLLOWPUSH(FOLLOW_expression_in_expression1058);
        	        e2=expression(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_UP, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }



        	        {
        	             binaryRefOperator(ctx, op, 
        	            e1.returnCodeBlock
        	            , e2.returnCodeBlock
        	            , e1.refCodeBlock
        	            , e2.refCodeBlock
        	            , retval.returnCodeBlock
        	            );
        	        }


        	    }
        	    break;
        	case 4:
        	    // C:\\Users\\matej_000\\Source\\Repos\\geogen\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:669:4: ^(op= '*=' e1= expression e2= expression )
        	    {
        	        op = (pANTLR3_BASE_TREE) MATCHT(OPERATOR_ASSIGN_TIMES, &FOLLOW_OPERATOR_ASSIGN_TIMES_in_expression1069);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_DOWN, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }

        	        FOLLOWPUSH(FOLLOW_expression_in_expression1073);
        	        e1=expression(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }


        	        FOLLOWPUSH(FOLLOW_expression_in_expression1077);
        	        e2=expression(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_UP, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }



        	        {
        	             binaryRefOperator(ctx, op, 
        	            e1.returnCodeBlock
        	            , e2.returnCodeBlock
        	            , e1.refCodeBlock
        	            , e2.refCodeBlock
        	            , retval.returnCodeBlock
        	            );
        	        }


        	    }
        	    break;
        	case 5:
        	    // C:\\Users\\matej_000\\Source\\Repos\\geogen\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:670:4: ^(op= '/=' e1= expression e2= expression )
        	    {
        	        op = (pANTLR3_BASE_TREE) MATCHT(OPERATOR_ASSIGN_DIVIDE, &FOLLOW_OPERATOR_ASSIGN_DIVIDE_in_expression1088);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_DOWN, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }

        	        FOLLOWPUSH(FOLLOW_expression_in_expression1092);
        	        e1=expression(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }


        	        FOLLOWPUSH(FOLLOW_expression_in_expression1096);
        	        e2=expression(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_UP, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }



        	        {
        	             binaryRefOperator(ctx, op, 
        	            e1.returnCodeBlock
        	            , e2.returnCodeBlock
        	            , e1.refCodeBlock
        	            , e2.refCodeBlock
        	            , retval.returnCodeBlock
        	            );
        	        }


        	    }
        	    break;
        	case 6:
        	    // C:\\Users\\matej_000\\Source\\Repos\\geogen\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:671:4: ^(op= '%=' e1= expression e2= expression )
        	    {
        	        op = (pANTLR3_BASE_TREE) MATCHT(OPERATOR_ASSIGN_MODULO, &FOLLOW_OPERATOR_ASSIGN_MODULO_in_expression1107);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_DOWN, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }

        	        FOLLOWPUSH(FOLLOW_expression_in_expression1111);
        	        e1=expression(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }


        	        FOLLOWPUSH(FOLLOW_expression_in_expression1115);
        	        e2=expression(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_UP, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }



        	        {
        	             binaryRefOperator(ctx, op, 
        	            e1.returnCodeBlock
        	            , e2.returnCodeBlock
        	            , e1.refCodeBlock
        	            , e2.refCodeBlock
        	            , retval.returnCodeBlock
        	            );
        	        }


        	    }
        	    break;
        	case 7:
        	    // C:\\Users\\matej_000\\Source\\Repos\\geogen\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:672:4: ^(op= '<<=' e1= expression e2= expression )
        	    {
        	        op = (pANTLR3_BASE_TREE) MATCHT(OPERATOR_ASSIGN_LSHIFT, &FOLLOW_OPERATOR_ASSIGN_LSHIFT_in_expression1126);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_DOWN, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }

        	        FOLLOWPUSH(FOLLOW_expression_in_expression1130);
        	        e1=expression(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }


        	        FOLLOWPUSH(FOLLOW_expression_in_expression1134);
        	        e2=expression(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_UP, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }



        	        {
        	             binaryRefOperator(ctx, op, 
        	            e1.returnCodeBlock
        	            , e2.returnCodeBlock
        	            , e1.refCodeBlock
        	            , e2.refCodeBlock
        	            , retval.returnCodeBlock
        	            );
        	        }


        	    }
        	    break;
        	case 8:
        	    // C:\\Users\\matej_000\\Source\\Repos\\geogen\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:673:4: ^(op= '>>=' e1= expression e2= expression )
        	    {
        	        op = (pANTLR3_BASE_TREE) MATCHT(OPERATOR_ASSIGN_RSHIFT, &FOLLOW_OPERATOR_ASSIGN_RSHIFT_in_expression1145);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_DOWN, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }

        	        FOLLOWPUSH(FOLLOW_expression_in_expression1149);
        	        e1=expression(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }


        	        FOLLOWPUSH(FOLLOW_expression_in_expression1153);
        	        e2=expression(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_UP, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }



        	        {
        	             binaryRefOperator(ctx, op, 
        	            e1.returnCodeBlock
        	            , e2.returnCodeBlock
        	            , e1.refCodeBlock
        	            , e2.refCodeBlock
        	            , retval.returnCodeBlock
        	            );
        	        }


        	    }
        	    break;
        	case 9:
        	    // C:\\Users\\matej_000\\Source\\Repos\\geogen\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:674:4: ^(op= '&=' e1= expression e2= expression )
        	    {
        	        op = (pANTLR3_BASE_TREE) MATCHT(OPERATOR_ASSIGN_AND, &FOLLOW_OPERATOR_ASSIGN_AND_in_expression1164);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_DOWN, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }

        	        FOLLOWPUSH(FOLLOW_expression_in_expression1168);
        	        e1=expression(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }


        	        FOLLOWPUSH(FOLLOW_expression_in_expression1172);
        	        e2=expression(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_UP, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }



        	        {
        	             binaryRefOperator(ctx, op, 
        	            e1.returnCodeBlock
        	            , e2.returnCodeBlock
        	            , e1.refCodeBlock
        	            , e2.refCodeBlock
        	            , retval.returnCodeBlock
        	            );
        	        }


        	    }
        	    break;
        	case 10:
        	    // C:\\Users\\matej_000\\Source\\Repos\\geogen\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:675:4: ^(op= '|=' e1= expression e2= expression )
        	    {
        	        op = (pANTLR3_BASE_TREE) MATCHT(OPERATOR_ASSIGN_OR, &FOLLOW_OPERATOR_ASSIGN_OR_in_expression1183);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_DOWN, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }

        	        FOLLOWPUSH(FOLLOW_expression_in_expression1187);
        	        e1=expression(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }


        	        FOLLOWPUSH(FOLLOW_expression_in_expression1191);
        	        e2=expression(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_UP, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }



        	        {
        	             binaryRefOperator(ctx, op, 
        	            e1.returnCodeBlock
        	            , e2.returnCodeBlock
        	            , e1.refCodeBlock
        	            , e2.refCodeBlock
        	            , retval.returnCodeBlock
        	            );
        	        }


        	    }
        	    break;
        	case 11:
        	    // C:\\Users\\matej_000\\Source\\Repos\\geogen\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:676:4: ^(op= 'is' e1= expression e2= expression )
        	    {
        	        op = (pANTLR3_BASE_TREE) MATCHT(OPERATOR_IS, &FOLLOW_OPERATOR_IS_in_expression1202);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_DOWN, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }

        	        FOLLOWPUSH(FOLLOW_expression_in_expression1206);
        	        e1=expression(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }


        	        FOLLOWPUSH(FOLLOW_expression_in_expression1210);
        	        e2=expression(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_UP, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }



        	        {
        	             binaryRefOperator(ctx, op, 
        	            e1.returnCodeBlock
        	            , e2.returnCodeBlock
        	            , e1.refCodeBlock
        	            , e2.refCodeBlock
        	            , retval.returnCodeBlock
        	            );
        	        }


        	    }
        	    break;
        	case 12:
        	    // C:\\Users\\matej_000\\Source\\Repos\\geogen\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:677:4: conditionalOperatorExpression
        	    {
        	        FOLLOWPUSH(FOLLOW_conditionalOperatorExpression_in_expression1218);
        	        conditionalOperatorExpression61=conditionalOperatorExpression(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }


        	        {
        	             retval.returnCodeBlock
        	            ->MoveInstructionsFrom(*conditionalOperatorExpression61
        	            ); delete conditionalOperatorExpression61
        	            ;
        	        }


        	    }
        	    break;
        	case 13:
        	    // C:\\Users\\matej_000\\Source\\Repos\\geogen\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:678:4: ^(op= '||' e1= expression e2= expression )
        	    {
        	        op = (pANTLR3_BASE_TREE) MATCHT(OPERATOR_REL_OR, &FOLLOW_OPERATOR_REL_OR_in_expression1229);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_DOWN, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }

        	        FOLLOWPUSH(FOLLOW_expression_in_expression1233);
        	        e1=expression(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }


        	        FOLLOWPUSH(FOLLOW_expression_in_expression1237);
        	        e2=expression(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_UP, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }



        	        {
        	             binaryOperator(ctx, op, 
        	            e1.returnCodeBlock
        	            , e2.returnCodeBlock
        	            , e1.refCodeBlock
        	            , e2.refCodeBlock
        	            , retval.returnCodeBlock
        	            );
        	        }


        	    }
        	    break;
        	case 14:
        	    // C:\\Users\\matej_000\\Source\\Repos\\geogen\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:679:4: ^(op= '&&' e1= expression e2= expression )
        	    {
        	        op = (pANTLR3_BASE_TREE) MATCHT(OPERATOR_REL_AND, &FOLLOW_OPERATOR_REL_AND_in_expression1248);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_DOWN, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }

        	        FOLLOWPUSH(FOLLOW_expression_in_expression1252);
        	        e1=expression(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }


        	        FOLLOWPUSH(FOLLOW_expression_in_expression1256);
        	        e2=expression(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_UP, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }



        	        {
        	             binaryOperator(ctx, op, 
        	            e1.returnCodeBlock
        	            , e2.returnCodeBlock
        	            , e1.refCodeBlock
        	            , e2.refCodeBlock
        	            , retval.returnCodeBlock
        	            );
        	        }


        	    }
        	    break;
        	case 15:
        	    // C:\\Users\\matej_000\\Source\\Repos\\geogen\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:680:4: ^(op= '^' e1= expression e2= expression )
        	    {
        	        op = (pANTLR3_BASE_TREE) MATCHT(OPERATOR_BIT_XOR, &FOLLOW_OPERATOR_BIT_XOR_in_expression1267);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_DOWN, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }

        	        FOLLOWPUSH(FOLLOW_expression_in_expression1271);
        	        e1=expression(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }


        	        FOLLOWPUSH(FOLLOW_expression_in_expression1275);
        	        e2=expression(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_UP, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }



        	        {
        	             binaryOperator(ctx, op, 
        	            e1.returnCodeBlock
        	            , e2.returnCodeBlock
        	            , e1.refCodeBlock
        	            , e2.refCodeBlock
        	            , retval.returnCodeBlock
        	            );
        	        }


        	    }
        	    break;
        	case 16:
        	    // C:\\Users\\matej_000\\Source\\Repos\\geogen\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:681:4: ^(op= '&' e1= expression e2= expression )
        	    {
        	        op = (pANTLR3_BASE_TREE) MATCHT(OPERATOR_BIT_AND, &FOLLOW_OPERATOR_BIT_AND_in_expression1286);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_DOWN, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }

        	        FOLLOWPUSH(FOLLOW_expression_in_expression1290);
        	        e1=expression(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }


        	        FOLLOWPUSH(FOLLOW_expression_in_expression1294);
        	        e2=expression(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_UP, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }



        	        {
        	             binaryOperator(ctx, op, 
        	            e1.returnCodeBlock
        	            , e2.returnCodeBlock
        	            , e1.refCodeBlock
        	            , e2.refCodeBlock
        	            , retval.returnCodeBlock
        	            );
        	        }


        	    }
        	    break;
        	case 17:
        	    // C:\\Users\\matej_000\\Source\\Repos\\geogen\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:682:4: ^(op= '|' e1= expression e2= expression )
        	    {
        	        op = (pANTLR3_BASE_TREE) MATCHT(OPERATOR_BIT_OR, &FOLLOW_OPERATOR_BIT_OR_in_expression1305);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_DOWN, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }

        	        FOLLOWPUSH(FOLLOW_expression_in_expression1309);
        	        e1=expression(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }


        	        FOLLOWPUSH(FOLLOW_expression_in_expression1313);
        	        e2=expression(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_UP, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }



        	        {
        	             binaryOperator(ctx, op, 
        	            e1.returnCodeBlock
        	            , e2.returnCodeBlock
        	            , e1.refCodeBlock
        	            , e2.refCodeBlock
        	            , retval.returnCodeBlock
        	            );
        	        }


        	    }
        	    break;
        	case 18:
        	    // C:\\Users\\matej_000\\Source\\Repos\\geogen\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:683:4: ^(op= '==' e1= expression e2= expression )
        	    {
        	        op = (pANTLR3_BASE_TREE) MATCHT(OPERATOR_EQUAL_TO, &FOLLOW_OPERATOR_EQUAL_TO_in_expression1324);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_DOWN, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }

        	        FOLLOWPUSH(FOLLOW_expression_in_expression1328);
        	        e1=expression(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }


        	        FOLLOWPUSH(FOLLOW_expression_in_expression1332);
        	        e2=expression(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_UP, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }



        	        {
        	             binaryOperator(ctx, op, 
        	            e1.returnCodeBlock
        	            , e2.returnCodeBlock
        	            , e1.refCodeBlock
        	            , e2.refCodeBlock
        	            , retval.returnCodeBlock
        	            );
        	        }


        	    }
        	    break;
        	case 19:
        	    // C:\\Users\\matej_000\\Source\\Repos\\geogen\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:684:4: ^(op= '!=' e1= expression e2= expression )
        	    {
        	        op = (pANTLR3_BASE_TREE) MATCHT(OPERATOR_NOT_EQUAL_TO, &FOLLOW_OPERATOR_NOT_EQUAL_TO_in_expression1343);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_DOWN, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }

        	        FOLLOWPUSH(FOLLOW_expression_in_expression1347);
        	        e1=expression(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }


        	        FOLLOWPUSH(FOLLOW_expression_in_expression1351);
        	        e2=expression(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_UP, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }



        	        {
        	             binaryOperator(ctx, op, 
        	            e1.returnCodeBlock
        	            , e2.returnCodeBlock
        	            , e1.refCodeBlock
        	            , e2.refCodeBlock
        	            , retval.returnCodeBlock
        	            );
        	        }


        	    }
        	    break;
        	case 20:
        	    // C:\\Users\\matej_000\\Source\\Repos\\geogen\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:685:4: ^(op= '<' e1= expression e2= expression )
        	    {
        	        op = (pANTLR3_BASE_TREE) MATCHT(OPERATOR_LESS_THAN, &FOLLOW_OPERATOR_LESS_THAN_in_expression1362);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_DOWN, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }

        	        FOLLOWPUSH(FOLLOW_expression_in_expression1366);
        	        e1=expression(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }


        	        FOLLOWPUSH(FOLLOW_expression_in_expression1370);
        	        e2=expression(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_UP, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }



        	        {
        	             binaryOperator(ctx, op, 
        	            e1.returnCodeBlock
        	            , e2.returnCodeBlock
        	            , e1.refCodeBlock
        	            , e2.refCodeBlock
        	            , retval.returnCodeBlock
        	            );
        	        }


        	    }
        	    break;
        	case 21:
        	    // C:\\Users\\matej_000\\Source\\Repos\\geogen\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:686:4: ^(op= '<=' e1= expression e2= expression )
        	    {
        	        op = (pANTLR3_BASE_TREE) MATCHT(OPERATOR_LESS_THAN_OR_EQUAL_TO, &FOLLOW_OPERATOR_LESS_THAN_OR_EQUAL_TO_in_expression1381);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_DOWN, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }

        	        FOLLOWPUSH(FOLLOW_expression_in_expression1385);
        	        e1=expression(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }


        	        FOLLOWPUSH(FOLLOW_expression_in_expression1389);
        	        e2=expression(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_UP, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }



        	        {
        	             binaryOperator(ctx, op, 
        	            e1.returnCodeBlock
        	            , e2.returnCodeBlock
        	            , e1.refCodeBlock
        	            , e2.refCodeBlock
        	            , retval.returnCodeBlock
        	            );
        	        }


        	    }
        	    break;
        	case 22:
        	    // C:\\Users\\matej_000\\Source\\Repos\\geogen\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:687:4: ^(op= '>' e1= expression e2= expression )
        	    {
        	        op = (pANTLR3_BASE_TREE) MATCHT(OPERATOR_GREATER_THAN, &FOLLOW_OPERATOR_GREATER_THAN_in_expression1400);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_DOWN, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }

        	        FOLLOWPUSH(FOLLOW_expression_in_expression1404);
        	        e1=expression(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }


        	        FOLLOWPUSH(FOLLOW_expression_in_expression1408);
        	        e2=expression(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_UP, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }



        	        {
        	             binaryOperator(ctx, op, 
        	            e1.returnCodeBlock
        	            , e2.returnCodeBlock
        	            , e1.refCodeBlock
        	            , e2.refCodeBlock
        	            , retval.returnCodeBlock
        	            );
        	        }


        	    }
        	    break;
        	case 23:
        	    // C:\\Users\\matej_000\\Source\\Repos\\geogen\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:688:4: ^(op= '>=' e1= expression e2= expression )
        	    {
        	        op = (pANTLR3_BASE_TREE) MATCHT(OPERATOR_GREATER_THAN_OR_EQUAL_TO, &FOLLOW_OPERATOR_GREATER_THAN_OR_EQUAL_TO_in_expression1419);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_DOWN, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }

        	        FOLLOWPUSH(FOLLOW_expression_in_expression1423);
        	        e1=expression(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }


        	        FOLLOWPUSH(FOLLOW_expression_in_expression1427);
        	        e2=expression(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_UP, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }



        	        {
        	             binaryOperator(ctx, op, 
        	            e1.returnCodeBlock
        	            , e2.returnCodeBlock
        	            , e1.refCodeBlock
        	            , e2.refCodeBlock
        	            , retval.returnCodeBlock
        	            );
        	        }


        	    }
        	    break;
        	case 24:
        	    // C:\\Users\\matej_000\\Source\\Repos\\geogen\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:689:4: ^(op= '<<' e1= expression e2= expression )
        	    {
        	        op = (pANTLR3_BASE_TREE) MATCHT(OPERATOR_LSHIFT, &FOLLOW_OPERATOR_LSHIFT_in_expression1438);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_DOWN, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }

        	        FOLLOWPUSH(FOLLOW_expression_in_expression1442);
        	        e1=expression(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }


        	        FOLLOWPUSH(FOLLOW_expression_in_expression1446);
        	        e2=expression(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_UP, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }



        	        {
        	             binaryOperator(ctx, op, 
        	            e1.returnCodeBlock
        	            , e2.returnCodeBlock
        	            , e1.refCodeBlock
        	            , e2.refCodeBlock
        	            , retval.returnCodeBlock
        	            );
        	        }


        	    }
        	    break;
        	case 25:
        	    // C:\\Users\\matej_000\\Source\\Repos\\geogen\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:690:4: ^(op= '>>' e1= expression e2= expression )
        	    {
        	        op = (pANTLR3_BASE_TREE) MATCHT(OPERATOR_RSHIFT, &FOLLOW_OPERATOR_RSHIFT_in_expression1457);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_DOWN, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }

        	        FOLLOWPUSH(FOLLOW_expression_in_expression1461);
        	        e1=expression(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }


        	        FOLLOWPUSH(FOLLOW_expression_in_expression1465);
        	        e2=expression(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_UP, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }



        	        {
        	             binaryOperator(ctx, op, 
        	            e1.returnCodeBlock
        	            , e2.returnCodeBlock
        	            , e1.refCodeBlock
        	            , e2.refCodeBlock
        	            , retval.returnCodeBlock
        	            );
        	        }


        	    }
        	    break;
        	case 26:
        	    // C:\\Users\\matej_000\\Source\\Repos\\geogen\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:691:4: ^(op= OPERATOR_PLUS e1= expression e2= expression )
        	    {
        	        op = (pANTLR3_BASE_TREE) MATCHT(OPERATOR_PLUS, &FOLLOW_OPERATOR_PLUS_in_expression1476);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_DOWN, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }

        	        FOLLOWPUSH(FOLLOW_expression_in_expression1480);
        	        e1=expression(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }


        	        FOLLOWPUSH(FOLLOW_expression_in_expression1484);
        	        e2=expression(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_UP, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }



        	        {
        	             binaryOperator(ctx, op, 
        	            e1.returnCodeBlock
        	            , e2.returnCodeBlock
        	            , e1.refCodeBlock
        	            , e2.refCodeBlock
        	            , retval.returnCodeBlock
        	            );
        	        }


        	    }
        	    break;
        	case 27:
        	    // C:\\Users\\matej_000\\Source\\Repos\\geogen\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:692:4: ^(op= OPERATOR_MINUS e1= expression e2= expression )
        	    {
        	        op = (pANTLR3_BASE_TREE) MATCHT(OPERATOR_MINUS, &FOLLOW_OPERATOR_MINUS_in_expression1495);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_DOWN, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }

        	        FOLLOWPUSH(FOLLOW_expression_in_expression1499);
        	        e1=expression(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }


        	        FOLLOWPUSH(FOLLOW_expression_in_expression1503);
        	        e2=expression(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_UP, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }



        	        {
        	             binaryOperator(ctx, op, 
        	            e1.returnCodeBlock
        	            , e2.returnCodeBlock
        	            , e1.refCodeBlock
        	            , e2.refCodeBlock
        	            , retval.returnCodeBlock
        	            );
        	        }


        	    }
        	    break;
        	case 28:
        	    // C:\\Users\\matej_000\\Source\\Repos\\geogen\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:693:4: ^(op= OPERATOR_TIMES e1= expression e2= expression )
        	    {
        	        op = (pANTLR3_BASE_TREE) MATCHT(OPERATOR_TIMES, &FOLLOW_OPERATOR_TIMES_in_expression1514);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_DOWN, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }

        	        FOLLOWPUSH(FOLLOW_expression_in_expression1518);
        	        e1=expression(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }


        	        FOLLOWPUSH(FOLLOW_expression_in_expression1522);
        	        e2=expression(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_UP, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }



        	        {
        	             binaryOperator(ctx, op, 
        	            e1.returnCodeBlock
        	            , e2.returnCodeBlock
        	            , e1.refCodeBlock
        	            , e2.refCodeBlock
        	            , retval.returnCodeBlock
        	            );
        	        }


        	    }
        	    break;
        	case 29:
        	    // C:\\Users\\matej_000\\Source\\Repos\\geogen\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:694:4: ^(op= OPERATOR_DIVIDE e1= expression e2= expression )
        	    {
        	        op = (pANTLR3_BASE_TREE) MATCHT(OPERATOR_DIVIDE, &FOLLOW_OPERATOR_DIVIDE_in_expression1533);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_DOWN, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }

        	        FOLLOWPUSH(FOLLOW_expression_in_expression1537);
        	        e1=expression(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }


        	        FOLLOWPUSH(FOLLOW_expression_in_expression1541);
        	        e2=expression(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_UP, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }



        	        {
        	             binaryOperator(ctx, op, 
        	            e1.returnCodeBlock
        	            , e2.returnCodeBlock
        	            , e1.refCodeBlock
        	            , e2.refCodeBlock
        	            , retval.returnCodeBlock
        	            );
        	        }


        	    }
        	    break;
        	case 30:
        	    // C:\\Users\\matej_000\\Source\\Repos\\geogen\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:695:4: ^(op= OPERATOR_MODULO e1= expression e2= expression )
        	    {
        	        op = (pANTLR3_BASE_TREE) MATCHT(OPERATOR_MODULO, &FOLLOW_OPERATOR_MODULO_in_expression1552);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_DOWN, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }

        	        FOLLOWPUSH(FOLLOW_expression_in_expression1556);
        	        e1=expression(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }


        	        FOLLOWPUSH(FOLLOW_expression_in_expression1560);
        	        e2=expression(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_UP, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }



        	        {
        	             binaryOperator(ctx, op, 
        	            e1.returnCodeBlock
        	            , e2.returnCodeBlock
        	            , e1.refCodeBlock
        	            , e2.refCodeBlock
        	            , retval.returnCodeBlock
        	            );
        	        }


        	    }
        	    break;
        	case 31:
        	    // C:\\Users\\matej_000\\Source\\Repos\\geogen\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:696:4: ^(op= OPERATOR_INCREMENT_PRE e1= expression )
        	    {
        	        op = (pANTLR3_BASE_TREE) MATCHT(OPERATOR_INCREMENT_PRE, &FOLLOW_OPERATOR_INCREMENT_PRE_in_expression1571);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_DOWN, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }

        	        FOLLOWPUSH(FOLLOW_expression_in_expression1575);
        	        e1=expression(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_UP, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }



        	        {
        	             unaryRefOperator(ctx, op, "++pre", 
        	            e1.returnCodeBlock
        	            , e1.refCodeBlock
        	            , retval.returnCodeBlock
        	            );
        	        }


        	    }
        	    break;
        	case 32:
        	    // C:\\Users\\matej_000\\Source\\Repos\\geogen\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:697:4: ^(op= OPERATOR_INCREMENT_POST e1= expression )
        	    {
        	        op = (pANTLR3_BASE_TREE) MATCHT(OPERATOR_INCREMENT_POST, &FOLLOW_OPERATOR_INCREMENT_POST_in_expression1587);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_DOWN, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }

        	        FOLLOWPUSH(FOLLOW_expression_in_expression1591);
        	        e1=expression(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_UP, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }



        	        {
        	             unaryRefOperator(ctx, op, "++post", 
        	            e1.returnCodeBlock
        	            , e1.refCodeBlock
        	            , retval.returnCodeBlock
        	            );
        	        }


        	    }
        	    break;
        	case 33:
        	    // C:\\Users\\matej_000\\Source\\Repos\\geogen\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:698:4: ^(op= OPERATOR_DECREMENT_PRE e1= expression )
        	    {
        	        op = (pANTLR3_BASE_TREE) MATCHT(OPERATOR_DECREMENT_PRE, &FOLLOW_OPERATOR_DECREMENT_PRE_in_expression1604);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_DOWN, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }

        	        FOLLOWPUSH(FOLLOW_expression_in_expression1608);
        	        e1=expression(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_UP, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }



        	        {
        	             unaryRefOperator(ctx, op, "--pre", 
        	            e1.returnCodeBlock
        	            , e1.refCodeBlock
        	            , retval.returnCodeBlock
        	            );
        	        }


        	    }
        	    break;
        	case 34:
        	    // C:\\Users\\matej_000\\Source\\Repos\\geogen\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:699:4: ^(op= OPERATOR_DECREMENT_POST e1= expression )
        	    {
        	        op = (pANTLR3_BASE_TREE) MATCHT(OPERATOR_DECREMENT_POST, &FOLLOW_OPERATOR_DECREMENT_POST_in_expression1620);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_DOWN, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }

        	        FOLLOWPUSH(FOLLOW_expression_in_expression1624);
        	        e1=expression(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_UP, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }



        	        {
        	             unaryRefOperator(ctx, op, "--post", 
        	            e1.returnCodeBlock
        	            , e1.refCodeBlock
        	            , retval.returnCodeBlock
        	            );
        	        }


        	    }
        	    break;
        	case 35:
        	    // C:\\Users\\matej_000\\Source\\Repos\\geogen\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:700:4: ^(op= OPERATOR_PLUS_UN e1= expression )
        	    {
        	        op = (pANTLR3_BASE_TREE) MATCHT(OPERATOR_PLUS_UN, &FOLLOW_OPERATOR_PLUS_UN_in_expression1639);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_DOWN, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }

        	        FOLLOWPUSH(FOLLOW_expression_in_expression1643);
        	        e1=expression(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_UP, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }



        	        {
        	             unaryOperator(ctx, op, "+un", 
        	            e1.returnCodeBlock
        	            , e1.refCodeBlock
        	            , retval.returnCodeBlock
        	            );
        	        }


        	    }
        	    break;
        	case 36:
        	    // C:\\Users\\matej_000\\Source\\Repos\\geogen\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:701:4: ^(op= OPERATOR_MINUS_UN e1= expression )
        	    {
        	        op = (pANTLR3_BASE_TREE) MATCHT(OPERATOR_MINUS_UN, &FOLLOW_OPERATOR_MINUS_UN_in_expression1658);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_DOWN, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }

        	        FOLLOWPUSH(FOLLOW_expression_in_expression1662);
        	        e1=expression(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_UP, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }



        	        {
        	             unaryOperator(ctx, op, "-un", 
        	            e1.returnCodeBlock
        	            , e1.refCodeBlock
        	            , retval.returnCodeBlock
        	            );
        	        }


        	    }
        	    break;
        	case 37:
        	    // C:\\Users\\matej_000\\Source\\Repos\\geogen\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:702:4: ^(op= OPERATOR_NOT e1= expression )
        	    {
        	        op = (pANTLR3_BASE_TREE) MATCHT(OPERATOR_NOT, &FOLLOW_OPERATOR_NOT_in_expression1678);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_DOWN, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }

        	        FOLLOWPUSH(FOLLOW_expression_in_expression1682);
        	        e1=expression(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_UP, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }



        	        {
        	             unaryOperator(ctx, op, "!", 
        	            e1.returnCodeBlock
        	            , e1.refCodeBlock
        	            , retval.returnCodeBlock
        	            );
        	        }


        	    }
        	    break;
        	case 38:
        	    // C:\\Users\\matej_000\\Source\\Repos\\geogen\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:703:4: ^(op= OPERATOR_RELATIVE e1= expression )
        	    {
        	        op = (pANTLR3_BASE_TREE) MATCHT(OPERATOR_RELATIVE, &FOLLOW_OPERATOR_RELATIVE_in_expression1699);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_DOWN, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }

        	        FOLLOWPUSH(FOLLOW_expression_in_expression1703);
        	        e1=expression(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_UP, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }



        	        {
        	             unaryOperator(ctx, op, "@", 
        	            e1.returnCodeBlock
        	            , e1.refCodeBlock
        	            , retval.returnCodeBlock
        	            );
        	        }


        	    }
        	    break;
        	case 39:
        	    // C:\\Users\\matej_000\\Source\\Repos\\geogen\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:704:4: ^( OPERATOR_DOT e1= expression IDENTIFIER )
        	    {
        	        OPERATOR_DOT62 = (pANTLR3_BASE_TREE) MATCHT(OPERATOR_DOT, &FOLLOW_OPERATOR_DOT_in_expression1719);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_DOWN, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }

        	        FOLLOWPUSH(FOLLOW_expression_in_expression1723);
        	        e1=expression(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }


        	        IDENTIFIER63 = (pANTLR3_BASE_TREE) MATCHT(IDENTIFIER, &FOLLOW_IDENTIFIER_in_expression1725);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_UP, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }



        	        {
        	             
        	            		CodeLocation location((OPERATOR_DOT62->getLine(OPERATOR_DOT62)), (OPERATOR_DOT62->getCharPositionInLine(OPERATOR_DOT62)));
        	            	
        	            		
        	            retval.returnCodeBlock
        	            ->MoveInstructionsFrom(*e1.returnCodeBlock
        	            ); 
        	            		delete e1.returnCodeBlock
        	            ; 
        	            		if(e1.refCodeBlock
        	             != NULL) delete e1.refCodeBlock
        	            ; 
        	            		
        	            		retval.returnCodeBlock
        	            ->AddInstruction(new instructions::LoadMemberValueInstruction(location, (Char*)(IDENTIFIER63->getText(IDENTIFIER63))->chars));
        	            	
        	        }


        	    }
        	    break;
        	case 40:
        	    // C:\\Users\\matej_000\\Source\\Repos\\geogen\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:714:4: callExpression
        	    {
        	        FOLLOWPUSH(FOLLOW_callExpression_in_expression1735);
        	        callExpression64=callExpression(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }


        	        {
        	             retval.returnCodeBlock
        	            ->MoveInstructionsFrom(*callExpression64
        	            ); delete callExpression64
        	            ;
        	        }


        	    }
        	    break;
        	case 41:
        	    // C:\\Users\\matej_000\\Source\\Repos\\geogen\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:715:4: indexAccessExpression
        	    {
        	        FOLLOWPUSH(FOLLOW_indexAccessExpression_in_expression1743);
        	        indexAccessExpression65=indexAccessExpression(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }


        	        {
        	             
        	            		retval.returnCodeBlock
        	            ->MoveInstructionsFrom(*indexAccessExpression65.returnCodeBlock
        	            ); delete indexAccessExpression65.returnCodeBlock
        	            ;	
        	            		retval.refCodeBlock= 
        	            indexAccessExpression65.refCodeBlock
        	            ;

        	            	
        	        }


        	    }
        	    break;
        	case 42:
        	    // C:\\Users\\matej_000\\Source\\Repos\\geogen\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:720:4: IDENTIFIER
        	    {
        	        IDENTIFIER66 = (pANTLR3_BASE_TREE) MATCHT(IDENTIFIER, &FOLLOW_IDENTIFIER_in_expression1753);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }


        	        {
        	             
        	            		CodeLocation location((IDENTIFIER66->getLine(IDENTIFIER66)), (IDENTIFIER66->getCharPositionInLine(IDENTIFIER66)));
        	            		
        	            retval.returnCodeBlock
        	            ->AddInstruction(new instructions::LoadScopeValueInstruction(location, (Char*)(IDENTIFIER66->getText(IDENTIFIER66))->chars)); 
        	            		
        	            retval.refCodeBlock= new CodeBlock();

        	            		retval.refCodeBlock
        	            ->AddInstruction(new instructions::LoadScopeReferenceInstruction(location, (Char*)(IDENTIFIER66->getText(IDENTIFIER66))->chars)); 
        	            	
        	        }


        	    }
        	    break;
        	case 43:
        	    // C:\\Users\\matej_000\\Source\\Repos\\geogen\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:728:4: TRUE_LIT
        	    {
        	        TRUE_LIT67 = (pANTLR3_BASE_TREE) MATCHT(TRUE_LIT, &FOLLOW_TRUE_LIT_in_expression1764);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }


        	        {
        	             
        	            		CodeLocation location((TRUE_LIT67->getLine(TRUE_LIT67)), (TRUE_LIT67->getCharPositionInLine(TRUE_LIT67)));
        	            		
        	            retval.returnCodeBlock
        	            ->AddInstruction(new instructions::LoadConstBooleanInstruction(location, true));	
        	            	
        	        }


        	    }
        	    break;
        	case 44:
        	    // C:\\Users\\matej_000\\Source\\Repos\\geogen\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:733:4: FALSE_LIT
        	    {
        	        FALSE_LIT68 = (pANTLR3_BASE_TREE) MATCHT(FALSE_LIT, &FOLLOW_FALSE_LIT_in_expression1772);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }


        	        {
        	             
        	            		CodeLocation location((FALSE_LIT68->getLine(FALSE_LIT68)), (FALSE_LIT68->getCharPositionInLine(FALSE_LIT68)));
        	            		
        	            retval.returnCodeBlock
        	            ->AddInstruction(new instructions::LoadConstBooleanInstruction(location, false));
        	            	
        	        }


        	    }
        	    break;
        	case 45:
        	    // C:\\Users\\matej_000\\Source\\Repos\\geogen\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:738:4: NUMBER
        	    {
        	        NUMBER69 = (pANTLR3_BASE_TREE) MATCHT(NUMBER, &FOLLOW_NUMBER_in_expression1781);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }


        	        {
        	             
        	            		CodeLocation location((NUMBER69->getLine(NUMBER69)), (NUMBER69->getCharPositionInLine(NUMBER69)));	
        	            		
        	            retval.returnCodeBlock
        	            ->AddInstruction(new instructions::LoadConstNumberInstruction(location, StringToNumber((Char*)(NUMBER69->getText(NUMBER69))->chars)));
        	            	
        	        }


        	    }
        	    break;
        	case 46:
        	    // C:\\Users\\matej_000\\Source\\Repos\\geogen\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:743:4: stringLiteral
        	    {
        	        FOLLOWPUSH(FOLLOW_stringLiteral_in_expression1790);
        	        stringLiteral70=stringLiteral(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }


        	        {
        	             
        	            		CodeLocation location(stringLiteral70.line
        	            , stringLiteral70.pos
        	            );	
        	            		retval.returnCodeBlock
        	            ->AddInstruction(new instructions::LoadConstStringInstruction(location, stringLiteral70.value
        	            ));
        	            	
        	        }


        	    }
        	    break;
        	case 47:
        	    // C:\\Users\\matej_000\\Source\\Repos\\geogen\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:748:4: coordinateExpression
        	    {
        	        FOLLOWPUSH(FOLLOW_coordinateExpression_in_expression1799);
        	        coordinateExpression71=coordinateExpression(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }


        	        {
        	             retval.returnCodeBlock
        	            ->MoveInstructionsFrom(*coordinateExpression71
        	            ); delete coordinateExpression71
        	            ;
        	        }


        	    }
        	    break;
        	case 48:
        	    // C:\\Users\\matej_000\\Source\\Repos\\geogen\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:749:4: collectionLiteral
        	    {
        	        FOLLOWPUSH(FOLLOW_collectionLiteral_in_expression1807);
        	        collectionLiteral72=collectionLiteral(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }


        	        {
        	             retval.returnCodeBlock
        	            ->MoveInstructionsFrom(*collectionLiteral72
        	            ); delete collectionLiteral72
        	            ;
        	        }


        	    }
        	    break;

            }
        }
    }

    // This is where rules clean up and exit
    //
    goto ruleexpressionEx; /* Prevent compiler warnings */
    ruleexpressionEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return retval;
}
/* $ANTLR end expression */

/**
 * $ANTLR start coordinateExpression
 * C:\\Users\\matej_000\\Source\\Repos\\geogen\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:752:1: coordinateExpression returns [CodeBlock* returnCodeBlock] : ^( COORDINATE ( expression )* ) ;
 */
static CodeBlock*
coordinateExpression(pGeoGenScriptDecls ctx)
{
    CodeBlock* returnCodeBlock;


    pANTLR3_BASE_TREE    COORDINATE74;
    GeoGenScriptDecls_expression_return expression73;
    #undef	RETURN_TYPE_expression73
    #define	RETURN_TYPE_expression73 GeoGenScriptDecls_expression_return

    /* Initialize rule variables
     */

     returnCodeBlock= new CodeBlock();
     std::vector<CodeBlock*> argumentCodeBlocks; 
    COORDINATE74       = NULL;

    {
        // C:\\Users\\matej_000\\Source\\Repos\\geogen\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:754:3: ( ^( COORDINATE ( expression )* ) )
        // C:\\Users\\matej_000\\Source\\Repos\\geogen\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:755:3: ^( COORDINATE ( expression )* )
        {
            COORDINATE74 = (pANTLR3_BASE_TREE) MATCHT(COORDINATE, &FOLLOW_COORDINATE_in_coordinateExpression1831);
            if  (HASEXCEPTION())
            {
                goto rulecoordinateExpressionEx;
            }


            if ( LA(1)==ANTLR3_TOKEN_DOWN ) {
                MATCHT(ANTLR3_TOKEN_DOWN, NULL);
                if  (HASEXCEPTION())
                {
                    goto rulecoordinateExpressionEx;
                }

                // C:\\Users\\matej_000\\Source\\Repos\\geogen\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:755:14: ( expression )*

                for (;;)
                {
                    int alt27=2;
                    switch ( LA(1) )
                    {
                    case COLLECTION:
                    case COORDINATE:
                    case FALSE_LIT:
                    case IDENTIFIER:
                    case LEFT_BRACKET:
                    case LEFT_SQUARE_BRACKET:
                    case NUMBER:
                    case OPERATOR_ASSIGN:
                    case OPERATOR_ASSIGN_AND:
                    case OPERATOR_ASSIGN_DIVIDE:
                    case OPERATOR_ASSIGN_LSHIFT:
                    case OPERATOR_ASSIGN_MINUS:
                    case OPERATOR_ASSIGN_MODULO:
                    case OPERATOR_ASSIGN_OR:
                    case OPERATOR_ASSIGN_PLUS:
                    case OPERATOR_ASSIGN_RSHIFT:
                    case OPERATOR_ASSIGN_TIMES:
                    case OPERATOR_BIT_AND:
                    case OPERATOR_BIT_OR:
                    case OPERATOR_BIT_XOR:
                    case OPERATOR_DECREMENT_POST:
                    case OPERATOR_DECREMENT_PRE:
                    case OPERATOR_DIVIDE:
                    case OPERATOR_DOT:
                    case OPERATOR_EQUAL_TO:
                    case OPERATOR_EXPR_IF:
                    case OPERATOR_GREATER_THAN:
                    case OPERATOR_GREATER_THAN_OR_EQUAL_TO:
                    case OPERATOR_INCREMENT_POST:
                    case OPERATOR_INCREMENT_PRE:
                    case OPERATOR_IS:
                    case OPERATOR_LESS_THAN:
                    case OPERATOR_LESS_THAN_OR_EQUAL_TO:
                    case OPERATOR_LSHIFT:
                    case OPERATOR_MINUS:
                    case OPERATOR_MINUS_UN:
                    case OPERATOR_MODULO:
                    case OPERATOR_NOT:
                    case OPERATOR_NOT_EQUAL_TO:
                    case OPERATOR_PLUS:
                    case OPERATOR_PLUS_UN:
                    case OPERATOR_RELATIVE:
                    case OPERATOR_REL_AND:
                    case OPERATOR_REL_OR:
                    case OPERATOR_RSHIFT:
                    case OPERATOR_TIMES:
                    case STRING:
                    case TRUE_LIT:
                    	{
                    		alt27=1;
                    	}
                        break;

                    }

                    switch (alt27)
                    {
                	case 1:
                	    // C:\\Users\\matej_000\\Source\\Repos\\geogen\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:755:15: expression
                	    {
                	        FOLLOWPUSH(FOLLOW_expression_in_coordinateExpression1834);
                	        expression73=expression(ctx);

                	        FOLLOWPOP();
                	        if  (HASEXCEPTION())
                	        {
                	            goto rulecoordinateExpressionEx;
                	        }


                	        {
                	             argumentCodeBlocks.push_back(expression73.returnCodeBlock
                	            ); if(expression73.refCodeBlock
                	             != NULL) delete expression73.refCodeBlock
                	            ; 
                	        }


                	    }
                	    break;

                	default:
                	    goto loop27;	/* break out of the loop */
                	    break;
                    }
                }
                loop27: ; /* Jump out to here if this rule does not match */


                MATCHT(ANTLR3_TOKEN_UP, NULL);
                if  (HASEXCEPTION())
                {
                    goto rulecoordinateExpressionEx;
                }

            }


            {

                	CodeLocation location((COORDINATE74->getLine(COORDINATE74)), (COORDINATE74->getCharPositionInLine(COORDINATE74)));
                		// The arguments are stored on the stack in reverse order.
                	for(int i = 0; i < argumentCodeBlocks.size(); i++)
                	{
                		
                returnCodeBlock
                ->MoveInstructionsFrom(*argumentCodeBlocks[i]); 
                		delete argumentCodeBlocks[i]; 
                	}
                	
                	if(argumentCodeBlocks.size() < 1 || argumentCodeBlocks.size() > 2)
                	{
                		throw InternalErrorException(GG_STR("Incorrect number of arguments in coordinate literal."));
                	}
                	
                	if(argumentCodeBlocks.size() == 1){
                		returnCodeBlock
                ->AddInstruction(new instructions::LoadScopeValueInstruction(location, GG_STR("Coordinate")));	
                		returnCodeBlock
                ->AddInstruction(new instructions::CallMemberInstruction(location, GG_STR("FromNumber"), argumentCodeBlocks.size()));	
                	}
                	else if(argumentCodeBlocks.size() == 2){
                		returnCodeBlock
                ->AddInstruction(new instructions::LoadScopeValueInstruction(location, GG_STR("Point")));	
                		returnCodeBlock
                ->AddInstruction(new instructions::CallMemberInstruction(location, GG_STR("Create"), argumentCodeBlocks.size()));	
                	}
                	

            }


        }

    }

    // This is where rules clean up and exit
    //
    goto rulecoordinateExpressionEx; /* Prevent compiler warnings */
    rulecoordinateExpressionEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return returnCodeBlock;
}
/* $ANTLR end coordinateExpression */

/**
 * $ANTLR start callExpression
 * C:\\Users\\matej_000\\Source\\Repos\\geogen\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:781:1: callExpression returns [CodeBlock* returnCodeBlock] : ( ^( LEFT_BRACKET IDENTIFIER ( expression )* ) | ^( LEFT_BRACKET ^( OPERATOR_DOT e1= expression IDENTIFIER ) (e2= expression )* ) );
 */
static CodeBlock*
callExpression(pGeoGenScriptDecls ctx)
{
    CodeBlock* returnCodeBlock;


    pANTLR3_BASE_TREE    IDENTIFIER76;
    pANTLR3_BASE_TREE    IDENTIFIER77;
    GeoGenScriptDecls_expression_return e1;
    #undef	RETURN_TYPE_e1
    #define	RETURN_TYPE_e1 GeoGenScriptDecls_expression_return

    GeoGenScriptDecls_expression_return e2;
    #undef	RETURN_TYPE_e2
    #define	RETURN_TYPE_e2 GeoGenScriptDecls_expression_return

    GeoGenScriptDecls_expression_return expression75;
    #undef	RETURN_TYPE_expression75
    #define	RETURN_TYPE_expression75 GeoGenScriptDecls_expression_return

    /* Initialize rule variables
     */

     returnCodeBlock= new CodeBlock();
     std::vector<CodeBlock*> argumentCodeBlocks; 
    IDENTIFIER76       = NULL;
    IDENTIFIER77       = NULL;

    {
        {
            //  C:\\Users\\matej_000\\Source\\Repos\\geogen\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:783:3: ( ^( LEFT_BRACKET IDENTIFIER ( expression )* ) | ^( LEFT_BRACKET ^( OPERATOR_DOT e1= expression IDENTIFIER ) (e2= expression )* ) )

            ANTLR3_UINT32 alt30;

            alt30=2;

            switch ( LA(1) )
            {
            case LEFT_BRACKET:
            	{
            		switch ( LA(2) )
            		{
            		case DOWN:
            			{
            				switch ( LA(3) )
            				{
            				case IDENTIFIER:
            					{
            						alt30=1;
            					}
            				    break;
            				case OPERATOR_DOT:
            					{
            						alt30=2;
            					}
            				    break;

            				default:
            				    CONSTRUCTEX();
            				    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            				    EXCEPTION->message      = (void *)"";
            				    EXCEPTION->decisionNum  = 30;
            				    EXCEPTION->state        = 2;


            				    goto rulecallExpressionEx;

            				}

            			}
            		    break;

            		default:
            		    CONSTRUCTEX();
            		    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            		    EXCEPTION->message      = (void *)"";
            		    EXCEPTION->decisionNum  = 30;
            		    EXCEPTION->state        = 1;


            		    goto rulecallExpressionEx;

            		}

            	}
                break;

            default:
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 30;
                EXCEPTION->state        = 0;


                goto rulecallExpressionEx;

            }

            switch (alt30)
            {
        	case 1:
        	    // C:\\Users\\matej_000\\Source\\Repos\\geogen\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:784:3: ^( LEFT_BRACKET IDENTIFIER ( expression )* )
        	    {
        	         MATCHT(LEFT_BRACKET, &FOLLOW_LEFT_BRACKET_in_callExpression1862);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulecallExpressionEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_DOWN, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulecallExpressionEx;
        	        }

        	        IDENTIFIER76 = (pANTLR3_BASE_TREE) MATCHT(IDENTIFIER, &FOLLOW_IDENTIFIER_in_callExpression1864);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulecallExpressionEx;
        	        }


        	        // C:\\Users\\matej_000\\Source\\Repos\\geogen\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:784:27: ( expression )*

        	        for (;;)
        	        {
        	            int alt28=2;
        	            switch ( LA(1) )
        	            {
        	            case COLLECTION:
        	            case COORDINATE:
        	            case FALSE_LIT:
        	            case IDENTIFIER:
        	            case LEFT_BRACKET:
        	            case LEFT_SQUARE_BRACKET:
        	            case NUMBER:
        	            case OPERATOR_ASSIGN:
        	            case OPERATOR_ASSIGN_AND:
        	            case OPERATOR_ASSIGN_DIVIDE:
        	            case OPERATOR_ASSIGN_LSHIFT:
        	            case OPERATOR_ASSIGN_MINUS:
        	            case OPERATOR_ASSIGN_MODULO:
        	            case OPERATOR_ASSIGN_OR:
        	            case OPERATOR_ASSIGN_PLUS:
        	            case OPERATOR_ASSIGN_RSHIFT:
        	            case OPERATOR_ASSIGN_TIMES:
        	            case OPERATOR_BIT_AND:
        	            case OPERATOR_BIT_OR:
        	            case OPERATOR_BIT_XOR:
        	            case OPERATOR_DECREMENT_POST:
        	            case OPERATOR_DECREMENT_PRE:
        	            case OPERATOR_DIVIDE:
        	            case OPERATOR_DOT:
        	            case OPERATOR_EQUAL_TO:
        	            case OPERATOR_EXPR_IF:
        	            case OPERATOR_GREATER_THAN:
        	            case OPERATOR_GREATER_THAN_OR_EQUAL_TO:
        	            case OPERATOR_INCREMENT_POST:
        	            case OPERATOR_INCREMENT_PRE:
        	            case OPERATOR_IS:
        	            case OPERATOR_LESS_THAN:
        	            case OPERATOR_LESS_THAN_OR_EQUAL_TO:
        	            case OPERATOR_LSHIFT:
        	            case OPERATOR_MINUS:
        	            case OPERATOR_MINUS_UN:
        	            case OPERATOR_MODULO:
        	            case OPERATOR_NOT:
        	            case OPERATOR_NOT_EQUAL_TO:
        	            case OPERATOR_PLUS:
        	            case OPERATOR_PLUS_UN:
        	            case OPERATOR_RELATIVE:
        	            case OPERATOR_REL_AND:
        	            case OPERATOR_REL_OR:
        	            case OPERATOR_RSHIFT:
        	            case OPERATOR_TIMES:
        	            case STRING:
        	            case TRUE_LIT:
        	            	{
        	            		alt28=1;
        	            	}
        	                break;

        	            }

        	            switch (alt28)
        	            {
        	        	case 1:
        	        	    // C:\\Users\\matej_000\\Source\\Repos\\geogen\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:784:28: expression
        	        	    {
        	        	        FOLLOWPUSH(FOLLOW_expression_in_callExpression1867);
        	        	        expression75=expression(ctx);

        	        	        FOLLOWPOP();
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto rulecallExpressionEx;
        	        	        }


        	        	        {
        	        	             argumentCodeBlocks.push_back(expression75.returnCodeBlock
        	        	            ); 
        	        	        }


        	        	    }
        	        	    break;

        	        	default:
        	        	    goto loop28;	/* break out of the loop */
        	        	    break;
        	            }
        	        }
        	        loop28: ; /* Jump out to here if this rule does not match */


        	        MATCHT(ANTLR3_TOKEN_UP, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulecallExpressionEx;
        	        }



        	        {

        	            	CodeLocation location((IDENTIFIER76->getLine(IDENTIFIER76)), (IDENTIFIER76->getCharPositionInLine(IDENTIFIER76)));

        	            	std::reverse(argumentCodeBlocks.begin(), argumentCodeBlocks.end());

        	            	// The arguments are stored on the stack in reverse order.
        	            	for(int i = argumentCodeBlocks.size() - 1; i >= 0; i--)
        	            	{
        	            		
        	            returnCodeBlock
        	            ->MoveInstructionsFrom(*argumentCodeBlocks[i]); 
        	            		delete argumentCodeBlocks[i]; 
        	            	}

        	            	returnCodeBlock
        	            ->AddInstruction(new instructions::CallGlobalInstruction(location, (Char*)(IDENTIFIER76->getText(IDENTIFIER76))->chars, argumentCodeBlocks.size()));

        	        }


        	    }
        	    break;
        	case 2:
        	    // C:\\Users\\matej_000\\Source\\Repos\\geogen\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:800:3: ^( LEFT_BRACKET ^( OPERATOR_DOT e1= expression IDENTIFIER ) (e2= expression )* )
        	    {
        	         MATCHT(LEFT_BRACKET, &FOLLOW_LEFT_BRACKET_in_callExpression1882);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulecallExpressionEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_DOWN, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulecallExpressionEx;
        	        }

        	         MATCHT(OPERATOR_DOT, &FOLLOW_OPERATOR_DOT_in_callExpression1885);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulecallExpressionEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_DOWN, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulecallExpressionEx;
        	        }

        	        FOLLOWPUSH(FOLLOW_expression_in_callExpression1889);
        	        e1=expression(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulecallExpressionEx;
        	        }


        	        IDENTIFIER77 = (pANTLR3_BASE_TREE) MATCHT(IDENTIFIER, &FOLLOW_IDENTIFIER_in_callExpression1891);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulecallExpressionEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_UP, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulecallExpressionEx;
        	        }



        	        // C:\\Users\\matej_000\\Source\\Repos\\geogen\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:800:57: (e2= expression )*

        	        for (;;)
        	        {
        	            int alt29=2;
        	            switch ( LA(1) )
        	            {
        	            case COLLECTION:
        	            case COORDINATE:
        	            case FALSE_LIT:
        	            case IDENTIFIER:
        	            case LEFT_BRACKET:
        	            case LEFT_SQUARE_BRACKET:
        	            case NUMBER:
        	            case OPERATOR_ASSIGN:
        	            case OPERATOR_ASSIGN_AND:
        	            case OPERATOR_ASSIGN_DIVIDE:
        	            case OPERATOR_ASSIGN_LSHIFT:
        	            case OPERATOR_ASSIGN_MINUS:
        	            case OPERATOR_ASSIGN_MODULO:
        	            case OPERATOR_ASSIGN_OR:
        	            case OPERATOR_ASSIGN_PLUS:
        	            case OPERATOR_ASSIGN_RSHIFT:
        	            case OPERATOR_ASSIGN_TIMES:
        	            case OPERATOR_BIT_AND:
        	            case OPERATOR_BIT_OR:
        	            case OPERATOR_BIT_XOR:
        	            case OPERATOR_DECREMENT_POST:
        	            case OPERATOR_DECREMENT_PRE:
        	            case OPERATOR_DIVIDE:
        	            case OPERATOR_DOT:
        	            case OPERATOR_EQUAL_TO:
        	            case OPERATOR_EXPR_IF:
        	            case OPERATOR_GREATER_THAN:
        	            case OPERATOR_GREATER_THAN_OR_EQUAL_TO:
        	            case OPERATOR_INCREMENT_POST:
        	            case OPERATOR_INCREMENT_PRE:
        	            case OPERATOR_IS:
        	            case OPERATOR_LESS_THAN:
        	            case OPERATOR_LESS_THAN_OR_EQUAL_TO:
        	            case OPERATOR_LSHIFT:
        	            case OPERATOR_MINUS:
        	            case OPERATOR_MINUS_UN:
        	            case OPERATOR_MODULO:
        	            case OPERATOR_NOT:
        	            case OPERATOR_NOT_EQUAL_TO:
        	            case OPERATOR_PLUS:
        	            case OPERATOR_PLUS_UN:
        	            case OPERATOR_RELATIVE:
        	            case OPERATOR_REL_AND:
        	            case OPERATOR_REL_OR:
        	            case OPERATOR_RSHIFT:
        	            case OPERATOR_TIMES:
        	            case STRING:
        	            case TRUE_LIT:
        	            	{
        	            		alt29=1;
        	            	}
        	                break;

        	            }

        	            switch (alt29)
        	            {
        	        	case 1:
        	        	    // C:\\Users\\matej_000\\Source\\Repos\\geogen\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:800:58: e2= expression
        	        	    {
        	        	        FOLLOWPUSH(FOLLOW_expression_in_callExpression1897);
        	        	        e2=expression(ctx);

        	        	        FOLLOWPOP();
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto rulecallExpressionEx;
        	        	        }


        	        	        {
        	        	             argumentCodeBlocks.push_back(e2.returnCodeBlock
        	        	            );if(e2.refCodeBlock
        	        	             != NULL) delete e2.refCodeBlock
        	        	            ; 
        	        	        }


        	        	    }
        	        	    break;

        	        	default:
        	        	    goto loop29;	/* break out of the loop */
        	        	    break;
        	            }
        	        }
        	        loop29: ; /* Jump out to here if this rule does not match */


        	        MATCHT(ANTLR3_TOKEN_UP, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulecallExpressionEx;
        	        }



        	        {

        	            	CodeLocation location((IDENTIFIER77->getLine(IDENTIFIER77)), (IDENTIFIER77->getCharPositionInLine(IDENTIFIER77)));

        	            	std::reverse(argumentCodeBlocks.begin(), argumentCodeBlocks.end());

        	            	// The arguments are stored on the stack in reverse order.
        	            	for(int i = argumentCodeBlocks.size() - 1; i >= 0; i--)
        	            	{
        	            		
        	            returnCodeBlock
        	            ->MoveInstructionsFrom(*argumentCodeBlocks[i]); delete argumentCodeBlocks[i]; 
        	            	}

        	            	returnCodeBlock
        	            ->MoveInstructionsFrom(*e1.returnCodeBlock
        	            ); 
        	            	delete e1.returnCodeBlock
        	            ; 
        	            	if(e1.refCodeBlock
        	             != NULL) delete e1.refCodeBlock
        	            ;
        	            	
        	            	returnCodeBlock
        	            ->AddInstruction(new instructions::CallMemberInstruction(location, (Char*)(IDENTIFIER77->getText(IDENTIFIER77))->chars, argumentCodeBlocks.size()));

        	        }


        	    }
        	    break;

            }
        }
    }

    // This is where rules clean up and exit
    //
    goto rulecallExpressionEx; /* Prevent compiler warnings */
    rulecallExpressionEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return returnCodeBlock;
}
/* $ANTLR end callExpression */

/**
 * $ANTLR start indexAccessExpression
 * C:\\Users\\matej_000\\Source\\Repos\\geogen\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:820:1: indexAccessExpression returns [CodeBlock* returnCodeBlock, CodeBlock* refCodeBlock] : ^( LEFT_SQUARE_BRACKET e1= expression (e2= expression )* ) ;
 */
static GeoGenScriptDecls_indexAccessExpression_return
indexAccessExpression(pGeoGenScriptDecls ctx)
{
    GeoGenScriptDecls_indexAccessExpression_return retval;


    pANTLR3_BASE_TREE    LEFT_SQUARE_BRACKET78;
    GeoGenScriptDecls_expression_return e1;
    #undef	RETURN_TYPE_e1
    #define	RETURN_TYPE_e1 GeoGenScriptDecls_expression_return

    GeoGenScriptDecls_expression_return e2;
    #undef	RETURN_TYPE_e2
    #define	RETURN_TYPE_e2 GeoGenScriptDecls_expression_return

    /* Initialize rule variables
     */

     retval.returnCodeBlock= new CodeBlock();
     retval.refCodeBlock= new CodeBlock();
     std::vector<CodeBlock*> argumentCodeBlocks; 
    LEFT_SQUARE_BRACKET78       = NULL;
    retval.start = LT(1); retval.stop = retval.start;


    {
        // C:\\Users\\matej_000\\Source\\Repos\\geogen\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:822:3: ( ^( LEFT_SQUARE_BRACKET e1= expression (e2= expression )* ) )
        // C:\\Users\\matej_000\\Source\\Repos\\geogen\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:823:3: ^( LEFT_SQUARE_BRACKET e1= expression (e2= expression )* )
        {
            LEFT_SQUARE_BRACKET78 = (pANTLR3_BASE_TREE) MATCHT(LEFT_SQUARE_BRACKET, &FOLLOW_LEFT_SQUARE_BRACKET_in_indexAccessExpression1926);
            if  (HASEXCEPTION())
            {
                goto ruleindexAccessExpressionEx;
            }


            MATCHT(ANTLR3_TOKEN_DOWN, NULL);
            if  (HASEXCEPTION())
            {
                goto ruleindexAccessExpressionEx;
            }

            FOLLOWPUSH(FOLLOW_expression_in_indexAccessExpression1930);
            e1=expression(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleindexAccessExpressionEx;
            }


            // C:\\Users\\matej_000\\Source\\Repos\\geogen\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:823:37: (e2= expression )*

            for (;;)
            {
                int alt31=2;
                switch ( LA(1) )
                {
                case COLLECTION:
                case COORDINATE:
                case FALSE_LIT:
                case IDENTIFIER:
                case LEFT_BRACKET:
                case LEFT_SQUARE_BRACKET:
                case NUMBER:
                case OPERATOR_ASSIGN:
                case OPERATOR_ASSIGN_AND:
                case OPERATOR_ASSIGN_DIVIDE:
                case OPERATOR_ASSIGN_LSHIFT:
                case OPERATOR_ASSIGN_MINUS:
                case OPERATOR_ASSIGN_MODULO:
                case OPERATOR_ASSIGN_OR:
                case OPERATOR_ASSIGN_PLUS:
                case OPERATOR_ASSIGN_RSHIFT:
                case OPERATOR_ASSIGN_TIMES:
                case OPERATOR_BIT_AND:
                case OPERATOR_BIT_OR:
                case OPERATOR_BIT_XOR:
                case OPERATOR_DECREMENT_POST:
                case OPERATOR_DECREMENT_PRE:
                case OPERATOR_DIVIDE:
                case OPERATOR_DOT:
                case OPERATOR_EQUAL_TO:
                case OPERATOR_EXPR_IF:
                case OPERATOR_GREATER_THAN:
                case OPERATOR_GREATER_THAN_OR_EQUAL_TO:
                case OPERATOR_INCREMENT_POST:
                case OPERATOR_INCREMENT_PRE:
                case OPERATOR_IS:
                case OPERATOR_LESS_THAN:
                case OPERATOR_LESS_THAN_OR_EQUAL_TO:
                case OPERATOR_LSHIFT:
                case OPERATOR_MINUS:
                case OPERATOR_MINUS_UN:
                case OPERATOR_MODULO:
                case OPERATOR_NOT:
                case OPERATOR_NOT_EQUAL_TO:
                case OPERATOR_PLUS:
                case OPERATOR_PLUS_UN:
                case OPERATOR_RELATIVE:
                case OPERATOR_REL_AND:
                case OPERATOR_REL_OR:
                case OPERATOR_RSHIFT:
                case OPERATOR_TIMES:
                case STRING:
                case TRUE_LIT:
                	{
                		alt31=1;
                	}
                    break;

                }

                switch (alt31)
                {
            	case 1:
            	    // C:\\Users\\matej_000\\Source\\Repos\\geogen\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:823:38: e2= expression
            	    {
            	        FOLLOWPUSH(FOLLOW_expression_in_indexAccessExpression1935);
            	        e2=expression(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleindexAccessExpressionEx;
            	        }


            	        {
            	             argumentCodeBlocks.push_back(e2.returnCodeBlock
            	            ); if(e2.refCodeBlock
            	             != NULL) delete e2.refCodeBlock
            	            ; 
            	        }


            	    }
            	    break;

            	default:
            	    goto loop31;	/* break out of the loop */
            	    break;
                }
            }
            loop31: ; /* Jump out to here if this rule does not match */


            MATCHT(ANTLR3_TOKEN_UP, NULL);
            if  (HASEXCEPTION())
            {
                goto ruleindexAccessExpressionEx;
            }



            {

                	CodeLocation location((LEFT_SQUARE_BRACKET78->getLine(LEFT_SQUARE_BRACKET78)), (LEFT_SQUARE_BRACKET78->getCharPositionInLine(LEFT_SQUARE_BRACKET78)));

                	// The arguments are stored on the stack in reverse order.
                	for(int i = argumentCodeBlocks.size() - 1; i >= 0; i--)
                	{
                		CodeBlock clone(*argumentCodeBlocks[i]);
                		
                retval.refCodeBlock
                ->MoveInstructionsFrom(clone); 
                	
                		retval.returnCodeBlock
                ->MoveInstructionsFrom(*argumentCodeBlocks[i]); delete argumentCodeBlocks[i]; 
                	}

                	CodeBlock clone(*e1.returnCodeBlock
                );
                	retval.refCodeBlock
                ->MoveInstructionsFrom(clone); 
                	
                	retval.returnCodeBlock
                ->MoveInstructionsFrom(*e1.returnCodeBlock
                ); 
                	delete e1.returnCodeBlock
                ; 
                	if(e1.refCodeBlock
                 != NULL) delete e1.refCodeBlock
                ;
                	
                	retval.returnCodeBlock
                ->AddInstruction(new instructions::CallMemberInstruction(location, GG_STR("[]"), argumentCodeBlocks.size()));
                	retval.refCodeBlock
                ->AddInstruction(new instructions::CallMemberInstruction(location, GG_STR("[]ref"), argumentCodeBlocks.size()));

            }


        }

    }

    // This is where rules clean up and exit
    //
    goto ruleindexAccessExpressionEx; /* Prevent compiler warnings */
    ruleindexAccessExpressionEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return retval;
}
/* $ANTLR end indexAccessExpression */

/**
 * $ANTLR start conditionalOperatorExpression
 * C:\\Users\\matej_000\\Source\\Repos\\geogen\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:847:1: conditionalOperatorExpression returns [CodeBlock* returnCodeBlock] : ^( OPERATOR_EXPR_IF conditionExpression= expression ifExpression= expression elseExpression= expression ) ;
 */
static CodeBlock*
conditionalOperatorExpression(pGeoGenScriptDecls ctx)
{
    CodeBlock* returnCodeBlock;


    pANTLR3_BASE_TREE    OPERATOR_EXPR_IF79;
    GeoGenScriptDecls_expression_return conditionExpression;
    #undef	RETURN_TYPE_conditionExpression
    #define	RETURN_TYPE_conditionExpression GeoGenScriptDecls_expression_return

    GeoGenScriptDecls_expression_return ifExpression;
    #undef	RETURN_TYPE_ifExpression
    #define	RETURN_TYPE_ifExpression GeoGenScriptDecls_expression_return

    GeoGenScriptDecls_expression_return elseExpression;
    #undef	RETURN_TYPE_elseExpression
    #define	RETURN_TYPE_elseExpression GeoGenScriptDecls_expression_return

    /* Initialize rule variables
     */

     returnCodeBlock= new CodeBlock();
     
    OPERATOR_EXPR_IF79       = NULL;

    {
        // C:\\Users\\matej_000\\Source\\Repos\\geogen\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:849:3: ( ^( OPERATOR_EXPR_IF conditionExpression= expression ifExpression= expression elseExpression= expression ) )
        // C:\\Users\\matej_000\\Source\\Repos\\geogen\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:850:3: ^( OPERATOR_EXPR_IF conditionExpression= expression ifExpression= expression elseExpression= expression )
        {
            OPERATOR_EXPR_IF79 = (pANTLR3_BASE_TREE) MATCHT(OPERATOR_EXPR_IF, &FOLLOW_OPERATOR_EXPR_IF_in_conditionalOperatorExpression1963);
            if  (HASEXCEPTION())
            {
                goto ruleconditionalOperatorExpressionEx;
            }


            MATCHT(ANTLR3_TOKEN_DOWN, NULL);
            if  (HASEXCEPTION())
            {
                goto ruleconditionalOperatorExpressionEx;
            }

            FOLLOWPUSH(FOLLOW_expression_in_conditionalOperatorExpression1967);
            conditionExpression=expression(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleconditionalOperatorExpressionEx;
            }


            FOLLOWPUSH(FOLLOW_expression_in_conditionalOperatorExpression1971);
            ifExpression=expression(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleconditionalOperatorExpressionEx;
            }


            FOLLOWPUSH(FOLLOW_expression_in_conditionalOperatorExpression1975);
            elseExpression=expression(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleconditionalOperatorExpressionEx;
            }


            MATCHT(ANTLR3_TOKEN_UP, NULL);
            if  (HASEXCEPTION())
            {
                goto ruleconditionalOperatorExpressionEx;
            }



            {

                	CodeLocation location((OPERATOR_EXPR_IF79->getLine(OPERATOR_EXPR_IF79)), (OPERATOR_EXPR_IF79->getCharPositionInLine(OPERATOR_EXPR_IF79)));

                	
                returnCodeBlock
                ->MoveInstructionsFrom(*conditionExpression.returnCodeBlock
                );
                	delete conditionExpression.returnCodeBlock
                ;
                	if(conditionExpression.refCodeBlock
                 != NULL) delete conditionExpression.refCodeBlock
                ;

                	instructions::IfInstruction* ifInstruction = new instructions::IfInstruction(location);
                	
                	ifInstruction->GetIfBranchCodeBlock().MoveInstructionsFrom(*ifExpression.returnCodeBlock
                );
                	delete ifExpression.returnCodeBlock
                ;
                	if(ifExpression.refCodeBlock
                 != NULL) delete ifExpression.refCodeBlock
                ;

                	ifInstruction->GetElseBranchCodeBlock().MoveInstructionsFrom(*elseExpression.returnCodeBlock
                );
                	delete elseExpression.returnCodeBlock
                ;
                	if(elseExpression.refCodeBlock
                 != NULL) delete elseExpression.refCodeBlock
                ;
                	
                	returnCodeBlock
                ->AddInstruction(ifInstruction);

            }


        }

    }

    // This is where rules clean up and exit
    //
    goto ruleconditionalOperatorExpressionEx; /* Prevent compiler warnings */
    ruleconditionalOperatorExpressionEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return returnCodeBlock;
}
/* $ANTLR end conditionalOperatorExpression */

/**
 * $ANTLR start lvalueExpression
 * C:\\Users\\matej_000\\Source\\Repos\\geogen\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:872:1: lvalueExpression returns [CodeBlock* returnCodeBlock] : ( IDENTIFIER | ^( OPERATOR_DOT e1= expression IDENTIFIER ) | lvalueIndexAccessExpression );
 */
static CodeBlock*
lvalueExpression(pGeoGenScriptDecls ctx)
{
    CodeBlock* returnCodeBlock;


    pANTLR3_BASE_TREE    IDENTIFIER80;
    pANTLR3_BASE_TREE    OPERATOR_DOT81;
    pANTLR3_BASE_TREE    IDENTIFIER82;
    GeoGenScriptDecls_expression_return e1;
    #undef	RETURN_TYPE_e1
    #define	RETURN_TYPE_e1 GeoGenScriptDecls_expression_return

    CodeBlock* lvalueIndexAccessExpression83;
    #undef	RETURN_TYPE_lvalueIndexAccessExpression83
    #define	RETURN_TYPE_lvalueIndexAccessExpression83 CodeBlock*

    /* Initialize rule variables
     */

     returnCodeBlock= new CodeBlock();

    IDENTIFIER80       = NULL;
    OPERATOR_DOT81       = NULL;
    IDENTIFIER82       = NULL;

    {
        {
            //  C:\\Users\\matej_000\\Source\\Repos\\geogen\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:874:2: ( IDENTIFIER | ^( OPERATOR_DOT e1= expression IDENTIFIER ) | lvalueIndexAccessExpression )

            ANTLR3_UINT32 alt32;

            alt32=3;

            switch ( LA(1) )
            {
            case IDENTIFIER:
            	{
            		alt32=1;
            	}
                break;
            case OPERATOR_DOT:
            	{
            		alt32=2;
            	}
                break;
            case LEFT_SQUARE_BRACKET:
            	{
            		alt32=3;
            	}
                break;

            default:
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 32;
                EXCEPTION->state        = 0;


                goto rulelvalueExpressionEx;

            }

            switch (alt32)
            {
        	case 1:
        	    // C:\\Users\\matej_000\\Source\\Repos\\geogen\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:875:2: IDENTIFIER
        	    {
        	        IDENTIFIER80 = (pANTLR3_BASE_TREE) MATCHT(IDENTIFIER, &FOLLOW_IDENTIFIER_in_lvalueExpression1998);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulelvalueExpressionEx;
        	        }


        	        {
        	             
        	            		CodeLocation location((IDENTIFIER80->getLine(IDENTIFIER80)), (IDENTIFIER80->getCharPositionInLine(IDENTIFIER80)));
        	            		
        	            returnCodeBlock
        	            ->AddInstruction(new instructions::StoreScopeValueInstruction(location, (Char*)(IDENTIFIER80->getText(IDENTIFIER80))->chars));  
        	            	
        	        }


        	    }
        	    break;
        	case 2:
        	    // C:\\Users\\matej_000\\Source\\Repos\\geogen\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:880:4: ^( OPERATOR_DOT e1= expression IDENTIFIER )
        	    {
        	        OPERATOR_DOT81 = (pANTLR3_BASE_TREE) MATCHT(OPERATOR_DOT, &FOLLOW_OPERATOR_DOT_in_lvalueExpression2008);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulelvalueExpressionEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_DOWN, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulelvalueExpressionEx;
        	        }

        	        FOLLOWPUSH(FOLLOW_expression_in_lvalueExpression2012);
        	        e1=expression(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulelvalueExpressionEx;
        	        }


        	        IDENTIFIER82 = (pANTLR3_BASE_TREE) MATCHT(IDENTIFIER, &FOLLOW_IDENTIFIER_in_lvalueExpression2014);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulelvalueExpressionEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_UP, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulelvalueExpressionEx;
        	        }



        	        {

        	            		CodeLocation location((OPERATOR_DOT81->getLine(OPERATOR_DOT81)), (OPERATOR_DOT81->getCharPositionInLine(OPERATOR_DOT81)));
        	            	
        	            		
        	            returnCodeBlock
        	            ->MoveInstructionsFrom(*e1.returnCodeBlock
        	            ); 
        	            		delete e1.returnCodeBlock
        	            ; 
        	            		if(e1.refCodeBlock
        	             != NULL) delete e1.refCodeBlock
        	            ;
        	            		
        	            		returnCodeBlock
        	            ->AddInstruction(new instructions::StoreMemberValueInstruction(location, (Char*)(IDENTIFIER82->getText(IDENTIFIER82))->chars));
        	            	
        	        }


        	    }
        	    break;
        	case 3:
        	    // C:\\Users\\matej_000\\Source\\Repos\\geogen\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:890:4: lvalueIndexAccessExpression
        	    {
        	        FOLLOWPUSH(FOLLOW_lvalueIndexAccessExpression_in_lvalueExpression2024);
        	        lvalueIndexAccessExpression83=lvalueIndexAccessExpression(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulelvalueExpressionEx;
        	        }


        	        {
        	             
        	            		returnCodeBlock
        	            ->MoveInstructionsFrom(*lvalueIndexAccessExpression83
        	            ); 
        	            		delete lvalueIndexAccessExpression83
        	            ; 
        	            	
        	        }


        	    }
        	    break;

            }
        }
    }

    // This is where rules clean up and exit
    //
    goto rulelvalueExpressionEx; /* Prevent compiler warnings */
    rulelvalueExpressionEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return returnCodeBlock;
}
/* $ANTLR end lvalueExpression */

/**
 * $ANTLR start lvalueIndexAccessExpression
 * C:\\Users\\matej_000\\Source\\Repos\\geogen\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:896:1: lvalueIndexAccessExpression returns [CodeBlock* returnCodeBlock] : ^( LEFT_SQUARE_BRACKET e1= expression (e2= expression )* ) ;
 */
static CodeBlock*
lvalueIndexAccessExpression(pGeoGenScriptDecls ctx)
{
    CodeBlock* returnCodeBlock;


    pANTLR3_BASE_TREE    LEFT_SQUARE_BRACKET84;
    GeoGenScriptDecls_expression_return e1;
    #undef	RETURN_TYPE_e1
    #define	RETURN_TYPE_e1 GeoGenScriptDecls_expression_return

    GeoGenScriptDecls_expression_return e2;
    #undef	RETURN_TYPE_e2
    #define	RETURN_TYPE_e2 GeoGenScriptDecls_expression_return

    /* Initialize rule variables
     */

     returnCodeBlock= new CodeBlock();
     std::vector<CodeBlock*> argumentCodeBlocks; 
    LEFT_SQUARE_BRACKET84       = NULL;

    {
        // C:\\Users\\matej_000\\Source\\Repos\\geogen\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:898:3: ( ^( LEFT_SQUARE_BRACKET e1= expression (e2= expression )* ) )
        // C:\\Users\\matej_000\\Source\\Repos\\geogen\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:899:3: ^( LEFT_SQUARE_BRACKET e1= expression (e2= expression )* )
        {
            LEFT_SQUARE_BRACKET84 = (pANTLR3_BASE_TREE) MATCHT(LEFT_SQUARE_BRACKET, &FOLLOW_LEFT_SQUARE_BRACKET_in_lvalueIndexAccessExpression2050);
            if  (HASEXCEPTION())
            {
                goto rulelvalueIndexAccessExpressionEx;
            }


            MATCHT(ANTLR3_TOKEN_DOWN, NULL);
            if  (HASEXCEPTION())
            {
                goto rulelvalueIndexAccessExpressionEx;
            }

            FOLLOWPUSH(FOLLOW_expression_in_lvalueIndexAccessExpression2054);
            e1=expression(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulelvalueIndexAccessExpressionEx;
            }


            // C:\\Users\\matej_000\\Source\\Repos\\geogen\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:899:37: (e2= expression )*

            for (;;)
            {
                int alt33=2;
                switch ( LA(1) )
                {
                case COLLECTION:
                case COORDINATE:
                case FALSE_LIT:
                case IDENTIFIER:
                case LEFT_BRACKET:
                case LEFT_SQUARE_BRACKET:
                case NUMBER:
                case OPERATOR_ASSIGN:
                case OPERATOR_ASSIGN_AND:
                case OPERATOR_ASSIGN_DIVIDE:
                case OPERATOR_ASSIGN_LSHIFT:
                case OPERATOR_ASSIGN_MINUS:
                case OPERATOR_ASSIGN_MODULO:
                case OPERATOR_ASSIGN_OR:
                case OPERATOR_ASSIGN_PLUS:
                case OPERATOR_ASSIGN_RSHIFT:
                case OPERATOR_ASSIGN_TIMES:
                case OPERATOR_BIT_AND:
                case OPERATOR_BIT_OR:
                case OPERATOR_BIT_XOR:
                case OPERATOR_DECREMENT_POST:
                case OPERATOR_DECREMENT_PRE:
                case OPERATOR_DIVIDE:
                case OPERATOR_DOT:
                case OPERATOR_EQUAL_TO:
                case OPERATOR_EXPR_IF:
                case OPERATOR_GREATER_THAN:
                case OPERATOR_GREATER_THAN_OR_EQUAL_TO:
                case OPERATOR_INCREMENT_POST:
                case OPERATOR_INCREMENT_PRE:
                case OPERATOR_IS:
                case OPERATOR_LESS_THAN:
                case OPERATOR_LESS_THAN_OR_EQUAL_TO:
                case OPERATOR_LSHIFT:
                case OPERATOR_MINUS:
                case OPERATOR_MINUS_UN:
                case OPERATOR_MODULO:
                case OPERATOR_NOT:
                case OPERATOR_NOT_EQUAL_TO:
                case OPERATOR_PLUS:
                case OPERATOR_PLUS_UN:
                case OPERATOR_RELATIVE:
                case OPERATOR_REL_AND:
                case OPERATOR_REL_OR:
                case OPERATOR_RSHIFT:
                case OPERATOR_TIMES:
                case STRING:
                case TRUE_LIT:
                	{
                		alt33=1;
                	}
                    break;

                }

                switch (alt33)
                {
            	case 1:
            	    // C:\\Users\\matej_000\\Source\\Repos\\geogen\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:899:38: e2= expression
            	    {
            	        FOLLOWPUSH(FOLLOW_expression_in_lvalueIndexAccessExpression2059);
            	        e2=expression(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulelvalueIndexAccessExpressionEx;
            	        }


            	        {
            	             argumentCodeBlocks.push_back(e2.returnCodeBlock
            	            ); if(e2.refCodeBlock
            	             != NULL) delete e2.refCodeBlock
            	            ; 
            	        }


            	    }
            	    break;

            	default:
            	    goto loop33;	/* break out of the loop */
            	    break;
                }
            }
            loop33: ; /* Jump out to here if this rule does not match */


            MATCHT(ANTLR3_TOKEN_UP, NULL);
            if  (HASEXCEPTION())
            {
                goto rulelvalueIndexAccessExpressionEx;
            }



            {

                	CodeLocation location((LEFT_SQUARE_BRACKET84->getLine(LEFT_SQUARE_BRACKET84)), (LEFT_SQUARE_BRACKET84->getCharPositionInLine(LEFT_SQUARE_BRACKET84)));

                	// The arguments are stored on the stack in reverse order.
                	for(int i = argumentCodeBlocks.size() - 1; i >= 0; i--)
                	{
                		
                returnCodeBlock
                ->MoveInstructionsFrom(*argumentCodeBlocks[i]); delete argumentCodeBlocks[i]; 
                	}

                	returnCodeBlock
                ->MoveInstructionsFrom(*e1.returnCodeBlock
                ); delete e1.returnCodeBlock
                ; 
                	
                	// +1 for the value being written into the array
                	returnCodeBlock
                ->AddInstruction(new instructions::CallMemberInstruction(location, GG_STR("[]="), argumentCodeBlocks.size() + 1));

            }


        }

    }

    // This is where rules clean up and exit
    //
    goto rulelvalueIndexAccessExpressionEx; /* Prevent compiler warnings */
    rulelvalueIndexAccessExpressionEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return returnCodeBlock;
}
/* $ANTLR end lvalueIndexAccessExpression */

/**
 * $ANTLR start collectionLiteral
 * C:\\Users\\matej_000\\Source\\Repos\\geogen\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:984:1: collectionLiteral returns [CodeBlock* returnCodeBlock] : ^( COLLECTION ( collectionLiteralItem )* ) ;
 */
static CodeBlock*
collectionLiteral(pGeoGenScriptDecls ctx)
{
    CodeBlock* returnCodeBlock;


    pANTLR3_BASE_TREE    COLLECTION86;
    CodeBlock* collectionLiteralItem85;
    #undef	RETURN_TYPE_collectionLiteralItem85
    #define	RETURN_TYPE_collectionLiteralItem85 CodeBlock*

    /* Initialize rule variables
     */

     returnCodeBlock= new CodeBlock();
     unsigned itemCount = 0; 
    COLLECTION86       = NULL;

    {
        // C:\\Users\\matej_000\\Source\\Repos\\geogen\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:985:71: ( ^( COLLECTION ( collectionLiteralItem )* ) )
        // C:\\Users\\matej_000\\Source\\Repos\\geogen\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:986:3: ^( COLLECTION ( collectionLiteralItem )* )
        {
            COLLECTION86 = (pANTLR3_BASE_TREE) MATCHT(COLLECTION, &FOLLOW_COLLECTION_in_collectionLiteral2127);
            if  (HASEXCEPTION())
            {
                goto rulecollectionLiteralEx;
            }


            if ( LA(1)==ANTLR3_TOKEN_DOWN ) {
                MATCHT(ANTLR3_TOKEN_DOWN, NULL);
                if  (HASEXCEPTION())
                {
                    goto rulecollectionLiteralEx;
                }

                // C:\\Users\\matej_000\\Source\\Repos\\geogen\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:986:14: ( collectionLiteralItem )*

                for (;;)
                {
                    int alt34=2;
                    switch ( LA(1) )
                    {
                    case COLLECTION_ITEM:
                    	{
                    		alt34=1;
                    	}
                        break;

                    }

                    switch (alt34)
                    {
                	case 1:
                	    // C:\\Users\\matej_000\\Source\\Repos\\geogen\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:986:15: collectionLiteralItem
                	    {
                	        FOLLOWPUSH(FOLLOW_collectionLiteralItem_in_collectionLiteral2130);
                	        collectionLiteralItem85=collectionLiteralItem(ctx);

                	        FOLLOWPOP();
                	        if  (HASEXCEPTION())
                	        {
                	            goto rulecollectionLiteralEx;
                	        }


                	        {
                	             returnCodeBlock->MoveInstructionsFrom(*collectionLiteralItem85
                	            ); delete collectionLiteralItem85
                	            ; itemCount++; 
                	        }


                	    }
                	    break;

                	default:
                	    goto loop34;	/* break out of the loop */
                	    break;
                    }
                }
                loop34: ; /* Jump out to here if this rule does not match */


                MATCHT(ANTLR3_TOKEN_UP, NULL);
                if  (HASEXCEPTION())
                {
                    goto rulecollectionLiteralEx;
                }

            }


            {

                	CodeLocation location((COLLECTION86->getLine(COLLECTION86)), (COLLECTION86->getCharPositionInLine(COLLECTION86)));	
                	
                returnCodeBlock
                ->AddInstruction(new instructions::LoadScopeValueInstruction(location, GG_STR("Array")));	
                	returnCodeBlock
                ->AddInstruction(new instructions::CallMemberInstruction(location, GG_STR("<FromList>"), itemCount * 2));		

            }


        }

    }

    // This is where rules clean up and exit
    //
    goto rulecollectionLiteralEx; /* Prevent compiler warnings */
    rulecollectionLiteralEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return returnCodeBlock;
}
/* $ANTLR end collectionLiteral */

/**
 * $ANTLR start collectionLiteralItem
 * C:\\Users\\matej_000\\Source\\Repos\\geogen\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:994:1: collectionLiteralItem returns [CodeBlock* returnCodeBlock] : ^( COLLECTION_ITEM e1= expression (e2= expression )? ) ;
 */
static CodeBlock*
collectionLiteralItem(pGeoGenScriptDecls ctx)
{
    CodeBlock* returnCodeBlock;


    pANTLR3_BASE_TREE    COLLECTION_ITEM87;
    GeoGenScriptDecls_expression_return e1;
    #undef	RETURN_TYPE_e1
    #define	RETURN_TYPE_e1 GeoGenScriptDecls_expression_return

    GeoGenScriptDecls_expression_return e2;
    #undef	RETURN_TYPE_e2
    #define	RETURN_TYPE_e2 GeoGenScriptDecls_expression_return

    /* Initialize rule variables
     */

     returnCodeBlock= new CodeBlock();
     bool hasSecond = false; 
    COLLECTION_ITEM87       = NULL;

    {
        // C:\\Users\\matej_000\\Source\\Repos\\geogen\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:995:71: ( ^( COLLECTION_ITEM e1= expression (e2= expression )? ) )
        // C:\\Users\\matej_000\\Source\\Repos\\geogen\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:996:5: ^( COLLECTION_ITEM e1= expression (e2= expression )? )
        {
            COLLECTION_ITEM87 = (pANTLR3_BASE_TREE) MATCHT(COLLECTION_ITEM, &FOLLOW_COLLECTION_ITEM_in_collectionLiteralItem2162);
            if  (HASEXCEPTION())
            {
                goto rulecollectionLiteralItemEx;
            }


            MATCHT(ANTLR3_TOKEN_DOWN, NULL);
            if  (HASEXCEPTION())
            {
                goto rulecollectionLiteralItemEx;
            }

            FOLLOWPUSH(FOLLOW_expression_in_collectionLiteralItem2166);
            e1=expression(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulecollectionLiteralItemEx;
            }


            // C:\\Users\\matej_000\\Source\\Repos\\geogen\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:997:6: (e2= expression )?
            {
                int alt35=2;
                switch ( LA(1) )
                {
                    case COLLECTION:
                    case COORDINATE:
                    case FALSE_LIT:
                    case IDENTIFIER:
                    case LEFT_BRACKET:
                    case LEFT_SQUARE_BRACKET:
                    case NUMBER:
                    case OPERATOR_ASSIGN:
                    case OPERATOR_ASSIGN_AND:
                    case OPERATOR_ASSIGN_DIVIDE:
                    case OPERATOR_ASSIGN_LSHIFT:
                    case OPERATOR_ASSIGN_MINUS:
                    case OPERATOR_ASSIGN_MODULO:
                    case OPERATOR_ASSIGN_OR:
                    case OPERATOR_ASSIGN_PLUS:
                    case OPERATOR_ASSIGN_RSHIFT:
                    case OPERATOR_ASSIGN_TIMES:
                    case OPERATOR_BIT_AND:
                    case OPERATOR_BIT_OR:
                    case OPERATOR_BIT_XOR:
                    case OPERATOR_DECREMENT_POST:
                    case OPERATOR_DECREMENT_PRE:
                    case OPERATOR_DIVIDE:
                    case OPERATOR_DOT:
                    case OPERATOR_EQUAL_TO:
                    case OPERATOR_EXPR_IF:
                    case OPERATOR_GREATER_THAN:
                    case OPERATOR_GREATER_THAN_OR_EQUAL_TO:
                    case OPERATOR_INCREMENT_POST:
                    case OPERATOR_INCREMENT_PRE:
                    case OPERATOR_IS:
                    case OPERATOR_LESS_THAN:
                    case OPERATOR_LESS_THAN_OR_EQUAL_TO:
                    case OPERATOR_LSHIFT:
                    case OPERATOR_MINUS:
                    case OPERATOR_MINUS_UN:
                    case OPERATOR_MODULO:
                    case OPERATOR_NOT:
                    case OPERATOR_NOT_EQUAL_TO:
                    case OPERATOR_PLUS:
                    case OPERATOR_PLUS_UN:
                    case OPERATOR_RELATIVE:
                    case OPERATOR_REL_AND:
                    case OPERATOR_REL_OR:
                    case OPERATOR_RSHIFT:
                    case OPERATOR_TIMES:
                    case STRING:
                    case TRUE_LIT:
                    	{
                    		alt35=1;
                    	}
                        break;
                }

                switch (alt35)
                {
            	case 1:
            	    // C:\\Users\\matej_000\\Source\\Repos\\geogen\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:997:7: e2= expression
            	    {
            	        FOLLOWPUSH(FOLLOW_expression_in_collectionLiteralItem2182);
            	        e2=expression(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulecollectionLiteralItemEx;
            	        }


            	        {
            	             returnCodeBlock->MoveInstructionsFrom(*e2.returnCodeBlock
            	            ); delete e2.returnCodeBlock
            	            ; hasSecond = true; 
            	        }


            	    }
            	    break;

                }
            }

            MATCHT(ANTLR3_TOKEN_UP, NULL);
            if  (HASEXCEPTION())
            {
                goto rulecollectionLiteralItemEx;
            }



            {

                	CodeLocation location((COLLECTION_ITEM87->getLine(COLLECTION_ITEM87)), (COLLECTION_ITEM87->getCharPositionInLine(COLLECTION_ITEM87)));
                    
                	returnCodeBlock->MoveInstructionsFrom(*
                e1.returnCodeBlock
                ); delete e1.returnCodeBlock
                ;
                		
                	if(!hasSecond)
                	{
                		//returnCodeBlock->AddInstruction(new instructions::LoadNullInstruction(location));
                		returnCodeBlock->AddInstruction(new instructions::LoadScopeValueInstruction(location, ArrayTypeDefinition::UNSET_KEY_VARIABLE_NAME));
                	}

                    
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto rulecollectionLiteralItemEx; /* Prevent compiler warnings */
    rulecollectionLiteralItemEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return returnCodeBlock;
}
/* $ANTLR end collectionLiteralItem */

/**
 * $ANTLR start label
 * C:\\Users\\matej_000\\Source\\Repos\\geogen\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:1011:1: label : ( ^( IDENTCHAIN ( IDENTIFIER )+ ) | TRUE_LIT | FALSE_LIT | NUMBER | STRING );
 */
static void
label(pGeoGenScriptDecls ctx)
{
    /* Initialize rule variables
     */

    {
        {
            //  C:\\Users\\matej_000\\Source\\Repos\\geogen\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:1011:6: ( ^( IDENTCHAIN ( IDENTIFIER )+ ) | TRUE_LIT | FALSE_LIT | NUMBER | STRING )

            ANTLR3_UINT32 alt37;

            alt37=5;

            switch ( LA(1) )
            {
            case IDENTCHAIN:
            	{
            		alt37=1;
            	}
                break;
            case TRUE_LIT:
            	{
            		alt37=2;
            	}
                break;
            case FALSE_LIT:
            	{
            		alt37=3;
            	}
                break;
            case NUMBER:
            	{
            		alt37=4;
            	}
                break;
            case STRING:
            	{
            		alt37=5;
            	}
                break;

            default:
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 37;
                EXCEPTION->state        = 0;


                goto rulelabelEx;

            }

            switch (alt37)
            {
        	case 1:
        	    // C:\\Users\\matej_000\\Source\\Repos\\geogen\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:1012:2: ^( IDENTCHAIN ( IDENTIFIER )+ )
        	    {
        	         MATCHT(IDENTCHAIN, &FOLLOW_IDENTCHAIN_in_label2211);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulelabelEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_DOWN, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulelabelEx;
        	        }

        	        // C:\\Users\\matej_000\\Source\\Repos\\geogen\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:1012:15: ( IDENTIFIER )+
        	        {
        	            int cnt36=0;

        	            for (;;)
        	            {
        	                int alt36=2;
        	        	switch ( LA(1) )
        	        	{
        	        	case IDENTIFIER:
        	        		{
        	        			alt36=1;
        	        		}
        	        	    break;

        	        	}

        	        	switch (alt36)
        	        	{
        	        	    case 1:
        	        	        // C:\\Users\\matej_000\\Source\\Repos\\geogen\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:1012:15: IDENTIFIER
        	        	        {
        	        	             MATCHT(IDENTIFIER, &FOLLOW_IDENTIFIER_in_label2213);
        	        	            if  (HASEXCEPTION())
        	        	            {
        	        	                goto rulelabelEx;
        	        	            }


        	        	        }
        	        	        break;

        	        	    default:

        	        		if ( cnt36 >= 1 )
        	        		{
        	        		    goto loop36;
        	        		}
        	        		/* mismatchedSetEx()
        	        		 */
        	        		CONSTRUCTEX();
        	        		EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;
        	        		EXCEPTION->name = (void *)ANTLR3_EARLY_EXIT_NAME;


        	        		goto rulelabelEx;
        	        	}
        	        	cnt36++;
        	            }
        	            loop36: ;	/* Jump to here if this rule does not match */
        	        }

        	        MATCHT(ANTLR3_TOKEN_UP, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulelabelEx;
        	        }



        	    }
        	    break;
        	case 2:
        	    // C:\\Users\\matej_000\\Source\\Repos\\geogen\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:1013:4: TRUE_LIT
        	    {
        	         MATCHT(TRUE_LIT, &FOLLOW_TRUE_LIT_in_label2220);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulelabelEx;
        	        }


        	    }
        	    break;
        	case 3:
        	    // C:\\Users\\matej_000\\Source\\Repos\\geogen\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:1014:11: FALSE_LIT
        	    {
        	         MATCHT(FALSE_LIT, &FOLLOW_FALSE_LIT_in_label2232);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulelabelEx;
        	        }


        	    }
        	    break;
        	case 4:
        	    // C:\\Users\\matej_000\\Source\\Repos\\geogen\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:1015:4: NUMBER
        	    {
        	         MATCHT(NUMBER, &FOLLOW_NUMBER_in_label2237);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulelabelEx;
        	        }


        	    }
        	    break;
        	case 5:
        	    // C:\\Users\\matej_000\\Source\\Repos\\geogen\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:1016:4: STRING
        	    {
        	         MATCHT(STRING, &FOLLOW_STRING_in_label2242);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulelabelEx;
        	        }


        	    }
        	    break;

            }
        }
    }

    // This is where rules clean up and exit
    //
    goto rulelabelEx; /* Prevent compiler warnings */
    rulelabelEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end label */

/**
 * $ANTLR start stringLiteral
 * C:\\Users\\matej_000\\Source\\Repos\\geogen\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:1018:1: stringLiteral returns [String value, int line, int pos] : STRING ;
 */
static GeoGenScriptDecls_stringLiteral_return
stringLiteral(pGeoGenScriptDecls ctx)
{
    GeoGenScriptDecls_stringLiteral_return retval;


    pANTLR3_BASE_TREE    STRING88;

    /* Initialize rule variables
     */

    STRING88       = NULL;
    retval.start = LT(1); retval.stop = retval.start;


    {
        // C:\\Users\\matej_000\\Source\\Repos\\geogen\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:1018:56: ( STRING )
        // C:\\Users\\matej_000\\Source\\Repos\\geogen\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:1019:2: STRING
        {
            STRING88 = (pANTLR3_BASE_TREE) MATCHT(STRING, &FOLLOW_STRING_in_stringLiteral2255);
            if  (HASEXCEPTION())
            {
                goto rulestringLiteralEx;
            }


            {

                	String str = (Char*)(STRING88->getText(STRING88))->chars;
                	
                retval.value= str;
                //str.substr(1, str.length() - 2);
                	retval.line= (STRING88->getLine(STRING88));

                	retval.pos= (STRING88->getCharPositionInLine(STRING88));


            }


        }

    }

    // This is where rules clean up and exit
    //
    goto rulestringLiteralEx; /* Prevent compiler warnings */
    rulestringLiteralEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return retval;
}
/* $ANTLR end stringLiteral */
/* End of parsing rules
 * ==============================================
 */

/* ==============================================
 * Syntactic predicates
 */
/* End of syntactic predicates
 * ==============================================
 */






/* End of code
 * =============================================================================
 */
