/** \file
 *  This C source file was generated by $ANTLR version null
 *
 *     -  From the grammar source file : D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g
 *     -                            On : 2014-04-19 14:32:01
 *     -           for the tree parser : GeoGenScriptDeclsTreeParser
 *
 * Editing it, at least manually, is not wise.
 *
 * C language generator and runtime by Jim Idle, jimi|hereisanat|idle|dotgoeshere|ws.
 *
 *
*/
// [The "BSD license"]
// Copyright (c) 2005-2009 Jim Idle, Temporal Wave LLC
// http://www.temporal-wave.com
// http://www.linkedin.com/in/jimidle
//
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. The name of the author may not be used to endorse or promote products
//    derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

/* -----------------------------------------
 * Include the ANTLR3 generated header file.
 */
#include    "GeoGenScriptDecls.h"
/* ----------------------------------------- */





/* MACROS that hide the C interface implementations from the
 * generated code, which makes it a little more understandable to the human eye.
 * I am very much against using C pre-processor macros for function calls and bits
 * of code as you cannot see what is happening when single stepping in debuggers
 * and so on. The exception (in my book at least) is for generated code, where you are
 * not maintaining it, but may wish to read and understand it. If you single step it, you know that input()
 * hides some indirect calls, but is always referring to the input stream. This is
 * probably more readable than ctx->input->istream->input(snarfle0->blarg) and allows me to rejig
 * the runtime interfaces without changing the generated code too often, without
 * confusing the reader of the generated output, who may not wish to know the gory
 * details of the interface inheritance.
 */

#define		CTX	ctx

/* Aids in accessing scopes for grammar programmers
 */
#undef	SCOPE_TYPE
#undef	SCOPE_STACK
#undef	SCOPE_TOP
#define	SCOPE_TYPE(scope)   pGeoGenScriptDecls_##scope##_SCOPE
#define SCOPE_STACK(scope)  pGeoGenScriptDecls_##scope##Stack
#define	SCOPE_TOP(scope)    ctx->pGeoGenScriptDecls_##scope##Top
#define	SCOPE_SIZE(scope)		ctx->pGeoGenScriptDecls_##scope##Stack_limit
#define SCOPE_INSTANCE(scope, i)	(ctx->SCOPE_STACK(scope)->get(ctx->SCOPE_STACK(scope),i))

/* Macros for accessing things in the parser
 */

#undef	    PARSER
#undef	    RECOGNIZER
#undef	    HAVEPARSEDRULE
#undef	    INPUT
#undef	    STRSTREAM
#undef	    HASEXCEPTION
#undef	    EXCEPTION
#undef	    MATCHT
#undef	    MATCHANYT
#undef	    FOLLOWSTACK
#undef	    FOLLOWPUSH
#undef	    FOLLOWPOP
#undef	    PRECOVER
#undef	    PREPORTERROR
#undef	    LA
#undef	    LT
#undef	    CONSTRUCTEX
#undef	    CONSUME
#undef	    MARK
#undef	    REWIND
#undef	    REWINDLAST
#undef	    PERRORRECOVERY
#undef	    HASFAILED
#undef	    FAILEDFLAG
#undef	    RECOVERFROMMISMATCHEDSET
#undef	    RECOVERFROMMISMATCHEDELEMENT
#undef	    BACKTRACKING
#undef      ADAPTOR
#undef	    RULEMEMO
#undef		SEEK
#undef		INDEX
#undef		DBG

#define	    PARSER							ctx->pTreeParser
#define	    RECOGNIZER						PARSER->rec
#define		PSRSTATE						RECOGNIZER->state
#define	    HAVEPARSEDRULE(r)				RECOGNIZER->alreadyParsedRule(RECOGNIZER, r)
#define	    INPUT							PARSER->ctnstream
#define		ISTREAM							INPUT->tnstream->istream
#define	    STRSTREAM						INPUT->tnstream
#define	    HASEXCEPTION()					(PSRSTATE->error == ANTLR3_TRUE)
#define	    EXCEPTION						PSRSTATE->exception
#define	    MATCHT(t, fs)					RECOGNIZER->match(RECOGNIZER, t, fs)
#define	    MATCHANYT()						RECOGNIZER->matchAny(RECOGNIZER)
#define	    FOLLOWSTACK					    PSRSTATE->following
#define	    FOLLOWPUSH(x)					FOLLOWSTACK->push(FOLLOWSTACK, ((void *)(&(x))), NULL)
#define	    FOLLOWPOP()						FOLLOWSTACK->pop(FOLLOWSTACK)
#define	    PRECOVER()						RECOGNIZER->recover(RECOGNIZER)
#define	    PREPORTERROR()					RECOGNIZER->reportError(RECOGNIZER)
#define	    LA(n)							ISTREAM->_LA(ISTREAM, n)
#define	    LT(n)							INPUT->tnstream->_LT(INPUT->tnstream, n)
#define	    CONSTRUCTEX()					RECOGNIZER->exConstruct(RECOGNIZER)
#define	    CONSUME()						ISTREAM->consume(ISTREAM)
#define	    MARK()							ISTREAM->mark(ISTREAM)
#define	    REWIND(m)						ISTREAM->rewind(ISTREAM, m)
#define	    REWINDLAST()					ISTREAM->rewindLast(ISTREAM)
#define	    PERRORRECOVERY					PSRSTATE->errorRecovery
#define	    FAILEDFLAG						PSRSTATE->failed
#define	    HASFAILED()						(FAILEDFLAG == ANTLR3_TRUE)
#define	    BACKTRACKING					PSRSTATE->backtracking
#define	    RECOVERFROMMISMATCHEDSET(s)		RECOGNIZER->recoverFromMismatchedSet(RECOGNIZER, s)
#define	    RECOVERFROMMISMATCHEDELEMENT(e)	RECOGNIZER->recoverFromMismatchedElement(RECOGNIZER, s)
#define     ADAPTOR                         INPUT->adaptor
#define		RULEMEMO						PSRSTATE->ruleMemo
#define		SEEK(n)							ISTREAM->seek(ISTREAM, n)
#define		INDEX()							ISTREAM->index(ISTREAM)
#define		DBG								RECOGNIZER->debugger



#define		TOKTEXT(tok, txt)				tok, (pANTLR3_UINT8)txt

/* The 4 tokens defined below may well clash with your own #defines or token types. If so
 * then for the present you must use different names for your defines as these are hard coded
 * in the code generator. It would be better not to use such names internally, and maybe
 * we can change this in a forthcoming release. I deliberately do not #undef these
 * here as this will at least give you a redefined error somewhere if they clash.
 */
#define	    UP	    ANTLR3_TOKEN_UP
#define	    DOWN    ANTLR3_TOKEN_DOWN
#define	    EOR	    ANTLR3_TOKEN_EOR
#define	    INVALID ANTLR3_TOKEN_INVALID


/* =============================================================================
 * Functions to create and destroy scopes. First come the rule scopes, followed
 * by the global declared scopes.
 */


/* globalAttributeScopeFuncDecl(scope)
 */
/* -----------------------------------------------------------------------------
 * Function declaration for creating a GeoGenScriptDecls_BlockScope scope set
 */
static pGeoGenScriptDecls_BlockScope_SCOPE   pGeoGenScriptDecls_BlockScopePush(pGeoGenScriptDecls ctx);
static void ANTLR3_CDECL BlockScopeFree(pGeoGenScriptDecls_BlockScope_SCOPE scope);
/* ----------------------------------------------------------------------------- */


/* globalAttributeScopeFuncs(scope)
 */
/* attributeFuncs(scope)
 */

static void ANTLR3_CDECL BlockScopeFree(pGeoGenScriptDecls_BlockScope_SCOPE scope)
{
    ANTLR3_FREE(scope);
}

/** \brief Allocate initial memory for a GeoGenScriptDecls BlockScope scope variable stack entry and
 *         add it to the top of the stack.
 *
 * \remark
 * By default the structure is freed with ANTLR_FREE(), but you can use the
 * the \@init action to install a pointer to a custom free() routine by
 * adding the code:
 * \code
 *   ctx->pGeoGenScriptDecls_BlockScopeTop->free = myroutine;
 * \endcode
 *
 * With lots of comments of course! The routine should be declared in
 * \@members { } as:
 * \code
 *   void ANTLR3_CDECL myfunc( pGeoGenScriptDecls_BlockScope_SCOPE ptr).
 * \endcode
 *
 * It should perform any custom freeing stuff that you need (call ANTLR_FREE3, not free()
 * NB: It should not free the pointer it is given, which is the scope stack entry itself
 * and will be freed by the function that calls your custom free routine.
 *
 */
static pGeoGenScriptDecls_BlockScope_SCOPE
pGeoGenScriptDecls_BlockScopePush(pGeoGenScriptDecls ctx)
{
    /* Pointer used to create a new set of attributes
     */
    pGeoGenScriptDecls_BlockScope_SCOPE      newAttributes;

    /* Allocate the memory for a new structure if we need one.
     */
    if (ctx->pGeoGenScriptDecls_BlockScopeStack->size(ctx->pGeoGenScriptDecls_BlockScopeStack) > ctx->pGeoGenScriptDecls_BlockScopeStack_limit)
    {
        // The current limit value was less than the number of scopes available on the stack so
        // we can just reuse one. Our limit tracks the stack count, so the index of the entry we want
        // is one less than that, or conveniently, the current value of limit.
        //
        newAttributes = (pGeoGenScriptDecls_BlockScope_SCOPE)ctx->pGeoGenScriptDecls_BlockScopeStack->get(ctx->pGeoGenScriptDecls_BlockScopeStack, ctx->pGeoGenScriptDecls_BlockScopeStack_limit);
    }
    else
    {
        // Need a new allocation
        //
        newAttributes = (pGeoGenScriptDecls_BlockScope_SCOPE) ANTLR3_MALLOC(sizeof(GeoGenScriptDecls_BlockScope_SCOPE));
        if  (newAttributes != NULL)
        {
            /* Standard ANTLR3 library implementation
             */
            ctx->pGeoGenScriptDecls_BlockScopeStack->push(ctx->pGeoGenScriptDecls_BlockScopeStack, newAttributes, (void (*)(void *))BlockScopeFree);
        }
    }

    // Blank out any previous free pointer, the user might or might install a new one.
    //
    newAttributes->free = NULL;

    // Indicate the position in the available stack that the current level is at
    //
    ctx->pGeoGenScriptDecls_BlockScopeStack_limit++;

	/* Return value is the pointer to the new entry, which may be used locally
	 * without de-referencing via the context.
     */
    return  newAttributes;
}






/* ============================================================================= */

/* =============================================================================
 * Start of recognizer
 */


/** \brief Table of all token names in symbolic order, mainly used for
 *         error reporting.
 */
pANTLR3_UINT8   GeoGenScriptDeclsTokenNames[91+4]
     = {
        (pANTLR3_UINT8) "<invalid>",       /* String to print to indicate an invalid token */
        (pANTLR3_UINT8) "<EOR>",
        (pANTLR3_UINT8) "<DOWN>",
        (pANTLR3_UINT8) "<UP>",
        (pANTLR3_UINT8) "AS",
        (pANTLR3_UINT8) "BLOCK",
        (pANTLR3_UINT8) "BREAK",
        (pANTLR3_UINT8) "CASE",
        (pANTLR3_UINT8) "COLLECTION",
        (pANTLR3_UINT8) "COLON",
        (pANTLR3_UINT8) "COMMA",
        (pANTLR3_UINT8) "COMMENT",
        (pANTLR3_UINT8) "CONDITION_EXPRESSION",
        (pANTLR3_UINT8) "CONTINUE",
        (pANTLR3_UINT8) "COORDINATE",
        (pANTLR3_UINT8) "DECLARATIONS",
        (pANTLR3_UINT8) "DEFAULT",
        (pANTLR3_UINT8) "ELSE",
        (pANTLR3_UINT8) "ENUM",
        (pANTLR3_UINT8) "ESC_SEQ",
        (pANTLR3_UINT8) "FALSE_LIT",
        (pANTLR3_UINT8) "FOR",
        (pANTLR3_UINT8) "FUNCTION",
        (pANTLR3_UINT8) "GLOBAL",
        (pANTLR3_UINT8) "HEX_DIGIT",
        (pANTLR3_UINT8) "IDENTCHAIN",
        (pANTLR3_UINT8) "IDENTIFIER",
        (pANTLR3_UINT8) "IF",
        (pANTLR3_UINT8) "INCREMENT_EXPRESSION",
        (pANTLR3_UINT8) "INITIALIZATION_EXPRESSION",
        (pANTLR3_UINT8) "INTEGER",
        (pANTLR3_UINT8) "LEFT_BRACKET",
        (pANTLR3_UINT8) "LEFT_CURLY_BRACKET",
        (pANTLR3_UINT8) "LEFT_SQUARE_BRACKET",
        (pANTLR3_UINT8) "METADATA",
        (pANTLR3_UINT8) "NUMBER",
        (pANTLR3_UINT8) "OPERATOR_ASSIGN",
        (pANTLR3_UINT8) "OPERATOR_ASSIGN_AND",
        (pANTLR3_UINT8) "OPERATOR_ASSIGN_DIVIDE",
        (pANTLR3_UINT8) "OPERATOR_ASSIGN_LSHIFT",
        (pANTLR3_UINT8) "OPERATOR_ASSIGN_MINUS",
        (pANTLR3_UINT8) "OPERATOR_ASSIGN_MODULO",
        (pANTLR3_UINT8) "OPERATOR_ASSIGN_OR",
        (pANTLR3_UINT8) "OPERATOR_ASSIGN_PLUS",
        (pANTLR3_UINT8) "OPERATOR_ASSIGN_RSHIFT",
        (pANTLR3_UINT8) "OPERATOR_ASSIGN_TIMES",
        (pANTLR3_UINT8) "OPERATOR_ASSIGN_XOR",
        (pANTLR3_UINT8) "OPERATOR_BIT_AND",
        (pANTLR3_UINT8) "OPERATOR_BIT_OR",
        (pANTLR3_UINT8) "OPERATOR_BIT_XOR",
        (pANTLR3_UINT8) "OPERATOR_CALL",
        (pANTLR3_UINT8) "OPERATOR_DECREMENT",
        (pANTLR3_UINT8) "OPERATOR_DECREMENT_POST",
        (pANTLR3_UINT8) "OPERATOR_DECREMENT_PRE",
        (pANTLR3_UINT8) "OPERATOR_DIVIDE",
        (pANTLR3_UINT8) "OPERATOR_DOT",
        (pANTLR3_UINT8) "OPERATOR_EQUAL_TO",
        (pANTLR3_UINT8) "OPERATOR_EXPR_IF",
        (pANTLR3_UINT8) "OPERATOR_GREATER_THAN",
        (pANTLR3_UINT8) "OPERATOR_GREATER_THAN_OR_EQUAL_TO",
        (pANTLR3_UINT8) "OPERATOR_INCREMENT",
        (pANTLR3_UINT8) "OPERATOR_INCREMENT_POST",
        (pANTLR3_UINT8) "OPERATOR_INCREMENT_PRE",
        (pANTLR3_UINT8) "OPERATOR_IS",
        (pANTLR3_UINT8) "OPERATOR_LESS_THAN",
        (pANTLR3_UINT8) "OPERATOR_LESS_THAN_OR_EQUAL_TO",
        (pANTLR3_UINT8) "OPERATOR_LSHIFT",
        (pANTLR3_UINT8) "OPERATOR_MINUS",
        (pANTLR3_UINT8) "OPERATOR_MINUS_UN",
        (pANTLR3_UINT8) "OPERATOR_MODULO",
        (pANTLR3_UINT8) "OPERATOR_NOT",
        (pANTLR3_UINT8) "OPERATOR_NOT_EQUAL_TO",
        (pANTLR3_UINT8) "OPERATOR_PLUS",
        (pANTLR3_UINT8) "OPERATOR_PLUS_UN",
        (pANTLR3_UINT8) "OPERATOR_RELATIVE",
        (pANTLR3_UINT8) "OPERATOR_REL_AND",
        (pANTLR3_UINT8) "OPERATOR_REL_OR",
        (pANTLR3_UINT8) "OPERATOR_RSHIFT",
        (pANTLR3_UINT8) "OPERATOR_SUBSCRIPT",
        (pANTLR3_UINT8) "OPERATOR_TIMES",
        (pANTLR3_UINT8) "PARAMETERS",
        (pANTLR3_UINT8) "RETURN",
        (pANTLR3_UINT8) "RIGHT_BRACKET",
        (pANTLR3_UINT8) "RIGHT_SQUARE_BRACKET",
        (pANTLR3_UINT8) "RIGTH_CURLY_BRACKET",
        (pANTLR3_UINT8) "SCRIPT",
        (pANTLR3_UINT8) "SEMICOLON",
        (pANTLR3_UINT8) "STRING",
        (pANTLR3_UINT8) "SWITCH",
        (pANTLR3_UINT8) "TRUE_LIT",
        (pANTLR3_UINT8) "VALUES",
        (pANTLR3_UINT8) "VAR",
        (pANTLR3_UINT8) "WHILE",
        (pANTLR3_UINT8) "WHITESPACE",
        (pANTLR3_UINT8) "YIELD"
       };


/* globalAttributeScopeFuncMacro(scope)
 */
/** Function  for popping the top value from a pGeoGenScriptDecls_BlockScopeStack
 */
void
pGeoGenScriptDecls_BlockScopePop(pGeoGenScriptDecls ctx)
{
    // First see if the user defined a function they want to be called when a
    // scope is popped/freed.
    //
	// If the user supplied the scope entries with a free function,then call it first
	//
    if	(SCOPE_TOP(BlockScope)->free != NULL)
	{
        SCOPE_TOP(BlockScope)->free(SCOPE_TOP(BlockScope));
	}

    // Now we decrement the scope's upper limit bound. We do not actually pop the scope as
    // we want to reuse scope entries if we do continuous push and pops. Most scopes don't
    // next too far so we don't want to keep freeing and allocating them
    //
    ctx->pGeoGenScriptDecls_BlockScopeStack_limit--;
    SCOPE_TOP(BlockScope) = (pGeoGenScriptDecls_BlockScope_SCOPE)(ctx->pGeoGenScriptDecls_BlockScopeStack->get(ctx->pGeoGenScriptDecls_BlockScopeStack, ctx->pGeoGenScriptDecls_BlockScopeStack_limit - 1));
}


// Forward declare the locally static matching functions we have generated.
//
static 
 void
	script    (pGeoGenScriptDecls ctx);
static 
 void
	metadata    (pGeoGenScriptDecls ctx);
static 
 MetadataValue*
	metadataKeyValueCollection    (pGeoGenScriptDecls ctx);
static 
 GeoGenScriptDecls_metadataKeyValuePair_return
	metadataKeyValuePair    (pGeoGenScriptDecls ctx);
static 
 MetadataValue*
	metadataKeyValueValue    (pGeoGenScriptDecls ctx);
static 
 void
	keyValueCollection    (pGeoGenScriptDecls ctx);
static 
 void
	keyValuePair    (pGeoGenScriptDecls ctx);
static 
 void
	keyValueValue    (pGeoGenScriptDecls ctx);
static 
 void
	declaration    (pGeoGenScriptDecls ctx);
static 
 void
	enumDeclaration    (pGeoGenScriptDecls ctx);
static 
 map<int, std::string>
	enumValues    (pGeoGenScriptDecls ctx);
static 
 void
	functionDeclaration    (pGeoGenScriptDecls ctx);
static 
 CodeBlock*
	block    (pGeoGenScriptDecls ctx);
static 
 CodeBlock*
	statement    (pGeoGenScriptDecls ctx);
static 
 CodeBlock*
	variableDeclaration    (pGeoGenScriptDecls ctx);
static 
 CodeBlock*
	globalVariableDeclaration    (pGeoGenScriptDecls ctx);
static 
 CodeBlock*
	yieldStatement    (pGeoGenScriptDecls ctx);
static 
 CodeBlock*
	returnStatement    (pGeoGenScriptDecls ctx);
static 
 CodeBlock*
	whileStatement    (pGeoGenScriptDecls ctx);
static 
 CodeBlock*
	forStatement    (pGeoGenScriptDecls ctx);
static 
 CodeBlock*
	initExpression    (pGeoGenScriptDecls ctx);
static 
 CodeBlock*
	ifStatement    (pGeoGenScriptDecls ctx);
static 
 void
	switchStatement    (pGeoGenScriptDecls ctx);
static 
 void
	normalCase    (pGeoGenScriptDecls ctx);
static 
 void
	defaultCase    (pGeoGenScriptDecls ctx);
static 
 CodeBlock*
	expression    (pGeoGenScriptDecls ctx);
static 
 CodeBlock*
	coordinateExpression    (pGeoGenScriptDecls ctx);
static 
 CodeBlock*
	callExpression    (pGeoGenScriptDecls ctx);
static 
 CodeBlock*
	indexAccessExpression    (pGeoGenScriptDecls ctx);
static 
 CodeBlock*
	conditionalOperatorExpression    (pGeoGenScriptDecls ctx);
static 
 CodeBlock*
	lvalueExpression    (pGeoGenScriptDecls ctx);
static 
 CodeBlock*
	lvalueIndexAccessExpression    (pGeoGenScriptDecls ctx);
static 
 void
	unkeyedCollectionLiteral    (pGeoGenScriptDecls ctx);
static 
 void
	label    (pGeoGenScriptDecls ctx);
static void	GeoGenScriptDeclsFree(pGeoGenScriptDecls ctx);
static void     GeoGenScriptDeclsReset (pGeoGenScriptDecls ctx);

/* For use in tree output where we are accumulating rule labels via label += ruleRef
 * we need a function that knows how to free a return scope when the list is destroyed.
 * We cannot just use ANTLR3_FREE because in debug tracking mode, this is a macro.
 */
static	void ANTLR3_CDECL freeScope(void * scope)
{
    ANTLR3_FREE(scope);
}

/** \brief Name of the grammar file that generated this code
 */
static const char fileName[] = "D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g";

/** \brief Return the name of the grammar file that generated this code.
 */
static const char * getGrammarFileName()
{
	return fileName;
}
/** \brief Create a new GeoGenScriptDecls parser and return a context for it.
 *
 * \param[in] instream Pointer to an input stream interface.
 *
 * \return Pointer to new parser context upon success.
 */
ANTLR3_API pGeoGenScriptDecls
GeoGenScriptDeclsNew   (pANTLR3_COMMON_TREE_NODE_STREAM instream)
{
	// See if we can create a new parser with the standard constructor
	//
	return GeoGenScriptDeclsNewSSD(instream, NULL);
}

/** \brief Create a new GeoGenScriptDecls parser and return a context for it.
 *
 * \param[in] instream Pointer to an input stream interface.
 *
 * \return Pointer to new parser context upon success.
 */
ANTLR3_API pGeoGenScriptDecls
GeoGenScriptDeclsNewSSD   (pANTLR3_COMMON_TREE_NODE_STREAM instream, pANTLR3_RECOGNIZER_SHARED_STATE state)
{
    pGeoGenScriptDecls ctx;	    /* Context structure we will build and return   */

    ctx	= (pGeoGenScriptDecls) ANTLR3_CALLOC(1, sizeof(GeoGenScriptDecls));

    if	(ctx == NULL)
    {
		// Failed to allocate memory for parser context
		//
        return  NULL;
    }

    /* -------------------------------------------------------------------
     * Memory for basic structure is allocated, now to fill in
     * the base ANTLR3 structures. We initialize the function pointers
     * for the standard ANTLR3 parser function set, but upon return
     * from here, the programmer may set the pointers to provide custom
     * implementations of each function.
     *
     * We don't use the macros defined in GeoGenScriptDecls.h here, in order that you can get a sense
     * of what goes where.
     */

    /* Create a base Tree parser/recognizer, using the supplied tree node stream
     */
    ctx->pTreeParser		= antlr3TreeParserNewStream(ANTLR3_SIZE_HINT, instream, state);

    /* Install the implementation of our GeoGenScriptDecls interface
     */
    ctx->script	= script;
    ctx->metadata	= metadata;
    ctx->metadataKeyValueCollection	= metadataKeyValueCollection;
    ctx->metadataKeyValuePair	= metadataKeyValuePair;
    ctx->metadataKeyValueValue	= metadataKeyValueValue;
    ctx->keyValueCollection	= keyValueCollection;
    ctx->keyValuePair	= keyValuePair;
    ctx->keyValueValue	= keyValueValue;
    ctx->declaration	= declaration;
    ctx->enumDeclaration	= enumDeclaration;
    ctx->enumValues	= enumValues;
    ctx->functionDeclaration	= functionDeclaration;
    ctx->block	= block;
    ctx->statement	= statement;
    ctx->variableDeclaration	= variableDeclaration;
    ctx->globalVariableDeclaration	= globalVariableDeclaration;
    ctx->yieldStatement	= yieldStatement;
    ctx->returnStatement	= returnStatement;
    ctx->whileStatement	= whileStatement;
    ctx->forStatement	= forStatement;
    ctx->initExpression	= initExpression;
    ctx->ifStatement	= ifStatement;
    ctx->switchStatement	= switchStatement;
    ctx->normalCase	= normalCase;
    ctx->defaultCase	= defaultCase;
    ctx->expression	= expression;
    ctx->coordinateExpression	= coordinateExpression;
    ctx->callExpression	= callExpression;
    ctx->indexAccessExpression	= indexAccessExpression;
    ctx->conditionalOperatorExpression	= conditionalOperatorExpression;
    ctx->lvalueExpression	= lvalueExpression;
    ctx->lvalueIndexAccessExpression	= lvalueIndexAccessExpression;
    ctx->unkeyedCollectionLiteral	= unkeyedCollectionLiteral;
    ctx->label	= label;
    ctx->free			= GeoGenScriptDeclsFree;
    ctx->reset			= GeoGenScriptDeclsReset;
    ctx->getGrammarFileName	= getGrammarFileName;

    /* Install the scope pushing methods.
     */
    /* globalAttributeScope(scope)
     */
    ctx->pGeoGenScriptDecls_BlockScopePush     = pGeoGenScriptDecls_BlockScopePush;
    ctx->pGeoGenScriptDecls_BlockScopeStack    = antlr3StackNew(0);
    ctx->pGeoGenScriptDecls_BlockScopeStack_limit    = 0;
    ctx->pGeoGenScriptDecls_BlockScopeTop      = NULL;





    	RECOGNIZER->displayRecognitionError = handleTreeWalkerError;

    /* Install the token table
     */
    PSRSTATE->tokenNames   = GeoGenScriptDeclsTokenNames;


    /* Return the newly built parser to the caller
     */
    return  ctx;
}

static void
GeoGenScriptDeclsReset (pGeoGenScriptDecls ctx)
{
    RECOGNIZER->reset(RECOGNIZER);
}

/** Free the parser resources
 */
 static void
 GeoGenScriptDeclsFree(pGeoGenScriptDecls ctx)
 {
    /* Free any scope memory
     */
    /* globalAttributeScope(scope)
     */
    ctx->pGeoGenScriptDecls_BlockScopeStack->free(ctx->pGeoGenScriptDecls_BlockScopeStack);



	// Free this parser
	//
    ctx->pTreeParser->free(ctx->pTreeParser);

    ANTLR3_FREE(ctx);

    /* Everything is released, so we can return
     */
    return;
 }

/** Return token names used by this 
tree parser

 *
 * The returned pointer is used as an index into the token names table (using the token
 * number as the index).
 *
 * \return Pointer to first char * in the table.
 */
static pANTLR3_UINT8    *getTokenNames()
{
        return GeoGenScriptDeclsTokenNames;
}


        	void handleTreeWalkerError (pANTLR3_BASE_RECOGNIZER recognizer, pANTLR3_UINT8 * tokenNames) { 
        	    pANTLR3_EXCEPTION ex = recognizer->state->exception;
        	    pANTLR3_BASE_TREE currentTree = (pANTLR3_BASE_TREE)(recognizer->state->exception->token);
        	    
        	    CodeLocation location(recognizer->state->exception->line, currentTree->getCharPositionInLine(currentTree));
        	    
        	    string expectedTokenName = "";
        	    if(ex->expecting == ANTLR3_TOKEN_EOF)
        	    {
        	    	expectedTokenName = "EOF";
        	    }
    			else if (ex->expecting > 0)
        	    {
        	    	expectedTokenName = (char*)tokenNames[ex->expecting];
        	    }
        	    
        	    throw UnexpectedTokenException(GGE1201_UnexpectedToken, location, expectedTokenName/*, currentTokenName, currentTokenText*/);
        	    
        	    /*switch  (ex->type)
        	    {
        		case:			    
        		    throw GeoGenException(GGE1201_UnexpectedToken); 
        	    }*/
        	 }

    	void binaryOperator(pGeoGenScriptDecls ctx, pANTLR3_BASE_TREE operatorToken, CodeBlock* e1, CodeBlock* e2, CodeBlock* returnCodeBlock)
    	{
    		CodeLocation location(operatorToken->getLine(operatorToken), operatorToken->getCharPositionInLine(operatorToken));
    		
    		returnCodeBlock->MoveInstructionsFrom(*e2); 
    		delete e2;
    		
    	
    		returnCodeBlock->MoveInstructionsFrom(*e1); 
    		delete e1; 
    		
    		returnCodeBlock->AddInstruction(new instructions::CallGlobalInstruction(location, (char*)operatorToken->getText(operatorToken)->chars, 2));
    	}
    	
    	void unaryOperator(pGeoGenScriptDecls ctx, pANTLR3_BASE_TREE operatorToken, std::string const& text, CodeBlock* e1, CodeBlock* returnCodeBlock)
    	{
    		CodeLocation location(operatorToken->getLine(operatorToken), operatorToken->getCharPositionInLine(operatorToken));
    	
    		returnCodeBlock->MoveInstructionsFrom(*e1); 
    		delete e1; 		
    		
    		returnCodeBlock->AddInstruction(new instructions::CallGlobalInstruction(location, text, 1));
    	}    	     	 


/* Declare the bitsets
 */
/** Bitset defining follow set for error recovery in rule state: FOLLOW_SCRIPT_in_script92  */
static	ANTLR3_BITWORD FOLLOW_SCRIPT_in_script92_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_SCRIPT_in_script92	= { FOLLOW_SCRIPT_in_script92_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_metadata_in_script94  */
static	ANTLR3_BITWORD FOLLOW_metadata_in_script94_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000008000) };
static  ANTLR3_BITSET_LIST FOLLOW_metadata_in_script94	= { FOLLOW_metadata_in_script94_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_DECLARATIONS_in_script98  */
static	ANTLR3_BITWORD FOLLOW_DECLARATIONS_in_script98_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_DECLARATIONS_in_script98	= { FOLLOW_DECLARATIONS_in_script98_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_declaration_in_script100  */
static	ANTLR3_BITWORD FOLLOW_declaration_in_script100_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000440008) };
static  ANTLR3_BITSET_LIST FOLLOW_declaration_in_script100	= { FOLLOW_declaration_in_script100_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_block_in_script104  */
static	ANTLR3_BITWORD FOLLOW_block_in_script104_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_block_in_script104	= { FOLLOW_block_in_script104_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_METADATA_in_metadata124  */
static	ANTLR3_BITWORD FOLLOW_METADATA_in_metadata124_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_METADATA_in_metadata124	= { FOLLOW_METADATA_in_metadata124_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_metadataKeyValueCollection_in_metadata126  */
static	ANTLR3_BITWORD FOLLOW_metadataKeyValueCollection_in_metadata126_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_metadataKeyValueCollection_in_metadata126	= { FOLLOW_metadataKeyValueCollection_in_metadata126_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_COLLECTION_in_metadataKeyValueCollection148  */
static	ANTLR3_BITWORD FOLLOW_COLLECTION_in_metadataKeyValueCollection148_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_COLLECTION_in_metadataKeyValueCollection148	= { FOLLOW_COLLECTION_in_metadataKeyValueCollection148_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_metadataKeyValuePair_in_metadataKeyValueCollection151  */
static	ANTLR3_BITWORD FOLLOW_metadataKeyValuePair_in_metadataKeyValueCollection151_bits[]	= { ANTLR3_UINT64_LIT(0x0000000804000008) };
static  ANTLR3_BITSET_LIST FOLLOW_metadataKeyValuePair_in_metadataKeyValueCollection151	= { FOLLOW_metadataKeyValuePair_in_metadataKeyValueCollection151_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_IDENTIFIER_in_metadataKeyValuePair177  */
static	ANTLR3_BITWORD FOLLOW_IDENTIFIER_in_metadataKeyValuePair177_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_IDENTIFIER_in_metadataKeyValuePair177	= { FOLLOW_IDENTIFIER_in_metadataKeyValuePair177_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_metadataKeyValueValue_in_metadataKeyValuePair179  */
static	ANTLR3_BITWORD FOLLOW_metadataKeyValueValue_in_metadataKeyValuePair179_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_metadataKeyValueValue_in_metadataKeyValuePair179	= { FOLLOW_metadataKeyValueValue_in_metadataKeyValuePair179_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_NUMBER_in_metadataKeyValuePair188  */
static	ANTLR3_BITWORD FOLLOW_NUMBER_in_metadataKeyValuePair188_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_NUMBER_in_metadataKeyValuePair188	= { FOLLOW_NUMBER_in_metadataKeyValuePair188_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_metadataKeyValueValue_in_metadataKeyValuePair190  */
static	ANTLR3_BITWORD FOLLOW_metadataKeyValueValue_in_metadataKeyValuePair190_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008), ANTLR3_UINT64_LIT(0x0000000000000400) };
static  ANTLR3_BITSET_LIST FOLLOW_metadataKeyValueValue_in_metadataKeyValuePair190	= { FOLLOW_metadataKeyValueValue_in_metadataKeyValuePair190_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_OPERATOR_RELATIVE_in_metadataKeyValuePair192  */
static	ANTLR3_BITWORD FOLLOW_OPERATOR_RELATIVE_in_metadataKeyValuePair192_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_OPERATOR_RELATIVE_in_metadataKeyValuePair192	= { FOLLOW_OPERATOR_RELATIVE_in_metadataKeyValuePair192_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_STRING_in_metadataKeyValueValue214  */
static	ANTLR3_BITWORD FOLLOW_STRING_in_metadataKeyValueValue214_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_STRING_in_metadataKeyValueValue214	= { FOLLOW_STRING_in_metadataKeyValueValue214_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_TRUE_LIT_in_metadataKeyValueValue222  */
static	ANTLR3_BITWORD FOLLOW_TRUE_LIT_in_metadataKeyValueValue222_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_TRUE_LIT_in_metadataKeyValueValue222	= { FOLLOW_TRUE_LIT_in_metadataKeyValueValue222_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_FALSE_LIT_in_metadataKeyValueValue230  */
static	ANTLR3_BITWORD FOLLOW_FALSE_LIT_in_metadataKeyValueValue230_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_FALSE_LIT_in_metadataKeyValueValue230	= { FOLLOW_FALSE_LIT_in_metadataKeyValueValue230_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_NUMBER_in_metadataKeyValueValue238  */
static	ANTLR3_BITWORD FOLLOW_NUMBER_in_metadataKeyValueValue238_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_NUMBER_in_metadataKeyValueValue238	= { FOLLOW_NUMBER_in_metadataKeyValueValue238_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_IDENTIFIER_in_metadataKeyValueValue245  */
static	ANTLR3_BITWORD FOLLOW_IDENTIFIER_in_metadataKeyValueValue245_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_IDENTIFIER_in_metadataKeyValueValue245	= { FOLLOW_IDENTIFIER_in_metadataKeyValueValue245_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_metadataKeyValueCollection_in_metadataKeyValueValue252  */
static	ANTLR3_BITWORD FOLLOW_metadataKeyValueCollection_in_metadataKeyValueValue252_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_metadataKeyValueCollection_in_metadataKeyValueValue252	= { FOLLOW_metadataKeyValueCollection_in_metadataKeyValueValue252_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_COLLECTION_in_keyValueCollection262  */
static	ANTLR3_BITWORD FOLLOW_COLLECTION_in_keyValueCollection262_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_COLLECTION_in_keyValueCollection262	= { FOLLOW_COLLECTION_in_keyValueCollection262_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_keyValuePair_in_keyValueCollection264  */
static	ANTLR3_BITWORD FOLLOW_keyValuePair_in_keyValueCollection264_bits[]	= { ANTLR3_UINT64_LIT(0x0000000804000008) };
static  ANTLR3_BITSET_LIST FOLLOW_keyValuePair_in_keyValueCollection264	= { FOLLOW_keyValuePair_in_keyValueCollection264_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_IDENTIFIER_in_keyValuePair276  */
static	ANTLR3_BITWORD FOLLOW_IDENTIFIER_in_keyValuePair276_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_IDENTIFIER_in_keyValuePair276	= { FOLLOW_IDENTIFIER_in_keyValuePair276_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_keyValueValue_in_keyValuePair278  */
static	ANTLR3_BITWORD FOLLOW_keyValueValue_in_keyValuePair278_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_keyValueValue_in_keyValuePair278	= { FOLLOW_keyValueValue_in_keyValuePair278_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_NUMBER_in_keyValuePair285  */
static	ANTLR3_BITWORD FOLLOW_NUMBER_in_keyValuePair285_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_NUMBER_in_keyValuePair285	= { FOLLOW_NUMBER_in_keyValuePair285_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_keyValueValue_in_keyValuePair287  */
static	ANTLR3_BITWORD FOLLOW_keyValueValue_in_keyValuePair287_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008), ANTLR3_UINT64_LIT(0x0000000000000400) };
static  ANTLR3_BITSET_LIST FOLLOW_keyValueValue_in_keyValuePair287	= { FOLLOW_keyValueValue_in_keyValuePair287_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_OPERATOR_RELATIVE_in_keyValuePair289  */
static	ANTLR3_BITWORD FOLLOW_OPERATOR_RELATIVE_in_keyValuePair289_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_OPERATOR_RELATIVE_in_keyValuePair289	= { FOLLOW_OPERATOR_RELATIVE_in_keyValuePair289_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_keyValueValue298  */
static	ANTLR3_BITWORD FOLLOW_expression_in_keyValueValue298_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_keyValueValue298	= { FOLLOW_expression_in_keyValueValue298_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_keyValueCollection_in_keyValueValue302  */
static	ANTLR3_BITWORD FOLLOW_keyValueCollection_in_keyValueValue302_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_keyValueCollection_in_keyValueValue302	= { FOLLOW_keyValueCollection_in_keyValueValue302_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_enumDeclaration_in_declaration309  */
static	ANTLR3_BITWORD FOLLOW_enumDeclaration_in_declaration309_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_enumDeclaration_in_declaration309	= { FOLLOW_enumDeclaration_in_declaration309_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_functionDeclaration_in_declaration313  */
static	ANTLR3_BITWORD FOLLOW_functionDeclaration_in_declaration313_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_functionDeclaration_in_declaration313	= { FOLLOW_functionDeclaration_in_declaration313_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ENUM_in_enumDeclaration321  */
static	ANTLR3_BITWORD FOLLOW_ENUM_in_enumDeclaration321_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_ENUM_in_enumDeclaration321	= { FOLLOW_ENUM_in_enumDeclaration321_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_IDENTIFIER_in_enumDeclaration323  */
static	ANTLR3_BITWORD FOLLOW_IDENTIFIER_in_enumDeclaration323_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000004000000) };
static  ANTLR3_BITSET_LIST FOLLOW_IDENTIFIER_in_enumDeclaration323	= { FOLLOW_IDENTIFIER_in_enumDeclaration323_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_enumValues_in_enumDeclaration325  */
static	ANTLR3_BITWORD FOLLOW_enumValues_in_enumDeclaration325_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_enumValues_in_enumDeclaration325	= { FOLLOW_enumValues_in_enumDeclaration325_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_VALUES_in_enumValues346  */
static	ANTLR3_BITWORD FOLLOW_VALUES_in_enumValues346_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_VALUES_in_enumValues346	= { FOLLOW_VALUES_in_enumValues346_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_IDENTIFIER_in_enumValues350  */
static	ANTLR3_BITWORD FOLLOW_IDENTIFIER_in_enumValues350_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_IDENTIFIER_in_enumValues350	= { FOLLOW_IDENTIFIER_in_enumValues350_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_NUMBER_in_enumValues353  */
static	ANTLR3_BITWORD FOLLOW_NUMBER_in_enumValues353_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_NUMBER_in_enumValues353	= { FOLLOW_NUMBER_in_enumValues353_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_FUNCTION_in_functionDeclaration390  */
static	ANTLR3_BITWORD FOLLOW_FUNCTION_in_functionDeclaration390_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_FUNCTION_in_functionDeclaration390	= { FOLLOW_FUNCTION_in_functionDeclaration390_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_IDENTIFIER_in_functionDeclaration394  */
static	ANTLR3_BITWORD FOLLOW_IDENTIFIER_in_functionDeclaration394_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000010000) };
static  ANTLR3_BITSET_LIST FOLLOW_IDENTIFIER_in_functionDeclaration394	= { FOLLOW_IDENTIFIER_in_functionDeclaration394_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_PARAMETERS_in_functionDeclaration397  */
static	ANTLR3_BITWORD FOLLOW_PARAMETERS_in_functionDeclaration397_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_PARAMETERS_in_functionDeclaration397	= { FOLLOW_PARAMETERS_in_functionDeclaration397_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_IDENTIFIER_in_functionDeclaration401  */
static	ANTLR3_BITWORD FOLLOW_IDENTIFIER_in_functionDeclaration401_bits[]	= { ANTLR3_UINT64_LIT(0x0000000004000008) };
static  ANTLR3_BITSET_LIST FOLLOW_IDENTIFIER_in_functionDeclaration401	= { FOLLOW_IDENTIFIER_in_functionDeclaration401_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_block_in_functionDeclaration405  */
static	ANTLR3_BITWORD FOLLOW_block_in_functionDeclaration405_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_block_in_functionDeclaration405	= { FOLLOW_block_in_functionDeclaration405_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_BLOCK_in_block432  */
static	ANTLR3_BITWORD FOLLOW_BLOCK_in_block432_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_BLOCK_in_block432	= { FOLLOW_BLOCK_in_block432_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_statement_in_block435  */
static	ANTLR3_BITWORD FOLLOW_statement_in_block435_bits[]	= { ANTLR3_UINT64_LIT(0xEFF3BFFA8CB06068), ANTLR3_UINT64_LIT(0x000000005B82BFFF) };
static  ANTLR3_BITSET_LIST FOLLOW_statement_in_block435	= { FOLLOW_statement_in_block435_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_BREAK_in_statement466  */
static	ANTLR3_BITWORD FOLLOW_BREAK_in_statement466_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_BREAK_in_statement466	= { FOLLOW_BREAK_in_statement466_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_CONTINUE_in_statement481  */
static	ANTLR3_BITWORD FOLLOW_CONTINUE_in_statement481_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_CONTINUE_in_statement481	= { FOLLOW_CONTINUE_in_statement481_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_variableDeclaration_in_statement496  */
static	ANTLR3_BITWORD FOLLOW_variableDeclaration_in_statement496_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_variableDeclaration_in_statement496	= { FOLLOW_variableDeclaration_in_statement496_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_globalVariableDeclaration_in_statement506  */
static	ANTLR3_BITWORD FOLLOW_globalVariableDeclaration_in_statement506_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_globalVariableDeclaration_in_statement506	= { FOLLOW_globalVariableDeclaration_in_statement506_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_statement516  */
static	ANTLR3_BITWORD FOLLOW_expression_in_statement516_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_statement516	= { FOLLOW_expression_in_statement516_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_yieldStatement_in_statement531  */
static	ANTLR3_BITWORD FOLLOW_yieldStatement_in_statement531_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_yieldStatement_in_statement531	= { FOLLOW_yieldStatement_in_statement531_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_returnStatement_in_statement540  */
static	ANTLR3_BITWORD FOLLOW_returnStatement_in_statement540_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_returnStatement_in_statement540	= { FOLLOW_returnStatement_in_statement540_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_whileStatement_in_statement550  */
static	ANTLR3_BITWORD FOLLOW_whileStatement_in_statement550_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_whileStatement_in_statement550	= { FOLLOW_whileStatement_in_statement550_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_forStatement_in_statement560  */
static	ANTLR3_BITWORD FOLLOW_forStatement_in_statement560_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_forStatement_in_statement560	= { FOLLOW_forStatement_in_statement560_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ifStatement_in_statement570  */
static	ANTLR3_BITWORD FOLLOW_ifStatement_in_statement570_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_ifStatement_in_statement570	= { FOLLOW_ifStatement_in_statement570_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_switchStatement_in_statement580  */
static	ANTLR3_BITWORD FOLLOW_switchStatement_in_statement580_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_switchStatement_in_statement580	= { FOLLOW_switchStatement_in_statement580_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_block_in_statement590  */
static	ANTLR3_BITWORD FOLLOW_block_in_statement590_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_block_in_statement590	= { FOLLOW_block_in_statement590_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_VAR_in_variableDeclaration615  */
static	ANTLR3_BITWORD FOLLOW_VAR_in_variableDeclaration615_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_VAR_in_variableDeclaration615	= { FOLLOW_VAR_in_variableDeclaration615_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_IDENTIFIER_in_variableDeclaration617  */
static	ANTLR3_BITWORD FOLLOW_IDENTIFIER_in_variableDeclaration617_bits[]	= { ANTLR3_UINT64_LIT(0xEFF3BFFA84104008), ANTLR3_UINT64_LIT(0x000000000280BFFF) };
static  ANTLR3_BITSET_LIST FOLLOW_IDENTIFIER_in_variableDeclaration617	= { FOLLOW_IDENTIFIER_in_variableDeclaration617_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_variableDeclaration620  */
static	ANTLR3_BITWORD FOLLOW_expression_in_variableDeclaration620_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_variableDeclaration620	= { FOLLOW_expression_in_variableDeclaration620_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_GLOBAL_in_globalVariableDeclaration648  */
static	ANTLR3_BITWORD FOLLOW_GLOBAL_in_globalVariableDeclaration648_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_GLOBAL_in_globalVariableDeclaration648	= { FOLLOW_GLOBAL_in_globalVariableDeclaration648_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_IDENTIFIER_in_globalVariableDeclaration650  */
static	ANTLR3_BITWORD FOLLOW_IDENTIFIER_in_globalVariableDeclaration650_bits[]	= { ANTLR3_UINT64_LIT(0xEFF3BFFA84104008), ANTLR3_UINT64_LIT(0x000000000280BFFF) };
static  ANTLR3_BITSET_LIST FOLLOW_IDENTIFIER_in_globalVariableDeclaration650	= { FOLLOW_IDENTIFIER_in_globalVariableDeclaration650_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_globalVariableDeclaration653  */
static	ANTLR3_BITWORD FOLLOW_expression_in_globalVariableDeclaration653_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_globalVariableDeclaration653	= { FOLLOW_expression_in_globalVariableDeclaration653_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_YIELD_in_yieldStatement681  */
static	ANTLR3_BITWORD FOLLOW_YIELD_in_yieldStatement681_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_YIELD_in_yieldStatement681	= { FOLLOW_YIELD_in_yieldStatement681_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_yieldStatement683  */
static	ANTLR3_BITWORD FOLLOW_expression_in_yieldStatement683_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008), ANTLR3_UINT64_LIT(0x0000000000800000) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_yieldStatement683	= { FOLLOW_expression_in_yieldStatement683_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_STRING_in_yieldStatement685  */
static	ANTLR3_BITWORD FOLLOW_STRING_in_yieldStatement685_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_STRING_in_yieldStatement685	= { FOLLOW_STRING_in_yieldStatement685_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_RETURN_in_returnStatement709  */
static	ANTLR3_BITWORD FOLLOW_RETURN_in_returnStatement709_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_RETURN_in_returnStatement709	= { FOLLOW_RETURN_in_returnStatement709_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_returnStatement712  */
static	ANTLR3_BITWORD FOLLOW_expression_in_returnStatement712_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_returnStatement712	= { FOLLOW_expression_in_returnStatement712_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_WHILE_in_whileStatement748  */
static	ANTLR3_BITWORD FOLLOW_WHILE_in_whileStatement748_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_WHILE_in_whileStatement748	= { FOLLOW_WHILE_in_whileStatement748_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_whileStatement750  */
static	ANTLR3_BITWORD FOLLOW_expression_in_whileStatement750_bits[]	= { ANTLR3_UINT64_LIT(0xEFF3BFFA8CB06060), ANTLR3_UINT64_LIT(0x000000005B82BFFF) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_whileStatement750	= { FOLLOW_expression_in_whileStatement750_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_statement_in_whileStatement752  */
static	ANTLR3_BITWORD FOLLOW_statement_in_whileStatement752_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_statement_in_whileStatement752	= { FOLLOW_statement_in_whileStatement752_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_FOR_in_forStatement785  */
static	ANTLR3_BITWORD FOLLOW_FOR_in_forStatement785_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_FOR_in_forStatement785	= { FOLLOW_FOR_in_forStatement785_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_INITIALIZATION_EXPRESSION_in_forStatement791  */
static	ANTLR3_BITWORD FOLLOW_INITIALIZATION_EXPRESSION_in_forStatement791_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_INITIALIZATION_EXPRESSION_in_forStatement791	= { FOLLOW_INITIALIZATION_EXPRESSION_in_forStatement791_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_initExpression_in_forStatement793  */
static	ANTLR3_BITWORD FOLLOW_initExpression_in_forStatement793_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_initExpression_in_forStatement793	= { FOLLOW_initExpression_in_forStatement793_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_CONDITION_EXPRESSION_in_forStatement805  */
static	ANTLR3_BITWORD FOLLOW_CONDITION_EXPRESSION_in_forStatement805_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_CONDITION_EXPRESSION_in_forStatement805	= { FOLLOW_CONDITION_EXPRESSION_in_forStatement805_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_forStatement809  */
static	ANTLR3_BITWORD FOLLOW_expression_in_forStatement809_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_forStatement809	= { FOLLOW_expression_in_forStatement809_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_INCREMENT_EXPRESSION_in_forStatement821  */
static	ANTLR3_BITWORD FOLLOW_INCREMENT_EXPRESSION_in_forStatement821_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_INCREMENT_EXPRESSION_in_forStatement821	= { FOLLOW_INCREMENT_EXPRESSION_in_forStatement821_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_forStatement825  */
static	ANTLR3_BITWORD FOLLOW_expression_in_forStatement825_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_forStatement825	= { FOLLOW_expression_in_forStatement825_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_statement_in_forStatement835  */
static	ANTLR3_BITWORD FOLLOW_statement_in_forStatement835_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_statement_in_forStatement835	= { FOLLOW_statement_in_forStatement835_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_variableDeclaration_in_initExpression860  */
static	ANTLR3_BITWORD FOLLOW_variableDeclaration_in_initExpression860_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_variableDeclaration_in_initExpression860	= { FOLLOW_variableDeclaration_in_initExpression860_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_initExpression870  */
static	ANTLR3_BITWORD FOLLOW_expression_in_initExpression870_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_initExpression870	= { FOLLOW_expression_in_initExpression870_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_IF_in_ifStatement896  */
static	ANTLR3_BITWORD FOLLOW_IF_in_ifStatement896_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_IF_in_ifStatement896	= { FOLLOW_IF_in_ifStatement896_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_ifStatement898  */
static	ANTLR3_BITWORD FOLLOW_expression_in_ifStatement898_bits[]	= { ANTLR3_UINT64_LIT(0xEFF3BFFA8CB06060), ANTLR3_UINT64_LIT(0x000000005B82BFFF) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_ifStatement898	= { FOLLOW_expression_in_ifStatement898_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_statement_in_ifStatement902  */
static	ANTLR3_BITWORD FOLLOW_statement_in_ifStatement902_bits[]	= { ANTLR3_UINT64_LIT(0xEFF3BFFA8CB06060), ANTLR3_UINT64_LIT(0x000000005B82BFFF) };
static  ANTLR3_BITSET_LIST FOLLOW_statement_in_ifStatement902	= { FOLLOW_statement_in_ifStatement902_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_statement_in_ifStatement906  */
static	ANTLR3_BITWORD FOLLOW_statement_in_ifStatement906_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_statement_in_ifStatement906	= { FOLLOW_statement_in_ifStatement906_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_SWITCH_in_switchStatement918  */
static	ANTLR3_BITWORD FOLLOW_SWITCH_in_switchStatement918_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_SWITCH_in_switchStatement918	= { FOLLOW_SWITCH_in_switchStatement918_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_switchStatement920  */
static	ANTLR3_BITWORD FOLLOW_expression_in_switchStatement920_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000010088) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_switchStatement920	= { FOLLOW_expression_in_switchStatement920_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_normalCase_in_switchStatement922  */
static	ANTLR3_BITWORD FOLLOW_normalCase_in_switchStatement922_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000010088) };
static  ANTLR3_BITSET_LIST FOLLOW_normalCase_in_switchStatement922	= { FOLLOW_normalCase_in_switchStatement922_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_defaultCase_in_switchStatement925  */
static	ANTLR3_BITWORD FOLLOW_defaultCase_in_switchStatement925_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_defaultCase_in_switchStatement925	= { FOLLOW_defaultCase_in_switchStatement925_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_CASE_in_normalCase935  */
static	ANTLR3_BITWORD FOLLOW_CASE_in_normalCase935_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_CASE_in_normalCase935	= { FOLLOW_CASE_in_normalCase935_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_label_in_normalCase937  */
static	ANTLR3_BITWORD FOLLOW_label_in_normalCase937_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000020) };
static  ANTLR3_BITSET_LIST FOLLOW_label_in_normalCase937	= { FOLLOW_label_in_normalCase937_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_BLOCK_in_normalCase940  */
static	ANTLR3_BITWORD FOLLOW_BLOCK_in_normalCase940_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_BLOCK_in_normalCase940	= { FOLLOW_BLOCK_in_normalCase940_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_statement_in_normalCase942  */
static	ANTLR3_BITWORD FOLLOW_statement_in_normalCase942_bits[]	= { ANTLR3_UINT64_LIT(0xEFF3BFFA8CB06068), ANTLR3_UINT64_LIT(0x000000005B82BFFF) };
static  ANTLR3_BITSET_LIST FOLLOW_statement_in_normalCase942	= { FOLLOW_statement_in_normalCase942_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_DEFAULT_in_defaultCase952  */
static	ANTLR3_BITWORD FOLLOW_DEFAULT_in_defaultCase952_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_DEFAULT_in_defaultCase952	= { FOLLOW_DEFAULT_in_defaultCase952_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_BLOCK_in_defaultCase955  */
static	ANTLR3_BITWORD FOLLOW_BLOCK_in_defaultCase955_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_BLOCK_in_defaultCase955	= { FOLLOW_BLOCK_in_defaultCase955_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_statement_in_defaultCase957  */
static	ANTLR3_BITWORD FOLLOW_statement_in_defaultCase957_bits[]	= { ANTLR3_UINT64_LIT(0xEFF3BFFA8CB06068), ANTLR3_UINT64_LIT(0x000000005B82BFFF) };
static  ANTLR3_BITSET_LIST FOLLOW_statement_in_defaultCase957	= { FOLLOW_statement_in_defaultCase957_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_OPERATOR_ASSIGN_in_expression980  */
static	ANTLR3_BITWORD FOLLOW_OPERATOR_ASSIGN_in_expression980_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_OPERATOR_ASSIGN_in_expression980	= { FOLLOW_OPERATOR_ASSIGN_in_expression980_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_lvalueExpression_in_expression982  */
static	ANTLR3_BITWORD FOLLOW_lvalueExpression_in_expression982_bits[]	= { ANTLR3_UINT64_LIT(0xEFF3BFFA84104000), ANTLR3_UINT64_LIT(0x000000000280BFFF) };
static  ANTLR3_BITSET_LIST FOLLOW_lvalueExpression_in_expression982	= { FOLLOW_lvalueExpression_in_expression982_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_expression986  */
static	ANTLR3_BITWORD FOLLOW_expression_in_expression986_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_expression986	= { FOLLOW_expression_in_expression986_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_OPERATOR_ASSIGN_PLUS_in_expression998  */
static	ANTLR3_BITWORD FOLLOW_OPERATOR_ASSIGN_PLUS_in_expression998_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_OPERATOR_ASSIGN_PLUS_in_expression998	= { FOLLOW_OPERATOR_ASSIGN_PLUS_in_expression998_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_expression1002  */
static	ANTLR3_BITWORD FOLLOW_expression_in_expression1002_bits[]	= { ANTLR3_UINT64_LIT(0xEFF3BFFA84104000), ANTLR3_UINT64_LIT(0x000000000280BFFF) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_expression1002	= { FOLLOW_expression_in_expression1002_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_expression1006  */
static	ANTLR3_BITWORD FOLLOW_expression_in_expression1006_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_expression1006	= { FOLLOW_expression_in_expression1006_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_OPERATOR_ASSIGN_MINUS_in_expression1017  */
static	ANTLR3_BITWORD FOLLOW_OPERATOR_ASSIGN_MINUS_in_expression1017_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_OPERATOR_ASSIGN_MINUS_in_expression1017	= { FOLLOW_OPERATOR_ASSIGN_MINUS_in_expression1017_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_expression1021  */
static	ANTLR3_BITWORD FOLLOW_expression_in_expression1021_bits[]	= { ANTLR3_UINT64_LIT(0xEFF3BFFA84104000), ANTLR3_UINT64_LIT(0x000000000280BFFF) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_expression1021	= { FOLLOW_expression_in_expression1021_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_expression1025  */
static	ANTLR3_BITWORD FOLLOW_expression_in_expression1025_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_expression1025	= { FOLLOW_expression_in_expression1025_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_OPERATOR_ASSIGN_TIMES_in_expression1036  */
static	ANTLR3_BITWORD FOLLOW_OPERATOR_ASSIGN_TIMES_in_expression1036_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_OPERATOR_ASSIGN_TIMES_in_expression1036	= { FOLLOW_OPERATOR_ASSIGN_TIMES_in_expression1036_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_expression1040  */
static	ANTLR3_BITWORD FOLLOW_expression_in_expression1040_bits[]	= { ANTLR3_UINT64_LIT(0xEFF3BFFA84104000), ANTLR3_UINT64_LIT(0x000000000280BFFF) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_expression1040	= { FOLLOW_expression_in_expression1040_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_expression1044  */
static	ANTLR3_BITWORD FOLLOW_expression_in_expression1044_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_expression1044	= { FOLLOW_expression_in_expression1044_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_OPERATOR_ASSIGN_DIVIDE_in_expression1055  */
static	ANTLR3_BITWORD FOLLOW_OPERATOR_ASSIGN_DIVIDE_in_expression1055_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_OPERATOR_ASSIGN_DIVIDE_in_expression1055	= { FOLLOW_OPERATOR_ASSIGN_DIVIDE_in_expression1055_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_expression1059  */
static	ANTLR3_BITWORD FOLLOW_expression_in_expression1059_bits[]	= { ANTLR3_UINT64_LIT(0xEFF3BFFA84104000), ANTLR3_UINT64_LIT(0x000000000280BFFF) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_expression1059	= { FOLLOW_expression_in_expression1059_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_expression1063  */
static	ANTLR3_BITWORD FOLLOW_expression_in_expression1063_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_expression1063	= { FOLLOW_expression_in_expression1063_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_OPERATOR_ASSIGN_MODULO_in_expression1074  */
static	ANTLR3_BITWORD FOLLOW_OPERATOR_ASSIGN_MODULO_in_expression1074_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_OPERATOR_ASSIGN_MODULO_in_expression1074	= { FOLLOW_OPERATOR_ASSIGN_MODULO_in_expression1074_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_expression1078  */
static	ANTLR3_BITWORD FOLLOW_expression_in_expression1078_bits[]	= { ANTLR3_UINT64_LIT(0xEFF3BFFA84104000), ANTLR3_UINT64_LIT(0x000000000280BFFF) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_expression1078	= { FOLLOW_expression_in_expression1078_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_expression1082  */
static	ANTLR3_BITWORD FOLLOW_expression_in_expression1082_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_expression1082	= { FOLLOW_expression_in_expression1082_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_OPERATOR_ASSIGN_LSHIFT_in_expression1093  */
static	ANTLR3_BITWORD FOLLOW_OPERATOR_ASSIGN_LSHIFT_in_expression1093_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_OPERATOR_ASSIGN_LSHIFT_in_expression1093	= { FOLLOW_OPERATOR_ASSIGN_LSHIFT_in_expression1093_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_expression1097  */
static	ANTLR3_BITWORD FOLLOW_expression_in_expression1097_bits[]	= { ANTLR3_UINT64_LIT(0xEFF3BFFA84104000), ANTLR3_UINT64_LIT(0x000000000280BFFF) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_expression1097	= { FOLLOW_expression_in_expression1097_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_expression1101  */
static	ANTLR3_BITWORD FOLLOW_expression_in_expression1101_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_expression1101	= { FOLLOW_expression_in_expression1101_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_OPERATOR_ASSIGN_RSHIFT_in_expression1112  */
static	ANTLR3_BITWORD FOLLOW_OPERATOR_ASSIGN_RSHIFT_in_expression1112_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_OPERATOR_ASSIGN_RSHIFT_in_expression1112	= { FOLLOW_OPERATOR_ASSIGN_RSHIFT_in_expression1112_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_expression1116  */
static	ANTLR3_BITWORD FOLLOW_expression_in_expression1116_bits[]	= { ANTLR3_UINT64_LIT(0xEFF3BFFA84104000), ANTLR3_UINT64_LIT(0x000000000280BFFF) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_expression1116	= { FOLLOW_expression_in_expression1116_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_expression1120  */
static	ANTLR3_BITWORD FOLLOW_expression_in_expression1120_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_expression1120	= { FOLLOW_expression_in_expression1120_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_OPERATOR_ASSIGN_AND_in_expression1131  */
static	ANTLR3_BITWORD FOLLOW_OPERATOR_ASSIGN_AND_in_expression1131_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_OPERATOR_ASSIGN_AND_in_expression1131	= { FOLLOW_OPERATOR_ASSIGN_AND_in_expression1131_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_expression1135  */
static	ANTLR3_BITWORD FOLLOW_expression_in_expression1135_bits[]	= { ANTLR3_UINT64_LIT(0xEFF3BFFA84104000), ANTLR3_UINT64_LIT(0x000000000280BFFF) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_expression1135	= { FOLLOW_expression_in_expression1135_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_expression1139  */
static	ANTLR3_BITWORD FOLLOW_expression_in_expression1139_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_expression1139	= { FOLLOW_expression_in_expression1139_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_OPERATOR_ASSIGN_OR_in_expression1150  */
static	ANTLR3_BITWORD FOLLOW_OPERATOR_ASSIGN_OR_in_expression1150_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_OPERATOR_ASSIGN_OR_in_expression1150	= { FOLLOW_OPERATOR_ASSIGN_OR_in_expression1150_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_expression1154  */
static	ANTLR3_BITWORD FOLLOW_expression_in_expression1154_bits[]	= { ANTLR3_UINT64_LIT(0xEFF3BFFA84104000), ANTLR3_UINT64_LIT(0x000000000280BFFF) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_expression1154	= { FOLLOW_expression_in_expression1154_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_expression1158  */
static	ANTLR3_BITWORD FOLLOW_expression_in_expression1158_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_expression1158	= { FOLLOW_expression_in_expression1158_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_OPERATOR_IS_in_expression1169  */
static	ANTLR3_BITWORD FOLLOW_OPERATOR_IS_in_expression1169_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_OPERATOR_IS_in_expression1169	= { FOLLOW_OPERATOR_IS_in_expression1169_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_expression1173  */
static	ANTLR3_BITWORD FOLLOW_expression_in_expression1173_bits[]	= { ANTLR3_UINT64_LIT(0xEFF3BFFA84104000), ANTLR3_UINT64_LIT(0x000000000280BFFF) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_expression1173	= { FOLLOW_expression_in_expression1173_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_expression1177  */
static	ANTLR3_BITWORD FOLLOW_expression_in_expression1177_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_expression1177	= { FOLLOW_expression_in_expression1177_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_conditionalOperatorExpression_in_expression1185  */
static	ANTLR3_BITWORD FOLLOW_conditionalOperatorExpression_in_expression1185_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_conditionalOperatorExpression_in_expression1185	= { FOLLOW_conditionalOperatorExpression_in_expression1185_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_OPERATOR_REL_OR_in_expression1196  */
static	ANTLR3_BITWORD FOLLOW_OPERATOR_REL_OR_in_expression1196_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_OPERATOR_REL_OR_in_expression1196	= { FOLLOW_OPERATOR_REL_OR_in_expression1196_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_expression1200  */
static	ANTLR3_BITWORD FOLLOW_expression_in_expression1200_bits[]	= { ANTLR3_UINT64_LIT(0xEFF3BFFA84104000), ANTLR3_UINT64_LIT(0x000000000280BFFF) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_expression1200	= { FOLLOW_expression_in_expression1200_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_expression1204  */
static	ANTLR3_BITWORD FOLLOW_expression_in_expression1204_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_expression1204	= { FOLLOW_expression_in_expression1204_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_OPERATOR_REL_AND_in_expression1215  */
static	ANTLR3_BITWORD FOLLOW_OPERATOR_REL_AND_in_expression1215_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_OPERATOR_REL_AND_in_expression1215	= { FOLLOW_OPERATOR_REL_AND_in_expression1215_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_expression1219  */
static	ANTLR3_BITWORD FOLLOW_expression_in_expression1219_bits[]	= { ANTLR3_UINT64_LIT(0xEFF3BFFA84104000), ANTLR3_UINT64_LIT(0x000000000280BFFF) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_expression1219	= { FOLLOW_expression_in_expression1219_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_expression1223  */
static	ANTLR3_BITWORD FOLLOW_expression_in_expression1223_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_expression1223	= { FOLLOW_expression_in_expression1223_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_OPERATOR_BIT_XOR_in_expression1234  */
static	ANTLR3_BITWORD FOLLOW_OPERATOR_BIT_XOR_in_expression1234_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_OPERATOR_BIT_XOR_in_expression1234	= { FOLLOW_OPERATOR_BIT_XOR_in_expression1234_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_expression1238  */
static	ANTLR3_BITWORD FOLLOW_expression_in_expression1238_bits[]	= { ANTLR3_UINT64_LIT(0xEFF3BFFA84104000), ANTLR3_UINT64_LIT(0x000000000280BFFF) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_expression1238	= { FOLLOW_expression_in_expression1238_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_expression1242  */
static	ANTLR3_BITWORD FOLLOW_expression_in_expression1242_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_expression1242	= { FOLLOW_expression_in_expression1242_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_OPERATOR_BIT_AND_in_expression1253  */
static	ANTLR3_BITWORD FOLLOW_OPERATOR_BIT_AND_in_expression1253_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_OPERATOR_BIT_AND_in_expression1253	= { FOLLOW_OPERATOR_BIT_AND_in_expression1253_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_expression1257  */
static	ANTLR3_BITWORD FOLLOW_expression_in_expression1257_bits[]	= { ANTLR3_UINT64_LIT(0xEFF3BFFA84104000), ANTLR3_UINT64_LIT(0x000000000280BFFF) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_expression1257	= { FOLLOW_expression_in_expression1257_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_expression1261  */
static	ANTLR3_BITWORD FOLLOW_expression_in_expression1261_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_expression1261	= { FOLLOW_expression_in_expression1261_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_OPERATOR_BIT_OR_in_expression1272  */
static	ANTLR3_BITWORD FOLLOW_OPERATOR_BIT_OR_in_expression1272_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_OPERATOR_BIT_OR_in_expression1272	= { FOLLOW_OPERATOR_BIT_OR_in_expression1272_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_expression1276  */
static	ANTLR3_BITWORD FOLLOW_expression_in_expression1276_bits[]	= { ANTLR3_UINT64_LIT(0xEFF3BFFA84104000), ANTLR3_UINT64_LIT(0x000000000280BFFF) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_expression1276	= { FOLLOW_expression_in_expression1276_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_expression1280  */
static	ANTLR3_BITWORD FOLLOW_expression_in_expression1280_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_expression1280	= { FOLLOW_expression_in_expression1280_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_OPERATOR_EQUAL_TO_in_expression1291  */
static	ANTLR3_BITWORD FOLLOW_OPERATOR_EQUAL_TO_in_expression1291_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_OPERATOR_EQUAL_TO_in_expression1291	= { FOLLOW_OPERATOR_EQUAL_TO_in_expression1291_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_expression1295  */
static	ANTLR3_BITWORD FOLLOW_expression_in_expression1295_bits[]	= { ANTLR3_UINT64_LIT(0xEFF3BFFA84104000), ANTLR3_UINT64_LIT(0x000000000280BFFF) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_expression1295	= { FOLLOW_expression_in_expression1295_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_expression1299  */
static	ANTLR3_BITWORD FOLLOW_expression_in_expression1299_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_expression1299	= { FOLLOW_expression_in_expression1299_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_OPERATOR_NOT_EQUAL_TO_in_expression1310  */
static	ANTLR3_BITWORD FOLLOW_OPERATOR_NOT_EQUAL_TO_in_expression1310_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_OPERATOR_NOT_EQUAL_TO_in_expression1310	= { FOLLOW_OPERATOR_NOT_EQUAL_TO_in_expression1310_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_expression1314  */
static	ANTLR3_BITWORD FOLLOW_expression_in_expression1314_bits[]	= { ANTLR3_UINT64_LIT(0xEFF3BFFA84104000), ANTLR3_UINT64_LIT(0x000000000280BFFF) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_expression1314	= { FOLLOW_expression_in_expression1314_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_expression1318  */
static	ANTLR3_BITWORD FOLLOW_expression_in_expression1318_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_expression1318	= { FOLLOW_expression_in_expression1318_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_OPERATOR_LESS_THAN_in_expression1329  */
static	ANTLR3_BITWORD FOLLOW_OPERATOR_LESS_THAN_in_expression1329_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_OPERATOR_LESS_THAN_in_expression1329	= { FOLLOW_OPERATOR_LESS_THAN_in_expression1329_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_expression1333  */
static	ANTLR3_BITWORD FOLLOW_expression_in_expression1333_bits[]	= { ANTLR3_UINT64_LIT(0xEFF3BFFA84104000), ANTLR3_UINT64_LIT(0x000000000280BFFF) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_expression1333	= { FOLLOW_expression_in_expression1333_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_expression1337  */
static	ANTLR3_BITWORD FOLLOW_expression_in_expression1337_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_expression1337	= { FOLLOW_expression_in_expression1337_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_OPERATOR_LESS_THAN_OR_EQUAL_TO_in_expression1348  */
static	ANTLR3_BITWORD FOLLOW_OPERATOR_LESS_THAN_OR_EQUAL_TO_in_expression1348_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_OPERATOR_LESS_THAN_OR_EQUAL_TO_in_expression1348	= { FOLLOW_OPERATOR_LESS_THAN_OR_EQUAL_TO_in_expression1348_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_expression1352  */
static	ANTLR3_BITWORD FOLLOW_expression_in_expression1352_bits[]	= { ANTLR3_UINT64_LIT(0xEFF3BFFA84104000), ANTLR3_UINT64_LIT(0x000000000280BFFF) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_expression1352	= { FOLLOW_expression_in_expression1352_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_expression1356  */
static	ANTLR3_BITWORD FOLLOW_expression_in_expression1356_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_expression1356	= { FOLLOW_expression_in_expression1356_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_OPERATOR_GREATER_THAN_in_expression1367  */
static	ANTLR3_BITWORD FOLLOW_OPERATOR_GREATER_THAN_in_expression1367_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_OPERATOR_GREATER_THAN_in_expression1367	= { FOLLOW_OPERATOR_GREATER_THAN_in_expression1367_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_expression1371  */
static	ANTLR3_BITWORD FOLLOW_expression_in_expression1371_bits[]	= { ANTLR3_UINT64_LIT(0xEFF3BFFA84104000), ANTLR3_UINT64_LIT(0x000000000280BFFF) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_expression1371	= { FOLLOW_expression_in_expression1371_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_expression1375  */
static	ANTLR3_BITWORD FOLLOW_expression_in_expression1375_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_expression1375	= { FOLLOW_expression_in_expression1375_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_OPERATOR_GREATER_THAN_OR_EQUAL_TO_in_expression1386  */
static	ANTLR3_BITWORD FOLLOW_OPERATOR_GREATER_THAN_OR_EQUAL_TO_in_expression1386_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_OPERATOR_GREATER_THAN_OR_EQUAL_TO_in_expression1386	= { FOLLOW_OPERATOR_GREATER_THAN_OR_EQUAL_TO_in_expression1386_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_expression1390  */
static	ANTLR3_BITWORD FOLLOW_expression_in_expression1390_bits[]	= { ANTLR3_UINT64_LIT(0xEFF3BFFA84104000), ANTLR3_UINT64_LIT(0x000000000280BFFF) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_expression1390	= { FOLLOW_expression_in_expression1390_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_expression1394  */
static	ANTLR3_BITWORD FOLLOW_expression_in_expression1394_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_expression1394	= { FOLLOW_expression_in_expression1394_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_OPERATOR_LSHIFT_in_expression1405  */
static	ANTLR3_BITWORD FOLLOW_OPERATOR_LSHIFT_in_expression1405_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_OPERATOR_LSHIFT_in_expression1405	= { FOLLOW_OPERATOR_LSHIFT_in_expression1405_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_expression1409  */
static	ANTLR3_BITWORD FOLLOW_expression_in_expression1409_bits[]	= { ANTLR3_UINT64_LIT(0xEFF3BFFA84104000), ANTLR3_UINT64_LIT(0x000000000280BFFF) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_expression1409	= { FOLLOW_expression_in_expression1409_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_expression1413  */
static	ANTLR3_BITWORD FOLLOW_expression_in_expression1413_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_expression1413	= { FOLLOW_expression_in_expression1413_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_OPERATOR_RSHIFT_in_expression1424  */
static	ANTLR3_BITWORD FOLLOW_OPERATOR_RSHIFT_in_expression1424_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_OPERATOR_RSHIFT_in_expression1424	= { FOLLOW_OPERATOR_RSHIFT_in_expression1424_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_expression1428  */
static	ANTLR3_BITWORD FOLLOW_expression_in_expression1428_bits[]	= { ANTLR3_UINT64_LIT(0xEFF3BFFA84104000), ANTLR3_UINT64_LIT(0x000000000280BFFF) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_expression1428	= { FOLLOW_expression_in_expression1428_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_expression1432  */
static	ANTLR3_BITWORD FOLLOW_expression_in_expression1432_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_expression1432	= { FOLLOW_expression_in_expression1432_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_OPERATOR_PLUS_in_expression1443  */
static	ANTLR3_BITWORD FOLLOW_OPERATOR_PLUS_in_expression1443_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_OPERATOR_PLUS_in_expression1443	= { FOLLOW_OPERATOR_PLUS_in_expression1443_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_expression1447  */
static	ANTLR3_BITWORD FOLLOW_expression_in_expression1447_bits[]	= { ANTLR3_UINT64_LIT(0xEFF3BFFA84104000), ANTLR3_UINT64_LIT(0x000000000280BFFF) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_expression1447	= { FOLLOW_expression_in_expression1447_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_expression1451  */
static	ANTLR3_BITWORD FOLLOW_expression_in_expression1451_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_expression1451	= { FOLLOW_expression_in_expression1451_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_OPERATOR_MINUS_in_expression1462  */
static	ANTLR3_BITWORD FOLLOW_OPERATOR_MINUS_in_expression1462_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_OPERATOR_MINUS_in_expression1462	= { FOLLOW_OPERATOR_MINUS_in_expression1462_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_expression1466  */
static	ANTLR3_BITWORD FOLLOW_expression_in_expression1466_bits[]	= { ANTLR3_UINT64_LIT(0xEFF3BFFA84104000), ANTLR3_UINT64_LIT(0x000000000280BFFF) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_expression1466	= { FOLLOW_expression_in_expression1466_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_expression1470  */
static	ANTLR3_BITWORD FOLLOW_expression_in_expression1470_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_expression1470	= { FOLLOW_expression_in_expression1470_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_OPERATOR_TIMES_in_expression1481  */
static	ANTLR3_BITWORD FOLLOW_OPERATOR_TIMES_in_expression1481_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_OPERATOR_TIMES_in_expression1481	= { FOLLOW_OPERATOR_TIMES_in_expression1481_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_expression1485  */
static	ANTLR3_BITWORD FOLLOW_expression_in_expression1485_bits[]	= { ANTLR3_UINT64_LIT(0xEFF3BFFA84104000), ANTLR3_UINT64_LIT(0x000000000280BFFF) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_expression1485	= { FOLLOW_expression_in_expression1485_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_expression1489  */
static	ANTLR3_BITWORD FOLLOW_expression_in_expression1489_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_expression1489	= { FOLLOW_expression_in_expression1489_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_OPERATOR_DIVIDE_in_expression1500  */
static	ANTLR3_BITWORD FOLLOW_OPERATOR_DIVIDE_in_expression1500_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_OPERATOR_DIVIDE_in_expression1500	= { FOLLOW_OPERATOR_DIVIDE_in_expression1500_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_expression1504  */
static	ANTLR3_BITWORD FOLLOW_expression_in_expression1504_bits[]	= { ANTLR3_UINT64_LIT(0xEFF3BFFA84104000), ANTLR3_UINT64_LIT(0x000000000280BFFF) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_expression1504	= { FOLLOW_expression_in_expression1504_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_expression1508  */
static	ANTLR3_BITWORD FOLLOW_expression_in_expression1508_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_expression1508	= { FOLLOW_expression_in_expression1508_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_OPERATOR_MODULO_in_expression1519  */
static	ANTLR3_BITWORD FOLLOW_OPERATOR_MODULO_in_expression1519_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_OPERATOR_MODULO_in_expression1519	= { FOLLOW_OPERATOR_MODULO_in_expression1519_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_expression1523  */
static	ANTLR3_BITWORD FOLLOW_expression_in_expression1523_bits[]	= { ANTLR3_UINT64_LIT(0xEFF3BFFA84104000), ANTLR3_UINT64_LIT(0x000000000280BFFF) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_expression1523	= { FOLLOW_expression_in_expression1523_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_expression1527  */
static	ANTLR3_BITWORD FOLLOW_expression_in_expression1527_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_expression1527	= { FOLLOW_expression_in_expression1527_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_OPERATOR_INCREMENT_PRE_in_expression1538  */
static	ANTLR3_BITWORD FOLLOW_OPERATOR_INCREMENT_PRE_in_expression1538_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_OPERATOR_INCREMENT_PRE_in_expression1538	= { FOLLOW_OPERATOR_INCREMENT_PRE_in_expression1538_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_expression1542  */
static	ANTLR3_BITWORD FOLLOW_expression_in_expression1542_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_expression1542	= { FOLLOW_expression_in_expression1542_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_OPERATOR_INCREMENT_POST_in_expression1554  */
static	ANTLR3_BITWORD FOLLOW_OPERATOR_INCREMENT_POST_in_expression1554_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_OPERATOR_INCREMENT_POST_in_expression1554	= { FOLLOW_OPERATOR_INCREMENT_POST_in_expression1554_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_expression1558  */
static	ANTLR3_BITWORD FOLLOW_expression_in_expression1558_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_expression1558	= { FOLLOW_expression_in_expression1558_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_OPERATOR_DECREMENT_PRE_in_expression1571  */
static	ANTLR3_BITWORD FOLLOW_OPERATOR_DECREMENT_PRE_in_expression1571_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_OPERATOR_DECREMENT_PRE_in_expression1571	= { FOLLOW_OPERATOR_DECREMENT_PRE_in_expression1571_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_expression1575  */
static	ANTLR3_BITWORD FOLLOW_expression_in_expression1575_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_expression1575	= { FOLLOW_expression_in_expression1575_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_OPERATOR_DECREMENT_POST_in_expression1587  */
static	ANTLR3_BITWORD FOLLOW_OPERATOR_DECREMENT_POST_in_expression1587_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_OPERATOR_DECREMENT_POST_in_expression1587	= { FOLLOW_OPERATOR_DECREMENT_POST_in_expression1587_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_expression1591  */
static	ANTLR3_BITWORD FOLLOW_expression_in_expression1591_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_expression1591	= { FOLLOW_expression_in_expression1591_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_OPERATOR_PLUS_UN_in_expression1606  */
static	ANTLR3_BITWORD FOLLOW_OPERATOR_PLUS_UN_in_expression1606_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_OPERATOR_PLUS_UN_in_expression1606	= { FOLLOW_OPERATOR_PLUS_UN_in_expression1606_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_expression1610  */
static	ANTLR3_BITWORD FOLLOW_expression_in_expression1610_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_expression1610	= { FOLLOW_expression_in_expression1610_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_OPERATOR_MINUS_UN_in_expression1625  */
static	ANTLR3_BITWORD FOLLOW_OPERATOR_MINUS_UN_in_expression1625_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_OPERATOR_MINUS_UN_in_expression1625	= { FOLLOW_OPERATOR_MINUS_UN_in_expression1625_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_expression1629  */
static	ANTLR3_BITWORD FOLLOW_expression_in_expression1629_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_expression1629	= { FOLLOW_expression_in_expression1629_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_OPERATOR_NOT_in_expression1645  */
static	ANTLR3_BITWORD FOLLOW_OPERATOR_NOT_in_expression1645_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_OPERATOR_NOT_in_expression1645	= { FOLLOW_OPERATOR_NOT_in_expression1645_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_expression1649  */
static	ANTLR3_BITWORD FOLLOW_expression_in_expression1649_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_expression1649	= { FOLLOW_expression_in_expression1649_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_OPERATOR_RELATIVE_in_expression1666  */
static	ANTLR3_BITWORD FOLLOW_OPERATOR_RELATIVE_in_expression1666_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_OPERATOR_RELATIVE_in_expression1666	= { FOLLOW_OPERATOR_RELATIVE_in_expression1666_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_expression1670  */
static	ANTLR3_BITWORD FOLLOW_expression_in_expression1670_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_expression1670	= { FOLLOW_expression_in_expression1670_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_OPERATOR_DOT_in_expression1686  */
static	ANTLR3_BITWORD FOLLOW_OPERATOR_DOT_in_expression1686_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_OPERATOR_DOT_in_expression1686	= { FOLLOW_OPERATOR_DOT_in_expression1686_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_expression1690  */
static	ANTLR3_BITWORD FOLLOW_expression_in_expression1690_bits[]	= { ANTLR3_UINT64_LIT(0x0000000004000000) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_expression1690	= { FOLLOW_expression_in_expression1690_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_IDENTIFIER_in_expression1692  */
static	ANTLR3_BITWORD FOLLOW_IDENTIFIER_in_expression1692_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_IDENTIFIER_in_expression1692	= { FOLLOW_IDENTIFIER_in_expression1692_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_callExpression_in_expression1702  */
static	ANTLR3_BITWORD FOLLOW_callExpression_in_expression1702_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_callExpression_in_expression1702	= { FOLLOW_callExpression_in_expression1702_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_indexAccessExpression_in_expression1710  */
static	ANTLR3_BITWORD FOLLOW_indexAccessExpression_in_expression1710_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_indexAccessExpression_in_expression1710	= { FOLLOW_indexAccessExpression_in_expression1710_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_IDENTIFIER_in_expression1718  */
static	ANTLR3_BITWORD FOLLOW_IDENTIFIER_in_expression1718_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_IDENTIFIER_in_expression1718	= { FOLLOW_IDENTIFIER_in_expression1718_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_TRUE_LIT_in_expression1729  */
static	ANTLR3_BITWORD FOLLOW_TRUE_LIT_in_expression1729_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_TRUE_LIT_in_expression1729	= { FOLLOW_TRUE_LIT_in_expression1729_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_FALSE_LIT_in_expression1737  */
static	ANTLR3_BITWORD FOLLOW_FALSE_LIT_in_expression1737_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_FALSE_LIT_in_expression1737	= { FOLLOW_FALSE_LIT_in_expression1737_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_NUMBER_in_expression1746  */
static	ANTLR3_BITWORD FOLLOW_NUMBER_in_expression1746_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_NUMBER_in_expression1746	= { FOLLOW_NUMBER_in_expression1746_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_STRING_in_expression1755  */
static	ANTLR3_BITWORD FOLLOW_STRING_in_expression1755_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_STRING_in_expression1755	= { FOLLOW_STRING_in_expression1755_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_coordinateExpression_in_expression1764  */
static	ANTLR3_BITWORD FOLLOW_coordinateExpression_in_expression1764_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_coordinateExpression_in_expression1764	= { FOLLOW_coordinateExpression_in_expression1764_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_COORDINATE_in_coordinateExpression1788  */
static	ANTLR3_BITWORD FOLLOW_COORDINATE_in_coordinateExpression1788_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_COORDINATE_in_coordinateExpression1788	= { FOLLOW_COORDINATE_in_coordinateExpression1788_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_coordinateExpression1791  */
static	ANTLR3_BITWORD FOLLOW_expression_in_coordinateExpression1791_bits[]	= { ANTLR3_UINT64_LIT(0xEFF3BFFA84104008), ANTLR3_UINT64_LIT(0x000000000280BFFF) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_coordinateExpression1791	= { FOLLOW_expression_in_coordinateExpression1791_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LEFT_BRACKET_in_callExpression1819  */
static	ANTLR3_BITWORD FOLLOW_LEFT_BRACKET_in_callExpression1819_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_LEFT_BRACKET_in_callExpression1819	= { FOLLOW_LEFT_BRACKET_in_callExpression1819_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_IDENTIFIER_in_callExpression1821  */
static	ANTLR3_BITWORD FOLLOW_IDENTIFIER_in_callExpression1821_bits[]	= { ANTLR3_UINT64_LIT(0xEFF3BFFA84104008), ANTLR3_UINT64_LIT(0x000000000280BFFF) };
static  ANTLR3_BITSET_LIST FOLLOW_IDENTIFIER_in_callExpression1821	= { FOLLOW_IDENTIFIER_in_callExpression1821_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_callExpression1824  */
static	ANTLR3_BITWORD FOLLOW_expression_in_callExpression1824_bits[]	= { ANTLR3_UINT64_LIT(0xEFF3BFFA84104008), ANTLR3_UINT64_LIT(0x000000000280BFFF) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_callExpression1824	= { FOLLOW_expression_in_callExpression1824_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LEFT_BRACKET_in_callExpression1839  */
static	ANTLR3_BITWORD FOLLOW_LEFT_BRACKET_in_callExpression1839_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_LEFT_BRACKET_in_callExpression1839	= { FOLLOW_LEFT_BRACKET_in_callExpression1839_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_OPERATOR_DOT_in_callExpression1842  */
static	ANTLR3_BITWORD FOLLOW_OPERATOR_DOT_in_callExpression1842_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_OPERATOR_DOT_in_callExpression1842	= { FOLLOW_OPERATOR_DOT_in_callExpression1842_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_callExpression1846  */
static	ANTLR3_BITWORD FOLLOW_expression_in_callExpression1846_bits[]	= { ANTLR3_UINT64_LIT(0x0000000004000000) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_callExpression1846	= { FOLLOW_expression_in_callExpression1846_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_IDENTIFIER_in_callExpression1848  */
static	ANTLR3_BITWORD FOLLOW_IDENTIFIER_in_callExpression1848_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_IDENTIFIER_in_callExpression1848	= { FOLLOW_IDENTIFIER_in_callExpression1848_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_callExpression1854  */
static	ANTLR3_BITWORD FOLLOW_expression_in_callExpression1854_bits[]	= { ANTLR3_UINT64_LIT(0xEFF3BFFA84104008), ANTLR3_UINT64_LIT(0x000000000280BFFF) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_callExpression1854	= { FOLLOW_expression_in_callExpression1854_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LEFT_SQUARE_BRACKET_in_indexAccessExpression1883  */
static	ANTLR3_BITWORD FOLLOW_LEFT_SQUARE_BRACKET_in_indexAccessExpression1883_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_LEFT_SQUARE_BRACKET_in_indexAccessExpression1883	= { FOLLOW_LEFT_SQUARE_BRACKET_in_indexAccessExpression1883_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_indexAccessExpression1887  */
static	ANTLR3_BITWORD FOLLOW_expression_in_indexAccessExpression1887_bits[]	= { ANTLR3_UINT64_LIT(0xEFF3BFFA84104008), ANTLR3_UINT64_LIT(0x000000000280BFFF) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_indexAccessExpression1887	= { FOLLOW_expression_in_indexAccessExpression1887_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_indexAccessExpression1892  */
static	ANTLR3_BITWORD FOLLOW_expression_in_indexAccessExpression1892_bits[]	= { ANTLR3_UINT64_LIT(0xEFF3BFFA84104008), ANTLR3_UINT64_LIT(0x000000000280BFFF) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_indexAccessExpression1892	= { FOLLOW_expression_in_indexAccessExpression1892_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_OPERATOR_EXPR_IF_in_conditionalOperatorExpression1920  */
static	ANTLR3_BITWORD FOLLOW_OPERATOR_EXPR_IF_in_conditionalOperatorExpression1920_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_OPERATOR_EXPR_IF_in_conditionalOperatorExpression1920	= { FOLLOW_OPERATOR_EXPR_IF_in_conditionalOperatorExpression1920_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_conditionalOperatorExpression1924  */
static	ANTLR3_BITWORD FOLLOW_expression_in_conditionalOperatorExpression1924_bits[]	= { ANTLR3_UINT64_LIT(0xEFF3BFFA84104000), ANTLR3_UINT64_LIT(0x000000000280BFFF) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_conditionalOperatorExpression1924	= { FOLLOW_expression_in_conditionalOperatorExpression1924_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_conditionalOperatorExpression1928  */
static	ANTLR3_BITWORD FOLLOW_expression_in_conditionalOperatorExpression1928_bits[]	= { ANTLR3_UINT64_LIT(0xEFF3BFFA84104000), ANTLR3_UINT64_LIT(0x000000000280BFFF) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_conditionalOperatorExpression1928	= { FOLLOW_expression_in_conditionalOperatorExpression1928_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_conditionalOperatorExpression1932  */
static	ANTLR3_BITWORD FOLLOW_expression_in_conditionalOperatorExpression1932_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_conditionalOperatorExpression1932	= { FOLLOW_expression_in_conditionalOperatorExpression1932_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_IDENTIFIER_in_lvalueExpression1955  */
static	ANTLR3_BITWORD FOLLOW_IDENTIFIER_in_lvalueExpression1955_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_IDENTIFIER_in_lvalueExpression1955	= { FOLLOW_IDENTIFIER_in_lvalueExpression1955_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_OPERATOR_DOT_in_lvalueExpression1965  */
static	ANTLR3_BITWORD FOLLOW_OPERATOR_DOT_in_lvalueExpression1965_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_OPERATOR_DOT_in_lvalueExpression1965	= { FOLLOW_OPERATOR_DOT_in_lvalueExpression1965_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_lvalueExpression1969  */
static	ANTLR3_BITWORD FOLLOW_expression_in_lvalueExpression1969_bits[]	= { ANTLR3_UINT64_LIT(0x0000000004000000) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_lvalueExpression1969	= { FOLLOW_expression_in_lvalueExpression1969_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_IDENTIFIER_in_lvalueExpression1971  */
static	ANTLR3_BITWORD FOLLOW_IDENTIFIER_in_lvalueExpression1971_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_IDENTIFIER_in_lvalueExpression1971	= { FOLLOW_IDENTIFIER_in_lvalueExpression1971_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_lvalueIndexAccessExpression_in_lvalueExpression1981  */
static	ANTLR3_BITWORD FOLLOW_lvalueIndexAccessExpression_in_lvalueExpression1981_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_lvalueIndexAccessExpression_in_lvalueExpression1981	= { FOLLOW_lvalueIndexAccessExpression_in_lvalueExpression1981_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LEFT_SQUARE_BRACKET_in_lvalueIndexAccessExpression2007  */
static	ANTLR3_BITWORD FOLLOW_LEFT_SQUARE_BRACKET_in_lvalueIndexAccessExpression2007_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_LEFT_SQUARE_BRACKET_in_lvalueIndexAccessExpression2007	= { FOLLOW_LEFT_SQUARE_BRACKET_in_lvalueIndexAccessExpression2007_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_lvalueIndexAccessExpression2011  */
static	ANTLR3_BITWORD FOLLOW_expression_in_lvalueIndexAccessExpression2011_bits[]	= { ANTLR3_UINT64_LIT(0xEFF3BFFA84104008), ANTLR3_UINT64_LIT(0x000000000280BFFF) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_lvalueIndexAccessExpression2011	= { FOLLOW_expression_in_lvalueIndexAccessExpression2011_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_lvalueIndexAccessExpression2016  */
static	ANTLR3_BITWORD FOLLOW_expression_in_lvalueIndexAccessExpression2016_bits[]	= { ANTLR3_UINT64_LIT(0xEFF3BFFA84104008), ANTLR3_UINT64_LIT(0x000000000280BFFF) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_lvalueIndexAccessExpression2016	= { FOLLOW_expression_in_lvalueIndexAccessExpression2016_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LEFT_CURLY_BRACKET_in_unkeyedCollectionLiteral2077  */
static	ANTLR3_BITWORD FOLLOW_LEFT_CURLY_BRACKET_in_unkeyedCollectionLiteral2077_bits[]	= { ANTLR3_UINT64_LIT(0xEFF3BFFA84104000), ANTLR3_UINT64_LIT(0x000000000280BFFF) };
static  ANTLR3_BITSET_LIST FOLLOW_LEFT_CURLY_BRACKET_in_unkeyedCollectionLiteral2077	= { FOLLOW_LEFT_CURLY_BRACKET_in_unkeyedCollectionLiteral2077_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_unkeyedCollectionLiteral2080  */
static	ANTLR3_BITWORD FOLLOW_expression_in_unkeyedCollectionLiteral2080_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000400), ANTLR3_UINT64_LIT(0x0000000000100000) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_unkeyedCollectionLiteral2080	= { FOLLOW_expression_in_unkeyedCollectionLiteral2080_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_COMMA_in_unkeyedCollectionLiteral2083  */
static	ANTLR3_BITWORD FOLLOW_COMMA_in_unkeyedCollectionLiteral2083_bits[]	= { ANTLR3_UINT64_LIT(0xEFF3BFFA84104000), ANTLR3_UINT64_LIT(0x000000000280BFFF) };
static  ANTLR3_BITSET_LIST FOLLOW_COMMA_in_unkeyedCollectionLiteral2083	= { FOLLOW_COMMA_in_unkeyedCollectionLiteral2083_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_unkeyedCollectionLiteral2085  */
static	ANTLR3_BITWORD FOLLOW_expression_in_unkeyedCollectionLiteral2085_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000400), ANTLR3_UINT64_LIT(0x0000000000100000) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_unkeyedCollectionLiteral2085	= { FOLLOW_expression_in_unkeyedCollectionLiteral2085_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_RIGTH_CURLY_BRACKET_in_unkeyedCollectionLiteral2090  */
static	ANTLR3_BITWORD FOLLOW_RIGTH_CURLY_BRACKET_in_unkeyedCollectionLiteral2090_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_RIGTH_CURLY_BRACKET_in_unkeyedCollectionLiteral2090	= { FOLLOW_RIGTH_CURLY_BRACKET_in_unkeyedCollectionLiteral2090_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_IDENTCHAIN_in_label2107  */
static	ANTLR3_BITWORD FOLLOW_IDENTCHAIN_in_label2107_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_IDENTCHAIN_in_label2107	= { FOLLOW_IDENTCHAIN_in_label2107_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_IDENTIFIER_in_label2109  */
static	ANTLR3_BITWORD FOLLOW_IDENTIFIER_in_label2109_bits[]	= { ANTLR3_UINT64_LIT(0x0000000004000008) };
static  ANTLR3_BITSET_LIST FOLLOW_IDENTIFIER_in_label2109	= { FOLLOW_IDENTIFIER_in_label2109_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_TRUE_LIT_in_label2116  */
static	ANTLR3_BITWORD FOLLOW_TRUE_LIT_in_label2116_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_TRUE_LIT_in_label2116	= { FOLLOW_TRUE_LIT_in_label2116_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_FALSE_LIT_in_label2128  */
static	ANTLR3_BITWORD FOLLOW_FALSE_LIT_in_label2128_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_FALSE_LIT_in_label2128	= { FOLLOW_FALSE_LIT_in_label2128_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_NUMBER_in_label2133  */
static	ANTLR3_BITWORD FOLLOW_NUMBER_in_label2133_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_NUMBER_in_label2133	= { FOLLOW_NUMBER_in_label2133_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_STRING_in_label2138  */
static	ANTLR3_BITWORD FOLLOW_STRING_in_label2138_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_STRING_in_label2138	= { FOLLOW_STRING_in_label2138_bits, 1	};


/* ==============================================
 * Parsing rules
 */
/**
 * $ANTLR start script
 * D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:101:1: script : ^( SCRIPT ( metadata )? ^( DECLARATIONS ( declaration )* ) block ) ;
 */
static void
script(pGeoGenScriptDecls ctx)
{
    CodeBlock* block1;
    #undef	RETURN_TYPE_block1
    #define	RETURN_TYPE_block1 CodeBlock*

    /* Initialize rule variables
     */

    {
        // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:101:7: ( ^( SCRIPT ( metadata )? ^( DECLARATIONS ( declaration )* ) block ) )
        // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:101:9: ^( SCRIPT ( metadata )? ^( DECLARATIONS ( declaration )* ) block )
        {
             MATCHT(SCRIPT, &FOLLOW_SCRIPT_in_script92);
            if  (HASEXCEPTION())
            {
                goto rulescriptEx;
            }


            MATCHT(ANTLR3_TOKEN_DOWN, NULL);
            if  (HASEXCEPTION())
            {
                goto rulescriptEx;
            }

            // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:101:18: ( metadata )?
            {
                int alt1=2;
                switch ( LA(1) )
                {
                    case METADATA:
                    	{
                    		alt1=1;
                    	}
                        break;
                }

                switch (alt1)
                {
            	case 1:
            	    // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:101:18: metadata
            	    {
            	        FOLLOWPUSH(FOLLOW_metadata_in_script94);
            	        metadata(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulescriptEx;
            	        }


            	    }
            	    break;

                }
            }

             MATCHT(DECLARATIONS, &FOLLOW_DECLARATIONS_in_script98);
            if  (HASEXCEPTION())
            {
                goto rulescriptEx;
            }


            if ( LA(1)==ANTLR3_TOKEN_DOWN ) {
                MATCHT(ANTLR3_TOKEN_DOWN, NULL);
                if  (HASEXCEPTION())
                {
                    goto rulescriptEx;
                }

                // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:101:43: ( declaration )*

                for (;;)
                {
                    int alt2=2;
                    switch ( LA(1) )
                    {
                    case ENUM:
                    case FUNCTION:
                    	{
                    		alt2=1;
                    	}
                        break;

                    }

                    switch (alt2)
                    {
                	case 1:
                	    // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:101:43: declaration
                	    {
                	        FOLLOWPUSH(FOLLOW_declaration_in_script100);
                	        declaration(ctx);

                	        FOLLOWPOP();
                	        if  (HASEXCEPTION())
                	        {
                	            goto rulescriptEx;
                	        }


                	    }
                	    break;

                	default:
                	    goto loop2;	/* break out of the loop */
                	    break;
                    }
                }
                loop2: ; /* Jump out to here if this rule does not match */


                MATCHT(ANTLR3_TOKEN_UP, NULL);
                if  (HASEXCEPTION())
                {
                    goto rulescriptEx;
                }

            }


            FOLLOWPUSH(FOLLOW_block_in_script104);
            block1=block(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulescriptEx;
            }


            MATCHT(ANTLR3_TOKEN_UP, NULL);
            if  (HASEXCEPTION())
            {
                goto rulescriptEx;
            }



            {
                 
                	ctx->rootCodeBlock->MoveInstructionsFrom(*block1
                ); 
                	delete block1
                ; 

            }


        }

    }

    // This is where rules clean up and exit
    //
    goto rulescriptEx; /* Prevent compiler warnings */
    rulescriptEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end script */

/**
 * $ANTLR start metadata
 * D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:107:1: metadata : ^( 'metadata' metadataKeyValueCollection ) ;
 */
static void
metadata(pGeoGenScriptDecls ctx)
{
    MetadataValue* metadataKeyValueCollection2;
    #undef	RETURN_TYPE_metadataKeyValueCollection2
    #define	RETURN_TYPE_metadataKeyValueCollection2 MetadataValue*

    /* Initialize rule variables
     */

    {
        // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:107:9: ( ^( 'metadata' metadataKeyValueCollection ) )
        // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:107:11: ^( 'metadata' metadataKeyValueCollection )
        {
             MATCHT(METADATA, &FOLLOW_METADATA_in_metadata124);
            if  (HASEXCEPTION())
            {
                goto rulemetadataEx;
            }


            MATCHT(ANTLR3_TOKEN_DOWN, NULL);
            if  (HASEXCEPTION())
            {
                goto rulemetadataEx;
            }

            FOLLOWPUSH(FOLLOW_metadataKeyValueCollection_in_metadata126);
            metadataKeyValueCollection2=metadataKeyValueCollection(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulemetadataEx;
            }


            MATCHT(ANTLR3_TOKEN_UP, NULL);
            if  (HASEXCEPTION())
            {
                goto rulemetadataEx;
            }



            {
                 
                	ctx->compiledScript->GetMetadata().MoveKeyValuesFrom(*dynamic_cast<MetadataKeyValueCollection*>(metadataKeyValueCollection2
                ));
                	delete metadataKeyValueCollection2
                ;

            }


        }

    }

    // This is where rules clean up and exit
    //
    goto rulemetadataEx; /* Prevent compiler warnings */
    rulemetadataEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end metadata */

/**
 * $ANTLR start metadataKeyValueCollection
 * D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:113:1: metadataKeyValueCollection returns [MetadataValue* value] : ^( COLLECTION ( metadataKeyValuePair )* ) ;
 */
static MetadataValue*
metadataKeyValueCollection(pGeoGenScriptDecls ctx)
{
    MetadataValue* value;


    pANTLR3_BASE_TREE    COLLECTION4;
    GeoGenScriptDecls_metadataKeyValuePair_return metadataKeyValuePair3;
    #undef	RETURN_TYPE_metadataKeyValuePair3
    #define	RETURN_TYPE_metadataKeyValuePair3 GeoGenScriptDecls_metadataKeyValuePair_return

    /* Initialize rule variables
     */


    	MetadataKeyValueCollection* ret = new MetadataKeyValueCollection();
    	value= ret;
    	

    COLLECTION4       = NULL;

    {
        // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:117:3: ( ^( COLLECTION ( metadataKeyValuePair )* ) )
        // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:117:5: ^( COLLECTION ( metadataKeyValuePair )* )
        {
            COLLECTION4 = (pANTLR3_BASE_TREE) MATCHT(COLLECTION, &FOLLOW_COLLECTION_in_metadataKeyValueCollection148);
            if  (HASEXCEPTION())
            {
                goto rulemetadataKeyValueCollectionEx;
            }


            if ( LA(1)==ANTLR3_TOKEN_DOWN ) {
                MATCHT(ANTLR3_TOKEN_DOWN, NULL);
                if  (HASEXCEPTION())
                {
                    goto rulemetadataKeyValueCollectionEx;
                }

                // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:117:18: ( metadataKeyValuePair )*

                for (;;)
                {
                    int alt3=2;
                    switch ( LA(1) )
                    {
                    case IDENTIFIER:
                    case NUMBER:
                    	{
                    		alt3=1;
                    	}
                        break;

                    }

                    switch (alt3)
                    {
                	case 1:
                	    // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:117:19: metadataKeyValuePair
                	    {
                	        FOLLOWPUSH(FOLLOW_metadataKeyValuePair_in_metadataKeyValueCollection151);
                	        metadataKeyValuePair3=metadataKeyValuePair(ctx);

                	        FOLLOWPOP();
                	        if  (HASEXCEPTION())
                	        {
                	            goto rulemetadataKeyValueCollectionEx;
                	        }


                	        {
                	             
                	            		if(!ret->AddItem(metadataKeyValuePair3.name
                	            , metadataKeyValuePair3.value
                	            ))
                	            		{
                	            			CodeLocation location((COLLECTION4->getLine(COLLECTION4)), (COLLECTION4->getCharPositionInLine(COLLECTION4)));
                	            			throw CompilerException(GGE1401_MetadataValueAlreadyDefined, location);
                	            		}
                	            		/*delete 
                	            metadataKeyValuePair3.name
                	            ; */
                	            	
                	        }


                	    }
                	    break;

                	default:
                	    goto loop3;	/* break out of the loop */
                	    break;
                    }
                }
                loop3: ; /* Jump out to here if this rule does not match */


                MATCHT(ANTLR3_TOKEN_UP, NULL);
                if  (HASEXCEPTION())
                {
                    goto rulemetadataKeyValueCollectionEx;
                }

            }


        }

    }

    // This is where rules clean up and exit
    //
    goto rulemetadataKeyValueCollectionEx; /* Prevent compiler warnings */
    rulemetadataKeyValueCollectionEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return value;
}
/* $ANTLR end metadataKeyValueCollection */

/**
 * $ANTLR start metadataKeyValuePair
 * D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:127:1: metadataKeyValuePair returns [char* name, MetadataValue* value] : ( ^( IDENTIFIER metadataKeyValueValue ) | ^( NUMBER metadataKeyValueValue ( '@' )? ) );
 */
static GeoGenScriptDecls_metadataKeyValuePair_return
metadataKeyValuePair(pGeoGenScriptDecls ctx)
{
    GeoGenScriptDecls_metadataKeyValuePair_return retval;


    pANTLR3_BASE_TREE    IDENTIFIER5;
    pANTLR3_BASE_TREE    NUMBER7;
    MetadataValue* metadataKeyValueValue6;
    #undef	RETURN_TYPE_metadataKeyValueValue6
    #define	RETURN_TYPE_metadataKeyValueValue6 MetadataValue*

    MetadataValue* metadataKeyValueValue8;
    #undef	RETURN_TYPE_metadataKeyValueValue8
    #define	RETURN_TYPE_metadataKeyValueValue8 MetadataValue*

    /* Initialize rule variables
     */

     retval.value= NULL;
     
    IDENTIFIER5       = NULL;
    NUMBER7       = NULL;
    retval.start = LT(1); retval.stop = retval.start;


    {
        {
            //  D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:127:88: ( ^( IDENTIFIER metadataKeyValueValue ) | ^( NUMBER metadataKeyValueValue ( '@' )? ) )

            ANTLR3_UINT32 alt5;

            alt5=2;

            switch ( LA(1) )
            {
            case IDENTIFIER:
            	{
            		alt5=1;
            	}
                break;
            case NUMBER:
            	{
            		alt5=2;
            	}
                break;

            default:
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 5;
                EXCEPTION->state        = 0;


                goto rulemetadataKeyValuePairEx;

            }

            switch (alt5)
            {
        	case 1:
        	    // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:128:2: ^( IDENTIFIER metadataKeyValueValue )
        	    {
        	        IDENTIFIER5 = (pANTLR3_BASE_TREE) MATCHT(IDENTIFIER, &FOLLOW_IDENTIFIER_in_metadataKeyValuePair177);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulemetadataKeyValuePairEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_DOWN, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulemetadataKeyValuePairEx;
        	        }

        	        FOLLOWPUSH(FOLLOW_metadataKeyValueValue_in_metadataKeyValuePair179);
        	        metadataKeyValueValue6=metadataKeyValueValue(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulemetadataKeyValuePairEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_UP, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulemetadataKeyValuePairEx;
        	        }



        	        {
        	             retval.name= (char*)(IDENTIFIER5->getText(IDENTIFIER5))->chars;
        	             retval.value= 
        	            metadataKeyValueValue6
        	            ;
        	             
        	        }


        	    }
        	    break;
        	case 2:
        	    // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:129:4: ^( NUMBER metadataKeyValueValue ( '@' )? )
        	    {
        	        NUMBER7 = (pANTLR3_BASE_TREE) MATCHT(NUMBER, &FOLLOW_NUMBER_in_metadataKeyValuePair188);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulemetadataKeyValuePairEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_DOWN, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulemetadataKeyValuePairEx;
        	        }

        	        FOLLOWPUSH(FOLLOW_metadataKeyValueValue_in_metadataKeyValuePair190);
        	        metadataKeyValueValue8=metadataKeyValueValue(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulemetadataKeyValuePairEx;
        	        }


        	        // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:129:35: ( '@' )?
        	        {
        	            int alt4=2;
        	            switch ( LA(1) )
        	            {
        	                case OPERATOR_RELATIVE:
        	                	{
        	                		alt4=1;
        	                	}
        	                    break;
        	            }

        	            switch (alt4)
        	            {
        	        	case 1:
        	        	    // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:129:35: '@'
        	        	    {
        	        	         MATCHT(OPERATOR_RELATIVE, &FOLLOW_OPERATOR_RELATIVE_in_metadataKeyValuePair192);
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto rulemetadataKeyValuePairEx;
        	        	        }


        	        	    }
        	        	    break;

        	            }
        	        }

        	        MATCHT(ANTLR3_TOKEN_UP, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulemetadataKeyValuePairEx;
        	        }



        	        {
        	             retval.name= (char*)(NUMBER7->getText(NUMBER7))->chars;
        	             retval.value= 
        	            metadataKeyValueValue8
        	            ;
        	             
        	        }


        	    }
        	    break;

            }
        }
    }

    // This is where rules clean up and exit
    //
    goto rulemetadataKeyValuePairEx; /* Prevent compiler warnings */
    rulemetadataKeyValuePairEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return retval;
}
/* $ANTLR end metadataKeyValuePair */

/**
 * $ANTLR start metadataKeyValueValue
 * D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:131:1: metadataKeyValueValue returns [MetadataValue* value] : ( STRING | TRUE_LIT | FALSE_LIT | NUMBER | IDENTIFIER | metadataKeyValueCollection );
 */
static MetadataValue*
metadataKeyValueValue(pGeoGenScriptDecls ctx)
{
    MetadataValue* value;


    pANTLR3_BASE_TREE    STRING9;
    pANTLR3_BASE_TREE    NUMBER10;
    pANTLR3_BASE_TREE    IDENTIFIER11;
    MetadataValue* metadataKeyValueCollection12;
    #undef	RETURN_TYPE_metadataKeyValueCollection12
    #define	RETURN_TYPE_metadataKeyValueCollection12 MetadataValue*

    /* Initialize rule variables
     */

     value= NULL;
     
    STRING9       = NULL;
    NUMBER10       = NULL;
    IDENTIFIER11       = NULL;

    {
        {
            //  D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:131:77: ( STRING | TRUE_LIT | FALSE_LIT | NUMBER | IDENTIFIER | metadataKeyValueCollection )

            ANTLR3_UINT32 alt6;

            alt6=6;

            switch ( LA(1) )
            {
            case STRING:
            	{
            		alt6=1;
            	}
                break;
            case TRUE_LIT:
            	{
            		alt6=2;
            	}
                break;
            case FALSE_LIT:
            	{
            		alt6=3;
            	}
                break;
            case NUMBER:
            	{
            		alt6=4;
            	}
                break;
            case IDENTIFIER:
            	{
            		alt6=5;
            	}
                break;
            case COLLECTION:
            	{
            		alt6=6;
            	}
                break;

            default:
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 6;
                EXCEPTION->state        = 0;


                goto rulemetadataKeyValueValueEx;

            }

            switch (alt6)
            {
        	case 1:
        	    // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:132:2: STRING
        	    {
        	        STRING9 = (pANTLR3_BASE_TREE) MATCHT(STRING, &FOLLOW_STRING_in_metadataKeyValueValue214);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulemetadataKeyValueValueEx;
        	        }


        	        {
        	             value= new MetadataString((char*)(STRING9->getText(STRING9))->chars);
        	             
        	        }


        	    }
        	    break;
        	case 2:
        	    // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:133:4: TRUE_LIT
        	    {
        	         MATCHT(TRUE_LIT, &FOLLOW_TRUE_LIT_in_metadataKeyValueValue222);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulemetadataKeyValueValueEx;
        	        }


        	        {
        	             value= new MetadataBoolean(true);
        	             
        	        }


        	    }
        	    break;
        	case 3:
        	    // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:134:4: FALSE_LIT
        	    {
        	         MATCHT(FALSE_LIT, &FOLLOW_FALSE_LIT_in_metadataKeyValueValue230);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulemetadataKeyValueValueEx;
        	        }


        	        {
        	             value= new MetadataBoolean(false);
        	             
        	        }


        	    }
        	    break;
        	case 4:
        	    // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:135:4: NUMBER
        	    {
        	        NUMBER10 = (pANTLR3_BASE_TREE) MATCHT(NUMBER, &FOLLOW_NUMBER_in_metadataKeyValueValue238);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulemetadataKeyValueValueEx;
        	        }


        	        {
        	             value= new MetadataNumber(StringToNumber((char*)(NUMBER10->getText(NUMBER10))->chars));
        	             
        	        }


        	    }
        	    break;
        	case 5:
        	    // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:136:4: IDENTIFIER
        	    {
        	        IDENTIFIER11 = (pANTLR3_BASE_TREE) MATCHT(IDENTIFIER, &FOLLOW_IDENTIFIER_in_metadataKeyValueValue245);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulemetadataKeyValueValueEx;
        	        }


        	        {
        	             value= new MetadataIdentifier((char*)(IDENTIFIER11->getText(IDENTIFIER11))->chars);
        	             
        	        }


        	    }
        	    break;
        	case 6:
        	    // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:137:4: metadataKeyValueCollection
        	    {
        	        FOLLOWPUSH(FOLLOW_metadataKeyValueCollection_in_metadataKeyValueValue252);
        	        metadataKeyValueCollection12=metadataKeyValueCollection(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulemetadataKeyValueValueEx;
        	        }


        	        {
        	             value= 
        	            metadataKeyValueCollection12
        	            ;
        	             
        	        }


        	    }
        	    break;

            }
        }
    }

    // This is where rules clean up and exit
    //
    goto rulemetadataKeyValueValueEx; /* Prevent compiler warnings */
    rulemetadataKeyValueValueEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return value;
}
/* $ANTLR end metadataKeyValueValue */

/**
 * $ANTLR start keyValueCollection
 * D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:139:1: keyValueCollection : ^( COLLECTION ( keyValuePair )* ) ;
 */
static void
keyValueCollection(pGeoGenScriptDecls ctx)
{
    /* Initialize rule variables
     */

    {
        // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:139:19: ( ^( COLLECTION ( keyValuePair )* ) )
        // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:139:21: ^( COLLECTION ( keyValuePair )* )
        {
             MATCHT(COLLECTION, &FOLLOW_COLLECTION_in_keyValueCollection262);
            if  (HASEXCEPTION())
            {
                goto rulekeyValueCollectionEx;
            }


            if ( LA(1)==ANTLR3_TOKEN_DOWN ) {
                MATCHT(ANTLR3_TOKEN_DOWN, NULL);
                if  (HASEXCEPTION())
                {
                    goto rulekeyValueCollectionEx;
                }

                // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:139:34: ( keyValuePair )*

                for (;;)
                {
                    int alt7=2;
                    switch ( LA(1) )
                    {
                    case IDENTIFIER:
                    case NUMBER:
                    	{
                    		alt7=1;
                    	}
                        break;

                    }

                    switch (alt7)
                    {
                	case 1:
                	    // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:139:34: keyValuePair
                	    {
                	        FOLLOWPUSH(FOLLOW_keyValuePair_in_keyValueCollection264);
                	        keyValuePair(ctx);

                	        FOLLOWPOP();
                	        if  (HASEXCEPTION())
                	        {
                	            goto rulekeyValueCollectionEx;
                	        }


                	    }
                	    break;

                	default:
                	    goto loop7;	/* break out of the loop */
                	    break;
                    }
                }
                loop7: ; /* Jump out to here if this rule does not match */


                MATCHT(ANTLR3_TOKEN_UP, NULL);
                if  (HASEXCEPTION())
                {
                    goto rulekeyValueCollectionEx;
                }

            }


        }

    }

    // This is where rules clean up and exit
    //
    goto rulekeyValueCollectionEx; /* Prevent compiler warnings */
    rulekeyValueCollectionEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end keyValueCollection */

/**
 * $ANTLR start keyValuePair
 * D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:141:1: keyValuePair : ( ^( IDENTIFIER keyValueValue ) | ^( NUMBER keyValueValue ( '@' )? ) );
 */
static void
keyValuePair(pGeoGenScriptDecls ctx)
{
    /* Initialize rule variables
     */

    {
        {
            //  D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:141:13: ( ^( IDENTIFIER keyValueValue ) | ^( NUMBER keyValueValue ( '@' )? ) )

            ANTLR3_UINT32 alt9;

            alt9=2;

            switch ( LA(1) )
            {
            case IDENTIFIER:
            	{
            		alt9=1;
            	}
                break;
            case NUMBER:
            	{
            		alt9=2;
            	}
                break;

            default:
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 9;
                EXCEPTION->state        = 0;


                goto rulekeyValuePairEx;

            }

            switch (alt9)
            {
        	case 1:
        	    // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:142:2: ^( IDENTIFIER keyValueValue )
        	    {
        	         MATCHT(IDENTIFIER, &FOLLOW_IDENTIFIER_in_keyValuePair276);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulekeyValuePairEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_DOWN, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulekeyValuePairEx;
        	        }

        	        FOLLOWPUSH(FOLLOW_keyValueValue_in_keyValuePair278);
        	        keyValueValue(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulekeyValuePairEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_UP, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulekeyValuePairEx;
        	        }



        	    }
        	    break;
        	case 2:
        	    // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:143:4: ^( NUMBER keyValueValue ( '@' )? )
        	    {
        	         MATCHT(NUMBER, &FOLLOW_NUMBER_in_keyValuePair285);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulekeyValuePairEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_DOWN, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulekeyValuePairEx;
        	        }

        	        FOLLOWPUSH(FOLLOW_keyValueValue_in_keyValuePair287);
        	        keyValueValue(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulekeyValuePairEx;
        	        }


        	        // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:143:27: ( '@' )?
        	        {
        	            int alt8=2;
        	            switch ( LA(1) )
        	            {
        	                case OPERATOR_RELATIVE:
        	                	{
        	                		alt8=1;
        	                	}
        	                    break;
        	            }

        	            switch (alt8)
        	            {
        	        	case 1:
        	        	    // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:143:27: '@'
        	        	    {
        	        	         MATCHT(OPERATOR_RELATIVE, &FOLLOW_OPERATOR_RELATIVE_in_keyValuePair289);
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto rulekeyValuePairEx;
        	        	        }


        	        	    }
        	        	    break;

        	            }
        	        }

        	        MATCHT(ANTLR3_TOKEN_UP, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulekeyValuePairEx;
        	        }



        	    }
        	    break;

            }
        }
    }

    // This is where rules clean up and exit
    //
    goto rulekeyValuePairEx; /* Prevent compiler warnings */
    rulekeyValuePairEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end keyValuePair */

/**
 * $ANTLR start keyValueValue
 * D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:145:1: keyValueValue : ( expression | keyValueCollection );
 */
static void
keyValueValue(pGeoGenScriptDecls ctx)
{
    /* Initialize rule variables
     */

    {
        {
            //  D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:145:14: ( expression | keyValueCollection )

            ANTLR3_UINT32 alt10;

            alt10=2;

            switch ( LA(1) )
            {
            case COORDINATE:
            case FALSE_LIT:
            case IDENTIFIER:
            case LEFT_BRACKET:
            case LEFT_SQUARE_BRACKET:
            case NUMBER:
            case OPERATOR_ASSIGN:
            case OPERATOR_ASSIGN_AND:
            case OPERATOR_ASSIGN_DIVIDE:
            case OPERATOR_ASSIGN_LSHIFT:
            case OPERATOR_ASSIGN_MINUS:
            case OPERATOR_ASSIGN_MODULO:
            case OPERATOR_ASSIGN_OR:
            case OPERATOR_ASSIGN_PLUS:
            case OPERATOR_ASSIGN_RSHIFT:
            case OPERATOR_ASSIGN_TIMES:
            case OPERATOR_BIT_AND:
            case OPERATOR_BIT_OR:
            case OPERATOR_BIT_XOR:
            case OPERATOR_DECREMENT_POST:
            case OPERATOR_DECREMENT_PRE:
            case OPERATOR_DIVIDE:
            case OPERATOR_DOT:
            case OPERATOR_EQUAL_TO:
            case OPERATOR_EXPR_IF:
            case OPERATOR_GREATER_THAN:
            case OPERATOR_GREATER_THAN_OR_EQUAL_TO:
            case OPERATOR_INCREMENT_POST:
            case OPERATOR_INCREMENT_PRE:
            case OPERATOR_IS:
            case OPERATOR_LESS_THAN:
            case OPERATOR_LESS_THAN_OR_EQUAL_TO:
            case OPERATOR_LSHIFT:
            case OPERATOR_MINUS:
            case OPERATOR_MINUS_UN:
            case OPERATOR_MODULO:
            case OPERATOR_NOT:
            case OPERATOR_NOT_EQUAL_TO:
            case OPERATOR_PLUS:
            case OPERATOR_PLUS_UN:
            case OPERATOR_RELATIVE:
            case OPERATOR_REL_AND:
            case OPERATOR_REL_OR:
            case OPERATOR_RSHIFT:
            case OPERATOR_TIMES:
            case STRING:
            case TRUE_LIT:
            	{
            		alt10=1;
            	}
                break;
            case COLLECTION:
            	{
            		alt10=2;
            	}
                break;

            default:
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 10;
                EXCEPTION->state        = 0;


                goto rulekeyValueValueEx;

            }

            switch (alt10)
            {
        	case 1:
        	    // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:145:16: expression
        	    {
        	        FOLLOWPUSH(FOLLOW_expression_in_keyValueValue298);
        	        expression(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulekeyValueValueEx;
        	        }


        	    }
        	    break;
        	case 2:
        	    // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:145:29: keyValueCollection
        	    {
        	        FOLLOWPUSH(FOLLOW_keyValueCollection_in_keyValueValue302);
        	        keyValueCollection(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulekeyValueValueEx;
        	        }


        	    }
        	    break;

            }
        }
    }

    // This is where rules clean up and exit
    //
    goto rulekeyValueValueEx; /* Prevent compiler warnings */
    rulekeyValueValueEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end keyValueValue */

/**
 * $ANTLR start declaration
 * D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:147:1: declaration : ( enumDeclaration | functionDeclaration );
 */
static void
declaration(pGeoGenScriptDecls ctx)
{
    /* Initialize rule variables
     */

    {
        {
            //  D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:147:12: ( enumDeclaration | functionDeclaration )

            ANTLR3_UINT32 alt11;

            alt11=2;

            switch ( LA(1) )
            {
            case ENUM:
            	{
            		alt11=1;
            	}
                break;
            case FUNCTION:
            	{
            		alt11=2;
            	}
                break;

            default:
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 11;
                EXCEPTION->state        = 0;


                goto ruledeclarationEx;

            }

            switch (alt11)
            {
        	case 1:
        	    // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:147:14: enumDeclaration
        	    {
        	        FOLLOWPUSH(FOLLOW_enumDeclaration_in_declaration309);
        	        enumDeclaration(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruledeclarationEx;
        	        }


        	    }
        	    break;
        	case 2:
        	    // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:147:32: functionDeclaration
        	    {
        	        FOLLOWPUSH(FOLLOW_functionDeclaration_in_declaration313);
        	        functionDeclaration(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruledeclarationEx;
        	        }


        	    }
        	    break;

            }
        }
    }

    // This is where rules clean up and exit
    //
    goto ruledeclarationEx; /* Prevent compiler warnings */
    ruledeclarationEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end declaration */

/**
 * $ANTLR start enumDeclaration
 * D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:149:1: enumDeclaration : ^( ENUM IDENTIFIER enumValues ) ;
 */
static void
enumDeclaration(pGeoGenScriptDecls ctx)
{
    pANTLR3_BASE_TREE    ENUM13;
    pANTLR3_BASE_TREE    IDENTIFIER14;
    map<int, std::string> enumValues15;
    #undef	RETURN_TYPE_enumValues15
    #define	RETURN_TYPE_enumValues15 map<int, std::string>

    /* Initialize rule variables
     */

    ENUM13       = NULL;
    IDENTIFIER14       = NULL;

    {
        // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:149:16: ( ^( ENUM IDENTIFIER enumValues ) )
        // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:149:18: ^( ENUM IDENTIFIER enumValues )
        {
            ENUM13 = (pANTLR3_BASE_TREE) MATCHT(ENUM, &FOLLOW_ENUM_in_enumDeclaration321);
            if  (HASEXCEPTION())
            {
                goto ruleenumDeclarationEx;
            }


            MATCHT(ANTLR3_TOKEN_DOWN, NULL);
            if  (HASEXCEPTION())
            {
                goto ruleenumDeclarationEx;
            }

            IDENTIFIER14 = (pANTLR3_BASE_TREE) MATCHT(IDENTIFIER, &FOLLOW_IDENTIFIER_in_enumDeclaration323);
            if  (HASEXCEPTION())
            {
                goto ruleenumDeclarationEx;
            }


            FOLLOWPUSH(FOLLOW_enumValues_in_enumDeclaration325);
            enumValues15=enumValues(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleenumDeclarationEx;
            }


            MATCHT(ANTLR3_TOKEN_UP, NULL);
            if  (HASEXCEPTION())
            {
                goto ruleenumDeclarationEx;
            }



            {

                	CodeLocation location((ENUM13->getLine(ENUM13)), (ENUM13->getCharPositionInLine(ENUM13)));
                		
                	EnumTypeDefinition* decl = new EnumTypeDefinition(location, (char*)(IDENTIFIER14->getText(IDENTIFIER14))->chars, 
                enumValues15
                );
                	
                	if (!ctx->compiledScript->AddTypeDefinition(decl)){
                		throw SymbolRedefinitionException(GGE1308_TypeAlreadyDefined, location, decl->GetName());
                	}

            }


        }

    }

    // This is where rules clean up and exit
    //
    goto ruleenumDeclarationEx; /* Prevent compiler warnings */
    ruleenumDeclarationEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end enumDeclaration */

/**
 * $ANTLR start enumValues
 * D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:160:1: enumValues returns [map<int, std::string> returnEnumValues] : ^( VALUES ( ^( IDENTIFIER ( NUMBER )? ) )* ) ;
 */
static map<int, std::string>
enumValues(pGeoGenScriptDecls ctx)
{
    map<int, std::string> returnEnumValues;


    pANTLR3_BASE_TREE    NUMBER16;
    pANTLR3_BASE_TREE    IDENTIFIER17;

    /* Initialize rule variables
     */

     map<std::string, int> tempEnumValues; int number = -1; 
    NUMBER16       = NULL;
    IDENTIFIER17       = NULL;

    {
        // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:162:3: ( ^( VALUES ( ^( IDENTIFIER ( NUMBER )? ) )* ) )
        // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:162:3: ^( VALUES ( ^( IDENTIFIER ( NUMBER )? ) )* )
        {
             MATCHT(VALUES, &FOLLOW_VALUES_in_enumValues346);
            if  (HASEXCEPTION())
            {
                goto ruleenumValuesEx;
            }


            if ( LA(1)==ANTLR3_TOKEN_DOWN ) {
                MATCHT(ANTLR3_TOKEN_DOWN, NULL);
                if  (HASEXCEPTION())
                {
                    goto ruleenumValuesEx;
                }

                // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:162:12: ( ^( IDENTIFIER ( NUMBER )? ) )*

                for (;;)
                {
                    int alt13=2;
                    switch ( LA(1) )
                    {
                    case IDENTIFIER:
                    	{
                    		alt13=1;
                    	}
                        break;

                    }

                    switch (alt13)
                    {
                	case 1:
                	    // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:162:13: ^( IDENTIFIER ( NUMBER )? )
                	    {
                	        IDENTIFIER17 = (pANTLR3_BASE_TREE) MATCHT(IDENTIFIER, &FOLLOW_IDENTIFIER_in_enumValues350);
                	        if  (HASEXCEPTION())
                	        {
                	            goto ruleenumValuesEx;
                	        }


                	        if ( LA(1)==ANTLR3_TOKEN_DOWN ) {
                	            MATCHT(ANTLR3_TOKEN_DOWN, NULL);
                	            if  (HASEXCEPTION())
                	            {
                	                goto ruleenumValuesEx;
                	            }

                	            // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:162:26: ( NUMBER )?
                	            {
                	                int alt12=2;
                	                switch ( LA(1) )
                	                {
                	                    case NUMBER:
                	                    	{
                	                    		alt12=1;
                	                    	}
                	                        break;
                	                }

                	                switch (alt12)
                	                {
                	            	case 1:
                	            	    // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:162:27: NUMBER
                	            	    {
                	            	        NUMBER16 = (pANTLR3_BASE_TREE) MATCHT(NUMBER, &FOLLOW_NUMBER_in_enumValues353);
                	            	        if  (HASEXCEPTION())
                	            	        {
                	            	            goto ruleenumValuesEx;
                	            	        }


                	            	        {
                	            	             number = (int)StringToNumber((char*)(NUMBER16->getText(NUMBER16))->chars); 
                	            	        }


                	            	    }
                	            	    break;

                	                }
                	            }

                	            MATCHT(ANTLR3_TOKEN_UP, NULL);
                	            if  (HASEXCEPTION())
                	            {
                	                goto ruleenumValuesEx;
                	            }

                	        }


                	        {
                	             
                	            		std::string valueName = (char*)(IDENTIFIER17->getText(IDENTIFIER17))->chars;
                	            	
                	            		CodeLocation enumValueLocation((IDENTIFIER17->getLine(IDENTIFIER17)), (IDENTIFIER17->getCharPositionInLine(IDENTIFIER17)));
                	            		
                	            		if(!IsNumberInt(number))
                	            		{
                	            			throw InvalidSymbolDefinitionException(GGE1310_EnumValueNotInteger, enumValueLocation, valueName);
                	            		}
                	            		
                	            		
                	            		if(!tempEnumValues.insert(std::pair<std::string, int>(valueName, NumberToInt(number))).second)
                	            		{		
                	            			throw SymbolRedefinitionException(GGE1309_EnumValueAlreadyDefined, enumValueLocation, valueName);
                	            		}
                	            		
                	            		number = -1;
                	            	
                	        }


                	    }
                	    break;

                	default:
                	    goto loop13;	/* break out of the loop */
                	    break;
                    }
                }
                loop13: ; /* Jump out to here if this rule does not match */


                MATCHT(ANTLR3_TOKEN_UP, NULL);
                if  (HASEXCEPTION())
                {
                    goto ruleenumValuesEx;
                }

            }


            {

                	// Assign unused numbers to values which have int value -1
                	for(std::map<std::string, int>::iterator it = tempEnumValues.begin(); it != tempEnumValues.end(); it++)
                	{
                		if(it->second > -1)
                		{
                			continue;
                		}
                	
                		int min = std::numeric_limits<int>::max();
                		for(std::map<std::string, int>::iterator it2 = tempEnumValues.begin(); it2 != tempEnumValues.end(); it2++)
                		{
                			int current = it2->second;
                			if(current > -1 && current < min)
                			{
                				min = current;
                			}		
                		}
                		
                		if(min == std::numeric_limits<int>::max())
                		{
                			min = 0;
                		}	
                				
                		min++;
                		
                		it->second = min;
                		
                		returnEnumValues.insert(std::pair<int, std::string>(min, it->first));
                	}

            }


        }

    }

    // This is where rules clean up and exit
    //
    goto ruleenumValuesEx; /* Prevent compiler warnings */
    ruleenumValuesEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return returnEnumValues;
}
/* $ANTLR end enumValues */

/**
 * $ANTLR start functionDeclaration
 * D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:215:1: functionDeclaration : ^( FUNCTION name= IDENTIFIER ^( PARAMETERS (formalParameters+= IDENTIFIER )* ) block ) ;
 */
static void
functionDeclaration(pGeoGenScriptDecls ctx)
{
    pANTLR3_BASE_TREE    name;
    pANTLR3_BASE_TREE    FUNCTION18;
    pANTLR3_BASE_TREE    formalParameters;
    pANTLR3_VECTOR    list_formalParameters;
    CodeBlock* block19;
    #undef	RETURN_TYPE_block19
    #define	RETURN_TYPE_block19 CodeBlock*

    /* Initialize rule variables
     */

     ctx->isInFunction = true; /*functionDeclaration::localVariableDefinitions = new SymbolDefinitionTable<VariableDefinition>();*/
    name       = NULL;
    FUNCTION18       = NULL;
    formalParameters       = NULL;
    list_formalParameters     = NULL;

    {
        // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:220:3: ( ^( FUNCTION name= IDENTIFIER ^( PARAMETERS (formalParameters+= IDENTIFIER )* ) block ) )
        // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:220:3: ^( FUNCTION name= IDENTIFIER ^( PARAMETERS (formalParameters+= IDENTIFIER )* ) block )
        {
            FUNCTION18 = (pANTLR3_BASE_TREE) MATCHT(FUNCTION, &FOLLOW_FUNCTION_in_functionDeclaration390);
            if  (HASEXCEPTION())
            {
                goto rulefunctionDeclarationEx;
            }


            MATCHT(ANTLR3_TOKEN_DOWN, NULL);
            if  (HASEXCEPTION())
            {
                goto rulefunctionDeclarationEx;
            }

            name = (pANTLR3_BASE_TREE) MATCHT(IDENTIFIER, &FOLLOW_IDENTIFIER_in_functionDeclaration394);
            if  (HASEXCEPTION())
            {
                goto rulefunctionDeclarationEx;
            }


             MATCHT(PARAMETERS, &FOLLOW_PARAMETERS_in_functionDeclaration397);
            if  (HASEXCEPTION())
            {
                goto rulefunctionDeclarationEx;
            }


            if ( LA(1)==ANTLR3_TOKEN_DOWN ) {
                MATCHT(ANTLR3_TOKEN_DOWN, NULL);
                if  (HASEXCEPTION())
                {
                    goto rulefunctionDeclarationEx;
                }

                // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:220:59: (formalParameters+= IDENTIFIER )*

                for (;;)
                {
                    int alt14=2;
                    switch ( LA(1) )
                    {
                    case IDENTIFIER:
                    	{
                    		alt14=1;
                    	}
                        break;

                    }

                    switch (alt14)
                    {
                	case 1:
                	    // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:220:59: formalParameters+= IDENTIFIER
                	    {
                	        formalParameters = (pANTLR3_BASE_TREE) MATCHT(IDENTIFIER, &FOLLOW_IDENTIFIER_in_functionDeclaration401);
                	        if  (HASEXCEPTION())
                	        {
                	            goto rulefunctionDeclarationEx;
                	        }

                	        if (list_formalParameters == NULL)
                	        {
                	            list_formalParameters=ctx->vectors->newVector(ctx->vectors);
                	        }
                	        list_formalParameters->add(list_formalParameters, formalParameters, NULL);

                	    }
                	    break;

                	default:
                	    goto loop14;	/* break out of the loop */
                	    break;
                    }
                }
                loop14: ; /* Jump out to here if this rule does not match */


                MATCHT(ANTLR3_TOKEN_UP, NULL);
                if  (HASEXCEPTION())
                {
                    goto rulefunctionDeclarationEx;
                }

            }


            FOLLOWPUSH(FOLLOW_block_in_functionDeclaration405);
            block19=block(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulefunctionDeclarationEx;
            }


            MATCHT(ANTLR3_TOKEN_UP, NULL);
            if  (HASEXCEPTION())
            {
                goto rulefunctionDeclarationEx;
            }



            {

                	CodeLocation location((FUNCTION18->getLine(FUNCTION18)), (FUNCTION18->getCharPositionInLine(FUNCTION18)));
                	ScriptFunctionDefinition* decl = new ScriptFunctionDefinition((char*)(name->getText(name))->chars, location, list_formalParameters != NULL ? list_formalParameters->count : 0);

                	//SymbolDefinitionTable<VariableDefinition>& varDecls = decl->GetLocalVariableDefinitions();	
                	
                	CodeBlock& codeBlock = decl->GetRootCodeBlock();
                	if(list_formalParameters != NULL)
                	{

                	        
                	        for(unsigned i = 0; i < list_formalParameters->count; i++)
                	        {
                			pANTLR3_BASE_TREE tree = (pANTLR3_BASE_TREE)list_formalParameters->elements[i].element;
                			CodeLocation parameterLocation(tree->getLine(tree), tree->getCharPositionInLine(tree));
                			//varDecls.AddItem(new ScriptVariableDefinition(std::string((char*)tree->getText(tree)->chars)));
                		        codeBlock.AddInstruction(new instructions::DeclareLocalValueInstruction(location, (char*)tree->getText(tree)->chars));	
                		        codeBlock.AddInstruction(new instructions::StoreScopeValueInstruction(location, (char*)tree->getText(tree)->chars));	
                		        codeBlock.AddInstruction(new instructions::PopInstruction(location));	
                		}
                	             	
                	        codeBlock.MoveInstructionsFrom(CodeBlock()); // todo: WTF?
                	}
                	
                	codeBlock.MoveInstructionsFrom(*
                block19
                );
                	delete block19
                ;

                	// Add null to end of each function for case it had no return. If it has, this instruction will never be reached.
                	codeBlock.AddInstruction(new instructions::LoadNullInstruction(location));
                	
                	//SymbolDefinitionTable<VariableDefinition>* d = functionDeclaration::localVariableDefinitions;
                	//varDecls.MoveItemsFrom(*functionDeclaration::localVariableDefinitions);

                	if (!ctx->compiledScript->AddGlobalFunctionDefinition(decl)){
                		throw SymbolRedefinitionException(GGE1306_FunctionAlreadyDefined, location, decl->GetName());
                	}
                        
                        //ctx->compiledScript->GetSymbolNameTable().AddName(decl->GetName());

            }


        }

    }

    // This is where rules clean up and exit
    //
    goto rulefunctionDeclarationEx; /* Prevent compiler warnings */
    rulefunctionDeclarationEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
            else
            {
                {
                     ctx->isInFunction = false; /*functionDeclaration::localVariableDefinitions = NULL;*/ 
                }
            }


    return ;
}
/* $ANTLR end functionDeclaration */

/**
 * $ANTLR start block
 * D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:261:1: block returns [CodeBlock* returnCodeBlock] : ^( BLOCK ( statement )* ) ;
 */
static CodeBlock*
block(pGeoGenScriptDecls ctx)
{
    CodeBlock* returnCodeBlock;


    CodeBlock* statement20;
    #undef	RETURN_TYPE_statement20
    #define	RETURN_TYPE_statement20 CodeBlock*

    /* Initialize rule variables
     */

     auto_ptr<CodeBlock> codeBlock(new CodeBlock()); returnCodeBlock= NULL;
     
    {
        // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:264:3: ( ^( BLOCK ( statement )* ) )
        // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:264:3: ^( BLOCK ( statement )* )
        {
             MATCHT(BLOCK, &FOLLOW_BLOCK_in_block432);
            if  (HASEXCEPTION())
            {
                goto ruleblockEx;
            }


            if ( LA(1)==ANTLR3_TOKEN_DOWN ) {
                MATCHT(ANTLR3_TOKEN_DOWN, NULL);
                if  (HASEXCEPTION())
                {
                    goto ruleblockEx;
                }

                // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:264:11: ( statement )*

                for (;;)
                {
                    int alt15=2;
                    switch ( LA(1) )
                    {
                    case BLOCK:
                    case BREAK:
                    case CONTINUE:
                    case COORDINATE:
                    case FALSE_LIT:
                    case FOR:
                    case GLOBAL:
                    case IDENTIFIER:
                    case IF:
                    case LEFT_BRACKET:
                    case LEFT_SQUARE_BRACKET:
                    case NUMBER:
                    case OPERATOR_ASSIGN:
                    case OPERATOR_ASSIGN_AND:
                    case OPERATOR_ASSIGN_DIVIDE:
                    case OPERATOR_ASSIGN_LSHIFT:
                    case OPERATOR_ASSIGN_MINUS:
                    case OPERATOR_ASSIGN_MODULO:
                    case OPERATOR_ASSIGN_OR:
                    case OPERATOR_ASSIGN_PLUS:
                    case OPERATOR_ASSIGN_RSHIFT:
                    case OPERATOR_ASSIGN_TIMES:
                    case OPERATOR_BIT_AND:
                    case OPERATOR_BIT_OR:
                    case OPERATOR_BIT_XOR:
                    case OPERATOR_DECREMENT_POST:
                    case OPERATOR_DECREMENT_PRE:
                    case OPERATOR_DIVIDE:
                    case OPERATOR_DOT:
                    case OPERATOR_EQUAL_TO:
                    case OPERATOR_EXPR_IF:
                    case OPERATOR_GREATER_THAN:
                    case OPERATOR_GREATER_THAN_OR_EQUAL_TO:
                    case OPERATOR_INCREMENT_POST:
                    case OPERATOR_INCREMENT_PRE:
                    case OPERATOR_IS:
                    case OPERATOR_LESS_THAN:
                    case OPERATOR_LESS_THAN_OR_EQUAL_TO:
                    case OPERATOR_LSHIFT:
                    case OPERATOR_MINUS:
                    case OPERATOR_MINUS_UN:
                    case OPERATOR_MODULO:
                    case OPERATOR_NOT:
                    case OPERATOR_NOT_EQUAL_TO:
                    case OPERATOR_PLUS:
                    case OPERATOR_PLUS_UN:
                    case OPERATOR_RELATIVE:
                    case OPERATOR_REL_AND:
                    case OPERATOR_REL_OR:
                    case OPERATOR_RSHIFT:
                    case OPERATOR_TIMES:
                    case RETURN:
                    case STRING:
                    case SWITCH:
                    case TRUE_LIT:
                    case VAR:
                    case WHILE:
                    case YIELD:
                    	{
                    		alt15=1;
                    	}
                        break;

                    }

                    switch (alt15)
                    {
                	case 1:
                	    // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:264:12: statement
                	    {
                	        FOLLOWPUSH(FOLLOW_statement_in_block435);
                	        statement20=statement(ctx);

                	        FOLLOWPOP();
                	        if  (HASEXCEPTION())
                	        {
                	            goto ruleblockEx;
                	        }


                	        {
                	             codeBlock.get()->MoveInstructionsFrom(*statement20
                	            ); delete statement20
                	            ; 
                	        }


                	    }
                	    break;

                	default:
                	    goto loop15;	/* break out of the loop */
                	    break;
                    }
                }
                loop15: ; /* Jump out to here if this rule does not match */


                MATCHT(ANTLR3_TOKEN_UP, NULL);
                if  (HASEXCEPTION())
                {
                    goto ruleblockEx;
                }

            }


        }

    }

    // This is where rules clean up and exit
    //
    goto ruleblockEx; /* Prevent compiler warnings */
    ruleblockEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
            else
            {
                {
                     returnCodeBlock= codeBlock.release();
                     
                }
            }


    return returnCodeBlock;
}
/* $ANTLR end block */

/**
 * $ANTLR start statement
 * D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:266:1: statement returns [CodeBlock* returnCodeBlock] : ( BREAK | CONTINUE | variableDeclaration | globalVariableDeclaration | expression | yieldStatement | returnStatement | whileStatement | forStatement | ifStatement | switchStatement | block );
 */
static CodeBlock*
statement(pGeoGenScriptDecls ctx)
{
    CodeBlock* returnCodeBlock;


    pANTLR3_BASE_TREE    BREAK21;
    pANTLR3_BASE_TREE    CONTINUE22;
    CodeBlock* variableDeclaration23;
    #undef	RETURN_TYPE_variableDeclaration23
    #define	RETURN_TYPE_variableDeclaration23 CodeBlock*

    CodeBlock* globalVariableDeclaration24;
    #undef	RETURN_TYPE_globalVariableDeclaration24
    #define	RETURN_TYPE_globalVariableDeclaration24 CodeBlock*

    CodeBlock* expression25;
    #undef	RETURN_TYPE_expression25
    #define	RETURN_TYPE_expression25 CodeBlock*

    CodeBlock* yieldStatement26;
    #undef	RETURN_TYPE_yieldStatement26
    #define	RETURN_TYPE_yieldStatement26 CodeBlock*

    CodeBlock* returnStatement27;
    #undef	RETURN_TYPE_returnStatement27
    #define	RETURN_TYPE_returnStatement27 CodeBlock*

    CodeBlock* whileStatement28;
    #undef	RETURN_TYPE_whileStatement28
    #define	RETURN_TYPE_whileStatement28 CodeBlock*

    CodeBlock* forStatement29;
    #undef	RETURN_TYPE_forStatement29
    #define	RETURN_TYPE_forStatement29 CodeBlock*

    CodeBlock* ifStatement30;
    #undef	RETURN_TYPE_ifStatement30
    #define	RETURN_TYPE_ifStatement30 CodeBlock*

    CodeBlock* block31;
    #undef	RETURN_TYPE_block31
    #define	RETURN_TYPE_block31 CodeBlock*

    /* Initialize rule variables
     */

     returnCodeBlock= NULL;
     
    BREAK21       = NULL;
    CONTINUE22       = NULL;

    {
        {
            //  D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:268:5: ( BREAK | CONTINUE | variableDeclaration | globalVariableDeclaration | expression | yieldStatement | returnStatement | whileStatement | forStatement | ifStatement | switchStatement | block )

            ANTLR3_UINT32 alt16;

            alt16=12;

            switch ( LA(1) )
            {
            case BREAK:
            	{
            		alt16=1;
            	}
                break;
            case CONTINUE:
            	{
            		alt16=2;
            	}
                break;
            case VAR:
            	{
            		alt16=3;
            	}
                break;
            case GLOBAL:
            	{
            		alt16=4;
            	}
                break;
            case COORDINATE:
            case FALSE_LIT:
            case IDENTIFIER:
            case LEFT_BRACKET:
            case LEFT_SQUARE_BRACKET:
            case NUMBER:
            case OPERATOR_ASSIGN:
            case OPERATOR_ASSIGN_AND:
            case OPERATOR_ASSIGN_DIVIDE:
            case OPERATOR_ASSIGN_LSHIFT:
            case OPERATOR_ASSIGN_MINUS:
            case OPERATOR_ASSIGN_MODULO:
            case OPERATOR_ASSIGN_OR:
            case OPERATOR_ASSIGN_PLUS:
            case OPERATOR_ASSIGN_RSHIFT:
            case OPERATOR_ASSIGN_TIMES:
            case OPERATOR_BIT_AND:
            case OPERATOR_BIT_OR:
            case OPERATOR_BIT_XOR:
            case OPERATOR_DECREMENT_POST:
            case OPERATOR_DECREMENT_PRE:
            case OPERATOR_DIVIDE:
            case OPERATOR_DOT:
            case OPERATOR_EQUAL_TO:
            case OPERATOR_EXPR_IF:
            case OPERATOR_GREATER_THAN:
            case OPERATOR_GREATER_THAN_OR_EQUAL_TO:
            case OPERATOR_INCREMENT_POST:
            case OPERATOR_INCREMENT_PRE:
            case OPERATOR_IS:
            case OPERATOR_LESS_THAN:
            case OPERATOR_LESS_THAN_OR_EQUAL_TO:
            case OPERATOR_LSHIFT:
            case OPERATOR_MINUS:
            case OPERATOR_MINUS_UN:
            case OPERATOR_MODULO:
            case OPERATOR_NOT:
            case OPERATOR_NOT_EQUAL_TO:
            case OPERATOR_PLUS:
            case OPERATOR_PLUS_UN:
            case OPERATOR_RELATIVE:
            case OPERATOR_REL_AND:
            case OPERATOR_REL_OR:
            case OPERATOR_RSHIFT:
            case OPERATOR_TIMES:
            case STRING:
            case TRUE_LIT:
            	{
            		alt16=5;
            	}
                break;
            case YIELD:
            	{
            		alt16=6;
            	}
                break;
            case RETURN:
            	{
            		alt16=7;
            	}
                break;
            case WHILE:
            	{
            		alt16=8;
            	}
                break;
            case FOR:
            	{
            		alt16=9;
            	}
                break;
            case IF:
            	{
            		alt16=10;
            	}
                break;
            case SWITCH:
            	{
            		alt16=11;
            	}
                break;
            case BLOCK:
            	{
            		alt16=12;
            	}
                break;

            default:
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 16;
                EXCEPTION->state        = 0;


                goto rulestatementEx;

            }

            switch (alt16)
            {
        	case 1:
        	    // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:269:5: BREAK
        	    {
        	        BREAK21 = (pANTLR3_BASE_TREE) MATCHT(BREAK, &FOLLOW_BREAK_in_statement466);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulestatementEx;
        	        }


        	        {
        	             
        	            	CodeLocation location((BREAK21->getLine(BREAK21)), (BREAK21->getCharPositionInLine(BREAK21)));
        	                
        	                	if(!ctx->isInLoop)
        	                	{
        	                		throw CompilerException(GGE1301_InvalidBreak, location);
        	                	}
        	                
        	                	int a = (SCOPE_TOP(BlockScope))->breakCodeBlockLevel;
        	                
        	                	
        	            returnCodeBlock= new CodeBlock();
        	              
        	                	returnCodeBlock
        	            ->AddInstruction(new instructions::BreakInstruction(location, ctx->codeBlockLevel - (SCOPE_TOP(BlockScope))->breakCodeBlockLevel + 1));
        	                
        	        }


        	    }
        	    break;
        	case 2:
        	    // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:283:7: CONTINUE
        	    {
        	        CONTINUE22 = (pANTLR3_BASE_TREE) MATCHT(CONTINUE, &FOLLOW_CONTINUE_in_statement481);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulestatementEx;
        	        }


        	        {
        	             
        	                	CodeLocation location((CONTINUE22->getLine(CONTINUE22)), (CONTINUE22->getCharPositionInLine(CONTINUE22)));
        	                	
        	                	if(!ctx->isInLoop)
        	                	{
        	                		throw CompilerException(GGE1303_InvalidContinue, location);
        	                	}
        	                
        	                	
        	            returnCodeBlock= new CodeBlock();
        	              
        	                	returnCodeBlock
        	            ->AddInstruction(new instructions::ContinueInstruction(location, ctx->codeBlockLevel - (SCOPE_TOP(BlockScope))->continueCodeBlockLevel + 1));
        	                
        	        }


        	    }
        	    break;
        	case 3:
        	    // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:295:7: variableDeclaration
        	    {
        	        FOLLOWPUSH(FOLLOW_variableDeclaration_in_statement496);
        	        variableDeclaration23=variableDeclaration(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulestatementEx;
        	        }


        	        {
        	             returnCodeBlock= 
        	            variableDeclaration23
        	            ;
        	             
        	        }


        	    }
        	    break;
        	case 4:
        	    // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:296:7: globalVariableDeclaration
        	    {
        	        FOLLOWPUSH(FOLLOW_globalVariableDeclaration_in_statement506);
        	        globalVariableDeclaration24=globalVariableDeclaration(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulestatementEx;
        	        }


        	        {
        	             returnCodeBlock= 
        	            globalVariableDeclaration24
        	            ;
        	             
        	        }


        	    }
        	    break;
        	case 5:
        	    // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:297:7: expression
        	    {
        	        FOLLOWPUSH(FOLLOW_expression_in_statement516);
        	        expression25=expression(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulestatementEx;
        	        }


        	        {
        	             
        	                	CodeLocation location(0, 0);
        	                
        	                	returnCodeBlock= new CodeBlock();
        	             
        	                	returnCodeBlock
        	            ->MoveInstructionsFrom(*expression25
        	            ); delete expression25
        	            ; 
        	                	returnCodeBlock
        	            ->AddInstruction(new instructions::PopInstruction(location));
        	                
        	        }


        	    }
        	    break;
        	case 6:
        	    // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:305:7: yieldStatement
        	    {
        	        FOLLOWPUSH(FOLLOW_yieldStatement_in_statement531);
        	        yieldStatement26=yieldStatement(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulestatementEx;
        	        }


        	        {
        	             returnCodeBlock= 
        	            yieldStatement26
        	            ;
        	             
        	        }


        	    }
        	    break;
        	case 7:
        	    // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:306:7: returnStatement
        	    {
        	        FOLLOWPUSH(FOLLOW_returnStatement_in_statement540);
        	        returnStatement27=returnStatement(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulestatementEx;
        	        }


        	        {
        	             returnCodeBlock= 
        	            returnStatement27
        	            ;
        	             
        	        }


        	    }
        	    break;
        	case 8:
        	    // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:307:7: whileStatement
        	    {
        	        FOLLOWPUSH(FOLLOW_whileStatement_in_statement550);
        	        whileStatement28=whileStatement(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulestatementEx;
        	        }


        	        {
        	             returnCodeBlock= 
        	            whileStatement28
        	            ;
        	             
        	        }


        	    }
        	    break;
        	case 9:
        	    // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:308:7: forStatement
        	    {
        	        FOLLOWPUSH(FOLLOW_forStatement_in_statement560);
        	        forStatement29=forStatement(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulestatementEx;
        	        }


        	        {
        	             returnCodeBlock= 
        	            forStatement29
        	            ;
        	             
        	        }


        	    }
        	    break;
        	case 10:
        	    // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:309:7: ifStatement
        	    {
        	        FOLLOWPUSH(FOLLOW_ifStatement_in_statement570);
        	        ifStatement30=ifStatement(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulestatementEx;
        	        }


        	        {
        	             returnCodeBlock= 
        	            ifStatement30
        	            ;

        	        }


        	    }
        	    break;
        	case 11:
        	    // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:310:7: switchStatement
        	    {
        	        FOLLOWPUSH(FOLLOW_switchStatement_in_statement580);
        	        switchStatement(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulestatementEx;
        	        }


        	        {
        	             returnCodeBlock= new CodeBlock();
        	             
        	        }


        	    }
        	    break;
        	case 12:
        	    // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:311:7: block
        	    {
        	        FOLLOWPUSH(FOLLOW_block_in_statement590);
        	        block31=block(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulestatementEx;
        	        }


        	        {
        	             returnCodeBlock= 
        	            block31
        	            ;
        	             
        	        }


        	    }
        	    break;

            }
        }
    }

    // This is where rules clean up and exit
    //
    goto rulestatementEx; /* Prevent compiler warnings */
    rulestatementEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return returnCodeBlock;
}
/* $ANTLR end statement */

/**
 * $ANTLR start variableDeclaration
 * D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:313:1: variableDeclaration returns [CodeBlock* returnCodeBlock] : ^( VAR IDENTIFIER ( expression )? ) ;
 */
static CodeBlock*
variableDeclaration(pGeoGenScriptDecls ctx)
{
    CodeBlock* returnCodeBlock;


    pANTLR3_BASE_TREE    VAR32;
    pANTLR3_BASE_TREE    IDENTIFIER34;
    CodeBlock* expression33;
    #undef	RETURN_TYPE_expression33
    #define	RETURN_TYPE_expression33 CodeBlock*

    /* Initialize rule variables
     */

     returnCodeBlock= new CodeBlock();
     bool hadValue = false; 
    VAR32       = NULL;
    IDENTIFIER34       = NULL;

    {
        // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:315:3: ( ^( VAR IDENTIFIER ( expression )? ) )
        // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:315:3: ^( VAR IDENTIFIER ( expression )? )
        {
            VAR32 = (pANTLR3_BASE_TREE) MATCHT(VAR, &FOLLOW_VAR_in_variableDeclaration615);
            if  (HASEXCEPTION())
            {
                goto rulevariableDeclarationEx;
            }


            MATCHT(ANTLR3_TOKEN_DOWN, NULL);
            if  (HASEXCEPTION())
            {
                goto rulevariableDeclarationEx;
            }

            IDENTIFIER34 = (pANTLR3_BASE_TREE) MATCHT(IDENTIFIER, &FOLLOW_IDENTIFIER_in_variableDeclaration617);
            if  (HASEXCEPTION())
            {
                goto rulevariableDeclarationEx;
            }


            // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:315:20: ( expression )?
            {
                int alt17=2;
                switch ( LA(1) )
                {
                    case COORDINATE:
                    case FALSE_LIT:
                    case IDENTIFIER:
                    case LEFT_BRACKET:
                    case LEFT_SQUARE_BRACKET:
                    case NUMBER:
                    case OPERATOR_ASSIGN:
                    case OPERATOR_ASSIGN_AND:
                    case OPERATOR_ASSIGN_DIVIDE:
                    case OPERATOR_ASSIGN_LSHIFT:
                    case OPERATOR_ASSIGN_MINUS:
                    case OPERATOR_ASSIGN_MODULO:
                    case OPERATOR_ASSIGN_OR:
                    case OPERATOR_ASSIGN_PLUS:
                    case OPERATOR_ASSIGN_RSHIFT:
                    case OPERATOR_ASSIGN_TIMES:
                    case OPERATOR_BIT_AND:
                    case OPERATOR_BIT_OR:
                    case OPERATOR_BIT_XOR:
                    case OPERATOR_DECREMENT_POST:
                    case OPERATOR_DECREMENT_PRE:
                    case OPERATOR_DIVIDE:
                    case OPERATOR_DOT:
                    case OPERATOR_EQUAL_TO:
                    case OPERATOR_EXPR_IF:
                    case OPERATOR_GREATER_THAN:
                    case OPERATOR_GREATER_THAN_OR_EQUAL_TO:
                    case OPERATOR_INCREMENT_POST:
                    case OPERATOR_INCREMENT_PRE:
                    case OPERATOR_IS:
                    case OPERATOR_LESS_THAN:
                    case OPERATOR_LESS_THAN_OR_EQUAL_TO:
                    case OPERATOR_LSHIFT:
                    case OPERATOR_MINUS:
                    case OPERATOR_MINUS_UN:
                    case OPERATOR_MODULO:
                    case OPERATOR_NOT:
                    case OPERATOR_NOT_EQUAL_TO:
                    case OPERATOR_PLUS:
                    case OPERATOR_PLUS_UN:
                    case OPERATOR_RELATIVE:
                    case OPERATOR_REL_AND:
                    case OPERATOR_REL_OR:
                    case OPERATOR_RSHIFT:
                    case OPERATOR_TIMES:
                    case STRING:
                    case TRUE_LIT:
                    	{
                    		alt17=1;
                    	}
                        break;
                }

                switch (alt17)
                {
            	case 1:
            	    // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:315:21: expression
            	    {
            	        FOLLOWPUSH(FOLLOW_expression_in_variableDeclaration620);
            	        expression33=expression(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulevariableDeclarationEx;
            	        }


            	        {

            	            		hadValue = true;
            	            	
            	                		CodeLocation location((VAR32->getLine(VAR32)), (VAR32->getCharPositionInLine(VAR32)));
            	                		
            	            		
            	            returnCodeBlock
            	            ->MoveInstructionsFrom(*expression33
            	            ); 
            	            		delete expression33
            	            ; 
            	            		
            	            		returnCodeBlock
            	            ->AddInstruction(new instructions::CallGlobalInstruction(location, "=", 1));
            	            		returnCodeBlock
            	            ->AddInstruction(new instructions::DeclareLocalValueInstruction(location, (char*)(IDENTIFIER34->getText(IDENTIFIER34))->chars));
            	            		
            	            returnCodeBlock
            	            ->AddInstruction(new instructions::StoreScopeValueInstruction(location, (char*)(IDENTIFIER34->getText(IDENTIFIER34))->chars));
            	            		
            	            returnCodeBlock
            	            ->AddInstruction(new instructions::PopInstruction(location));
            	            	
            	        }


            	    }
            	    break;

                }
            }

            MATCHT(ANTLR3_TOKEN_UP, NULL);
            if  (HASEXCEPTION())
            {
                goto rulevariableDeclarationEx;
            }



            {

                    	CodeLocation location((VAR32->getLine(VAR32)), (VAR32->getCharPositionInLine(VAR32)));
                	if(!hadValue){
                		
                returnCodeBlock
                ->AddInstruction(new instructions::DeclareLocalValueInstruction(location, (char*)(IDENTIFIER34->getText(IDENTIFIER34))->chars));
                	}

            }


        }

    }

    // This is where rules clean up and exit
    //
    goto rulevariableDeclarationEx; /* Prevent compiler warnings */
    rulevariableDeclarationEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return returnCodeBlock;
}
/* $ANTLR end variableDeclaration */

/**
 * $ANTLR start globalVariableDeclaration
 * D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:336:1: globalVariableDeclaration returns [CodeBlock* returnCodeBlock] : ^( GLOBAL IDENTIFIER ( expression )? ) ;
 */
static CodeBlock*
globalVariableDeclaration(pGeoGenScriptDecls ctx)
{
    CodeBlock* returnCodeBlock;


    pANTLR3_BASE_TREE    GLOBAL35;
    pANTLR3_BASE_TREE    IDENTIFIER37;
    CodeBlock* expression36;
    #undef	RETURN_TYPE_expression36
    #define	RETURN_TYPE_expression36 CodeBlock*

    /* Initialize rule variables
     */

     returnCodeBlock= new CodeBlock();
     bool hadValue = false; 
    GLOBAL35       = NULL;
    IDENTIFIER37       = NULL;

    {
        // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:338:3: ( ^( GLOBAL IDENTIFIER ( expression )? ) )
        // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:338:3: ^( GLOBAL IDENTIFIER ( expression )? )
        {
            GLOBAL35 = (pANTLR3_BASE_TREE) MATCHT(GLOBAL, &FOLLOW_GLOBAL_in_globalVariableDeclaration648);
            if  (HASEXCEPTION())
            {
                goto ruleglobalVariableDeclarationEx;
            }


            MATCHT(ANTLR3_TOKEN_DOWN, NULL);
            if  (HASEXCEPTION())
            {
                goto ruleglobalVariableDeclarationEx;
            }

            IDENTIFIER37 = (pANTLR3_BASE_TREE) MATCHT(IDENTIFIER, &FOLLOW_IDENTIFIER_in_globalVariableDeclaration650);
            if  (HASEXCEPTION())
            {
                goto ruleglobalVariableDeclarationEx;
            }


            // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:338:23: ( expression )?
            {
                int alt18=2;
                switch ( LA(1) )
                {
                    case COORDINATE:
                    case FALSE_LIT:
                    case IDENTIFIER:
                    case LEFT_BRACKET:
                    case LEFT_SQUARE_BRACKET:
                    case NUMBER:
                    case OPERATOR_ASSIGN:
                    case OPERATOR_ASSIGN_AND:
                    case OPERATOR_ASSIGN_DIVIDE:
                    case OPERATOR_ASSIGN_LSHIFT:
                    case OPERATOR_ASSIGN_MINUS:
                    case OPERATOR_ASSIGN_MODULO:
                    case OPERATOR_ASSIGN_OR:
                    case OPERATOR_ASSIGN_PLUS:
                    case OPERATOR_ASSIGN_RSHIFT:
                    case OPERATOR_ASSIGN_TIMES:
                    case OPERATOR_BIT_AND:
                    case OPERATOR_BIT_OR:
                    case OPERATOR_BIT_XOR:
                    case OPERATOR_DECREMENT_POST:
                    case OPERATOR_DECREMENT_PRE:
                    case OPERATOR_DIVIDE:
                    case OPERATOR_DOT:
                    case OPERATOR_EQUAL_TO:
                    case OPERATOR_EXPR_IF:
                    case OPERATOR_GREATER_THAN:
                    case OPERATOR_GREATER_THAN_OR_EQUAL_TO:
                    case OPERATOR_INCREMENT_POST:
                    case OPERATOR_INCREMENT_PRE:
                    case OPERATOR_IS:
                    case OPERATOR_LESS_THAN:
                    case OPERATOR_LESS_THAN_OR_EQUAL_TO:
                    case OPERATOR_LSHIFT:
                    case OPERATOR_MINUS:
                    case OPERATOR_MINUS_UN:
                    case OPERATOR_MODULO:
                    case OPERATOR_NOT:
                    case OPERATOR_NOT_EQUAL_TO:
                    case OPERATOR_PLUS:
                    case OPERATOR_PLUS_UN:
                    case OPERATOR_RELATIVE:
                    case OPERATOR_REL_AND:
                    case OPERATOR_REL_OR:
                    case OPERATOR_RSHIFT:
                    case OPERATOR_TIMES:
                    case STRING:
                    case TRUE_LIT:
                    	{
                    		alt18=1;
                    	}
                        break;
                }

                switch (alt18)
                {
            	case 1:
            	    // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:338:24: expression
            	    {
            	        FOLLOWPUSH(FOLLOW_expression_in_globalVariableDeclaration653);
            	        expression36=expression(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleglobalVariableDeclarationEx;
            	        }


            	        {

            	            		hadValue = true;
            	            	
            	                		CodeLocation location((GLOBAL35->getLine(GLOBAL35)), (GLOBAL35->getCharPositionInLine(GLOBAL35)));
            	                		
            	            		
            	            returnCodeBlock
            	            ->MoveInstructionsFrom(*expression36
            	            ); 
            	            		delete expression36
            	            ; 
            	            		
            	            		returnCodeBlock
            	            ->AddInstruction(new instructions::CallGlobalInstruction(location, "=", 1));
            	            		returnCodeBlock
            	            ->AddInstruction(new instructions::DeclareGlobalValueInstruction(location, (char*)(IDENTIFIER37->getText(IDENTIFIER37))->chars));
            	            		
            	            returnCodeBlock
            	            ->AddInstruction(new instructions::StoreScopeValueInstruction(location, (char*)(IDENTIFIER37->getText(IDENTIFIER37))->chars));
            	            		
            	            returnCodeBlock
            	            ->AddInstruction(new instructions::PopInstruction(location));
            	            	
            	        }


            	    }
            	    break;

                }
            }

            MATCHT(ANTLR3_TOKEN_UP, NULL);
            if  (HASEXCEPTION())
            {
                goto ruleglobalVariableDeclarationEx;
            }



            {

                    	CodeLocation location((GLOBAL35->getLine(GLOBAL35)), (GLOBAL35->getCharPositionInLine(GLOBAL35)));
                	if(!hadValue){
                		
                returnCodeBlock
                ->AddInstruction(new instructions::DeclareGlobalValueInstruction(location, (char*)(IDENTIFIER37->getText(IDENTIFIER37))->chars));
                	}

            }


        }

    }

    // This is where rules clean up and exit
    //
    goto ruleglobalVariableDeclarationEx; /* Prevent compiler warnings */
    ruleglobalVariableDeclarationEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return returnCodeBlock;
}
/* $ANTLR end globalVariableDeclaration */

/**
 * $ANTLR start yieldStatement
 * D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:359:1: yieldStatement returns [CodeBlock* returnCodeBlock] : ^( YIELD expression ( STRING )? ) ;
 */
static CodeBlock*
yieldStatement(pGeoGenScriptDecls ctx)
{
    CodeBlock* returnCodeBlock;


    pANTLR3_BASE_TREE    YIELD38;
    pANTLR3_BASE_TREE    STRING39;

    /* Initialize rule variables
     */

     returnCodeBlock= new CodeBlock();
     
    YIELD38       = NULL;
    STRING39       = NULL;

    {
        // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:361:3: ( ^( YIELD expression ( STRING )? ) )
        // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:361:3: ^( YIELD expression ( STRING )? )
        {
            YIELD38 = (pANTLR3_BASE_TREE) MATCHT(YIELD, &FOLLOW_YIELD_in_yieldStatement681);
            if  (HASEXCEPTION())
            {
                goto ruleyieldStatementEx;
            }


            MATCHT(ANTLR3_TOKEN_DOWN, NULL);
            if  (HASEXCEPTION())
            {
                goto ruleyieldStatementEx;
            }

            FOLLOWPUSH(FOLLOW_expression_in_yieldStatement683);
            expression(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleyieldStatementEx;
            }


            // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:361:22: ( STRING )?
            {
                int alt19=2;
                switch ( LA(1) )
                {
                    case STRING:
                    	{
                    		alt19=1;
                    	}
                        break;
                }

                switch (alt19)
                {
            	case 1:
            	    // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:361:22: STRING
            	    {
            	        STRING39 = (pANTLR3_BASE_TREE) MATCHT(STRING, &FOLLOW_STRING_in_yieldStatement685);
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleyieldStatementEx;
            	        }


            	    }
            	    break;

                }
            }

            MATCHT(ANTLR3_TOKEN_UP, NULL);
            if  (HASEXCEPTION())
            {
                goto ruleyieldStatementEx;
            }



            {
                 
                	CodeLocation location((YIELD38->getLine(YIELD38)), (YIELD38->getCharPositionInLine(YIELD38)));
                	
                	if(STRING39 == NULL){
                		
                returnCodeBlock
                ->AddInstruction(new instructions::YieldAsMainInstruction(location));
                	}
                	else 
                	{
                		returnCodeBlock
                ->AddInstruction(new instructions::YieldAsNamedInstruction(location, (char*)(STRING39->getText(STRING39))->chars));	
                	}

            }


        }

    }

    // This is where rules clean up and exit
    //
    goto ruleyieldStatementEx; /* Prevent compiler warnings */
    ruleyieldStatementEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return returnCodeBlock;
}
/* $ANTLR end yieldStatement */

/**
 * $ANTLR start returnStatement
 * D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:374:1: returnStatement returns [CodeBlock* returnCodeBlock] : ^( RETURN ( expression )? ) ;
 */
static CodeBlock*
returnStatement(pGeoGenScriptDecls ctx)
{
    CodeBlock* returnCodeBlock;


    pANTLR3_BASE_TREE    RETURN41;
    CodeBlock* expression40;
    #undef	RETURN_TYPE_expression40
    #define	RETURN_TYPE_expression40 CodeBlock*

    /* Initialize rule variables
     */

     returnCodeBlock= NULL;
     
    RETURN41       = NULL;

    {
        // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:376:3: ( ^( RETURN ( expression )? ) )
        // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:376:3: ^( RETURN ( expression )? )
        {
            RETURN41 = (pANTLR3_BASE_TREE) MATCHT(RETURN, &FOLLOW_RETURN_in_returnStatement709);
            if  (HASEXCEPTION())
            {
                goto rulereturnStatementEx;
            }


            if ( LA(1)==ANTLR3_TOKEN_DOWN ) {
                MATCHT(ANTLR3_TOKEN_DOWN, NULL);
                if  (HASEXCEPTION())
                {
                    goto rulereturnStatementEx;
                }

                // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:376:12: ( expression )?
                {
                    int alt20=2;
                    switch ( LA(1) )
                    {
                        case COORDINATE:
                        case FALSE_LIT:
                        case IDENTIFIER:
                        case LEFT_BRACKET:
                        case LEFT_SQUARE_BRACKET:
                        case NUMBER:
                        case OPERATOR_ASSIGN:
                        case OPERATOR_ASSIGN_AND:
                        case OPERATOR_ASSIGN_DIVIDE:
                        case OPERATOR_ASSIGN_LSHIFT:
                        case OPERATOR_ASSIGN_MINUS:
                        case OPERATOR_ASSIGN_MODULO:
                        case OPERATOR_ASSIGN_OR:
                        case OPERATOR_ASSIGN_PLUS:
                        case OPERATOR_ASSIGN_RSHIFT:
                        case OPERATOR_ASSIGN_TIMES:
                        case OPERATOR_BIT_AND:
                        case OPERATOR_BIT_OR:
                        case OPERATOR_BIT_XOR:
                        case OPERATOR_DECREMENT_POST:
                        case OPERATOR_DECREMENT_PRE:
                        case OPERATOR_DIVIDE:
                        case OPERATOR_DOT:
                        case OPERATOR_EQUAL_TO:
                        case OPERATOR_EXPR_IF:
                        case OPERATOR_GREATER_THAN:
                        case OPERATOR_GREATER_THAN_OR_EQUAL_TO:
                        case OPERATOR_INCREMENT_POST:
                        case OPERATOR_INCREMENT_PRE:
                        case OPERATOR_IS:
                        case OPERATOR_LESS_THAN:
                        case OPERATOR_LESS_THAN_OR_EQUAL_TO:
                        case OPERATOR_LSHIFT:
                        case OPERATOR_MINUS:
                        case OPERATOR_MINUS_UN:
                        case OPERATOR_MODULO:
                        case OPERATOR_NOT:
                        case OPERATOR_NOT_EQUAL_TO:
                        case OPERATOR_PLUS:
                        case OPERATOR_PLUS_UN:
                        case OPERATOR_RELATIVE:
                        case OPERATOR_REL_AND:
                        case OPERATOR_REL_OR:
                        case OPERATOR_RSHIFT:
                        case OPERATOR_TIMES:
                        case STRING:
                        case TRUE_LIT:
                        	{
                        		alt20=1;
                        	}
                            break;
                    }

                    switch (alt20)
                    {
                	case 1:
                	    // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:376:13: expression
                	    {
                	        FOLLOWPUSH(FOLLOW_expression_in_returnStatement712);
                	        expression40=expression(ctx);

                	        FOLLOWPOP();
                	        if  (HASEXCEPTION())
                	        {
                	            goto rulereturnStatementEx;
                	        }


                	        {
                	             returnCodeBlock= new CodeBlock();
                	             returnCodeBlock
                	            ->MoveInstructionsFrom(*expression40
                	            ); delete expression40
                	            ; 
                	        }


                	    }
                	    break;

                    }
                }

                MATCHT(ANTLR3_TOKEN_UP, NULL);
                if  (HASEXCEPTION())
                {
                    goto rulereturnStatementEx;
                }

            }


            {

                	CodeLocation location((RETURN41->getLine(RETURN41)), (RETURN41->getCharPositionInLine(RETURN41)));
                	
                	if(
                returnCodeBlock
                 == NULL)
                	{
                		returnCodeBlock= new CodeBlock();
                	
                		returnCodeBlock
                ->AddInstruction(new instructions::LoadNullInstruction(location));
                	}

                	if(!ctx->isInFunction)
                	{		
                		throw CompilerException(GGE1304_InvalidReturn, location);
                	}

                	returnCodeBlock
                ->AddInstruction(new instructions::BreakInstruction(location, ctx->codeBlockLevel + 1));

            }


        }

    }

    // This is where rules clean up and exit
    //
    goto rulereturnStatementEx; /* Prevent compiler warnings */
    rulereturnStatementEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return returnCodeBlock;
}
/* $ANTLR end returnStatement */

/**
 * $ANTLR start whileStatement
 * D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:394:1: whileStatement returns [CodeBlock* returnCodeBlock] : ^( WHILE expression statement ) ;
 */
static CodeBlock*
whileStatement(pGeoGenScriptDecls ctx)
{
    CodeBlock* returnCodeBlock;


    pANTLR3_BASE_TREE    WHILE42;
    CodeBlock* expression43;
    #undef	RETURN_TYPE_expression43
    #define	RETURN_TYPE_expression43 CodeBlock*

    CodeBlock* statement44;
    #undef	RETURN_TYPE_statement44
    #define	RETURN_TYPE_statement44 CodeBlock*

    /* Initialize rule variables
     */
    ctx->pGeoGenScriptDecls_BlockScopeTop = pGeoGenScriptDecls_BlockScopePush(ctx);

     
    	returnCodeBlock= new CodeBlock();
     
    	ctx->codeBlockLevel++; 
    	(SCOPE_TOP(BlockScope))->breakCodeBlockLevel= ctx->codeBlockLevel; 
    	(SCOPE_TOP(BlockScope))->continueCodeBlockLevel= ctx->codeBlockLevel; 
    	ctx->isInLoop = true; 

    WHILE42       = NULL;

    {
        // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:404:3: ( ^( WHILE expression statement ) )
        // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:404:3: ^( WHILE expression statement )
        {
            WHILE42 = (pANTLR3_BASE_TREE) MATCHT(WHILE, &FOLLOW_WHILE_in_whileStatement748);
            if  (HASEXCEPTION())
            {
                goto rulewhileStatementEx;
            }


            MATCHT(ANTLR3_TOKEN_DOWN, NULL);
            if  (HASEXCEPTION())
            {
                goto rulewhileStatementEx;
            }

            FOLLOWPUSH(FOLLOW_expression_in_whileStatement750);
            expression43=expression(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulewhileStatementEx;
            }


            FOLLOWPUSH(FOLLOW_statement_in_whileStatement752);
            statement44=statement(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulewhileStatementEx;
            }


            MATCHT(ANTLR3_TOKEN_UP, NULL);
            if  (HASEXCEPTION())
            {
                goto rulewhileStatementEx;
            }



            {

                	CodeLocation location((WHILE42->getLine(WHILE42)), (WHILE42->getCharPositionInLine(WHILE42)));

                	instructions::WhileInstruction* whileInstr = new instructions::WhileInstruction(location);
                	CodeBlock& whileCodeBlock = whileInstr->GetCodeBlock();
                	
                	whileCodeBlock.MoveInstructionsFrom(*
                expression43
                );
                	delete expression43
                ;
                	
                	instructions::IfInstruction* ifInstr = new instructions::IfInstruction(location);
                	ifInstr->GetElseBranchCodeBlock().AddInstruction(new instructions::BreakInstruction(location, 2));
                	whileCodeBlock.AddInstruction(ifInstr);
                	
                	whileCodeBlock.MoveInstructionsFrom(*statement44
                );
                	delete statement44
                ;
                	
                	returnCodeBlock
                ->AddInstruction(whileInstr);

            }


        }

    }

    // This is where rules clean up and exit
    //
    goto rulewhileStatementEx; /* Prevent compiler warnings */
    rulewhileStatementEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
            else
            {
                {
                     ctx->codeBlockLevel--; ctx->isInLoop = false;
                }
            }


    pGeoGenScriptDecls_BlockScopePop(ctx);

    return returnCodeBlock;
}
/* $ANTLR end whileStatement */

/**
 * $ANTLR start forStatement
 * D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:424:1: forStatement returns [CodeBlock* returnCodeBlock] : ^( FOR ( ^( INITIALIZATION_EXPRESSION initExpression ) )? ( ^( CONDITION_EXPRESSION conditionExpression= expression ) )? ( ^( INCREMENT_EXPRESSION incrementExpression= expression ) )? statement ) ;
 */
static CodeBlock*
forStatement(pGeoGenScriptDecls ctx)
{
    CodeBlock* returnCodeBlock;


    pANTLR3_BASE_TREE    FOR46;
    CodeBlock* conditionExpression;
    #undef	RETURN_TYPE_conditionExpression
    #define	RETURN_TYPE_conditionExpression CodeBlock*

    CodeBlock* incrementExpression;
    #undef	RETURN_TYPE_incrementExpression
    #define	RETURN_TYPE_incrementExpression CodeBlock*

    CodeBlock* initExpression45;
    #undef	RETURN_TYPE_initExpression45
    #define	RETURN_TYPE_initExpression45 CodeBlock*

    CodeBlock* statement47;
    #undef	RETURN_TYPE_statement47
    #define	RETURN_TYPE_statement47 CodeBlock*

    /* Initialize rule variables
     */
    ctx->pGeoGenScriptDecls_BlockScopeTop = pGeoGenScriptDecls_BlockScopePush(ctx);

     
    	returnCodeBlock= new CodeBlock();
     
    	CodeBlock* initExpressionCodeBlock = NULL; 
    	CodeBlock* conditionExpressionCodeBlock = NULL; 
    	CodeBlock* incrementExpressionCodeBlock = NULL; 
    	ctx->codeBlockLevel++; 
    	ctx->isInLoop = true;
    	(SCOPE_TOP(BlockScope))->breakCodeBlockLevel= ctx->codeBlockLevel; 
    	(SCOPE_TOP(BlockScope))->continueCodeBlockLevel= ctx->codeBlockLevel; 

    FOR46       = NULL;

    {
        // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:438:3: ( ^( FOR ( ^( INITIALIZATION_EXPRESSION initExpression ) )? ( ^( CONDITION_EXPRESSION conditionExpression= expression ) )? ( ^( INCREMENT_EXPRESSION incrementExpression= expression ) )? statement ) )
        // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:438:3: ^( FOR ( ^( INITIALIZATION_EXPRESSION initExpression ) )? ( ^( CONDITION_EXPRESSION conditionExpression= expression ) )? ( ^( INCREMENT_EXPRESSION incrementExpression= expression ) )? statement )
        {
            FOR46 = (pANTLR3_BASE_TREE) MATCHT(FOR, &FOLLOW_FOR_in_forStatement785);
            if  (HASEXCEPTION())
            {
                goto ruleforStatementEx;
            }


            MATCHT(ANTLR3_TOKEN_DOWN, NULL);
            if  (HASEXCEPTION())
            {
                goto ruleforStatementEx;
            }

            // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:439:2: ( ^( INITIALIZATION_EXPRESSION initExpression ) )?
            {
                int alt21=2;
                switch ( LA(1) )
                {
                    case INITIALIZATION_EXPRESSION:
                    	{
                    		alt21=1;
                    	}
                        break;
                }

                switch (alt21)
                {
            	case 1:
            	    // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:439:3: ^( INITIALIZATION_EXPRESSION initExpression )
            	    {
            	         MATCHT(INITIALIZATION_EXPRESSION, &FOLLOW_INITIALIZATION_EXPRESSION_in_forStatement791);
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleforStatementEx;
            	        }


            	        MATCHT(ANTLR3_TOKEN_DOWN, NULL);
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleforStatementEx;
            	        }

            	        FOLLOWPUSH(FOLLOW_initExpression_in_forStatement793);
            	        initExpression45=initExpression(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleforStatementEx;
            	        }


            	        {
            	             initExpressionCodeBlock = initExpression45
            	            ; 
            	        }


            	        MATCHT(ANTLR3_TOKEN_UP, NULL);
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleforStatementEx;
            	        }



            	    }
            	    break;

                }
            }

            // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:440:2: ( ^( CONDITION_EXPRESSION conditionExpression= expression ) )?
            {
                int alt22=2;
                switch ( LA(1) )
                {
                    case CONDITION_EXPRESSION:
                    	{
                    		alt22=1;
                    	}
                        break;
                }

                switch (alt22)
                {
            	case 1:
            	    // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:440:3: ^( CONDITION_EXPRESSION conditionExpression= expression )
            	    {
            	         MATCHT(CONDITION_EXPRESSION, &FOLLOW_CONDITION_EXPRESSION_in_forStatement805);
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleforStatementEx;
            	        }


            	        MATCHT(ANTLR3_TOKEN_DOWN, NULL);
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleforStatementEx;
            	        }

            	        FOLLOWPUSH(FOLLOW_expression_in_forStatement809);
            	        conditionExpression=expression(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleforStatementEx;
            	        }


            	        {
            	             conditionExpressionCodeBlock = conditionExpression
            	            ; 
            	        }


            	        MATCHT(ANTLR3_TOKEN_UP, NULL);
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleforStatementEx;
            	        }



            	    }
            	    break;

                }
            }

            // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:441:2: ( ^( INCREMENT_EXPRESSION incrementExpression= expression ) )?
            {
                int alt23=2;
                switch ( LA(1) )
                {
                    case INCREMENT_EXPRESSION:
                    	{
                    		alt23=1;
                    	}
                        break;
                }

                switch (alt23)
                {
            	case 1:
            	    // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:441:3: ^( INCREMENT_EXPRESSION incrementExpression= expression )
            	    {
            	         MATCHT(INCREMENT_EXPRESSION, &FOLLOW_INCREMENT_EXPRESSION_in_forStatement821);
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleforStatementEx;
            	        }


            	        MATCHT(ANTLR3_TOKEN_DOWN, NULL);
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleforStatementEx;
            	        }

            	        FOLLOWPUSH(FOLLOW_expression_in_forStatement825);
            	        incrementExpression=expression(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleforStatementEx;
            	        }


            	        {
            	             incrementExpressionCodeBlock = incrementExpression
            	            ; 
            	        }


            	        MATCHT(ANTLR3_TOKEN_UP, NULL);
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleforStatementEx;
            	        }



            	    }
            	    break;

                }
            }

            FOLLOWPUSH(FOLLOW_statement_in_forStatement835);
            statement47=statement(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleforStatementEx;
            }


            MATCHT(ANTLR3_TOKEN_UP, NULL);
            if  (HASEXCEPTION())
            {
                goto ruleforStatementEx;
            }



            {

                	CodeLocation location((FOR46->getLine(FOR46)), (FOR46->getCharPositionInLine(FOR46)));

                	if(initExpressionCodeBlock != NULL)
                	{
                		
                returnCodeBlock
                ->MoveInstructionsFrom(*initExpressionCodeBlock);
                		delete initExpressionCodeBlock;
                	}
                	
                	instructions::WhileInstruction* whileInstr = new instructions::WhileInstruction(location);
                	CodeBlock& whileCodeBlock = whileInstr->GetCodeBlock();
                	
                	if(conditionExpressionCodeBlock != NULL)
                	{
                		whileCodeBlock.MoveInstructionsFrom(*conditionExpressionCodeBlock);
                		delete conditionExpressionCodeBlock;
                		
                		instructions::IfInstruction* ifInstr = new instructions::IfInstruction(location);
                		ifInstr->GetElseBranchCodeBlock().AddInstruction(new instructions::BreakInstruction(location, 2));
                		whileCodeBlock.AddInstruction(ifInstr);
                	}

                	whileCodeBlock.MoveInstructionsFrom(*statement47
                );
                	delete statement47
                ;
                	
                	if(incrementExpressionCodeBlock != NULL)
                	{
                		whileCodeBlock.MoveInstructionsFrom(*incrementExpressionCodeBlock);
                		delete incrementExpressionCodeBlock;
                		
                		whileCodeBlock.AddInstruction(new instructions::PopInstruction(location));
                	}
                	
                	returnCodeBlock
                ->AddInstruction(whileInstr);

            }


        }

    }

    // This is where rules clean up and exit
    //
    goto ruleforStatementEx; /* Prevent compiler warnings */
    ruleforStatementEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
            else
            {
                {
                     ctx->codeBlockLevel--; ctx->isInLoop = false; 
                }
            }


    pGeoGenScriptDecls_BlockScopePop(ctx);

    return returnCodeBlock;
}
/* $ANTLR end forStatement */

/**
 * $ANTLR start initExpression
 * D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:479:1: initExpression returns [CodeBlock* returnCodeBlock] : ( variableDeclaration | expression );
 */
static CodeBlock*
initExpression(pGeoGenScriptDecls ctx)
{
    CodeBlock* returnCodeBlock;


    CodeBlock* variableDeclaration48;
    #undef	RETURN_TYPE_variableDeclaration48
    #define	RETURN_TYPE_variableDeclaration48 CodeBlock*

    CodeBlock* expression49;
    #undef	RETURN_TYPE_expression49
    #define	RETURN_TYPE_expression49 CodeBlock*

    /* Initialize rule variables
     */

     returnCodeBlock= NULL;
     
    {
        {
            //  D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:481:5: ( variableDeclaration | expression )

            ANTLR3_UINT32 alt24;

            alt24=2;

            switch ( LA(1) )
            {
            case VAR:
            	{
            		alt24=1;
            	}
                break;
            case COORDINATE:
            case FALSE_LIT:
            case IDENTIFIER:
            case LEFT_BRACKET:
            case LEFT_SQUARE_BRACKET:
            case NUMBER:
            case OPERATOR_ASSIGN:
            case OPERATOR_ASSIGN_AND:
            case OPERATOR_ASSIGN_DIVIDE:
            case OPERATOR_ASSIGN_LSHIFT:
            case OPERATOR_ASSIGN_MINUS:
            case OPERATOR_ASSIGN_MODULO:
            case OPERATOR_ASSIGN_OR:
            case OPERATOR_ASSIGN_PLUS:
            case OPERATOR_ASSIGN_RSHIFT:
            case OPERATOR_ASSIGN_TIMES:
            case OPERATOR_BIT_AND:
            case OPERATOR_BIT_OR:
            case OPERATOR_BIT_XOR:
            case OPERATOR_DECREMENT_POST:
            case OPERATOR_DECREMENT_PRE:
            case OPERATOR_DIVIDE:
            case OPERATOR_DOT:
            case OPERATOR_EQUAL_TO:
            case OPERATOR_EXPR_IF:
            case OPERATOR_GREATER_THAN:
            case OPERATOR_GREATER_THAN_OR_EQUAL_TO:
            case OPERATOR_INCREMENT_POST:
            case OPERATOR_INCREMENT_PRE:
            case OPERATOR_IS:
            case OPERATOR_LESS_THAN:
            case OPERATOR_LESS_THAN_OR_EQUAL_TO:
            case OPERATOR_LSHIFT:
            case OPERATOR_MINUS:
            case OPERATOR_MINUS_UN:
            case OPERATOR_MODULO:
            case OPERATOR_NOT:
            case OPERATOR_NOT_EQUAL_TO:
            case OPERATOR_PLUS:
            case OPERATOR_PLUS_UN:
            case OPERATOR_RELATIVE:
            case OPERATOR_REL_AND:
            case OPERATOR_REL_OR:
            case OPERATOR_RSHIFT:
            case OPERATOR_TIMES:
            case STRING:
            case TRUE_LIT:
            	{
            		alt24=2;
            	}
                break;

            default:
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 24;
                EXCEPTION->state        = 0;


                goto ruleinitExpressionEx;

            }

            switch (alt24)
            {
        	case 1:
        	    // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:482:5: variableDeclaration
        	    {
        	        FOLLOWPUSH(FOLLOW_variableDeclaration_in_initExpression860);
        	        variableDeclaration48=variableDeclaration(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleinitExpressionEx;
        	        }


        	        {
        	             returnCodeBlock= 
        	            variableDeclaration48
        	            ;
        	             
        	        }


        	    }
        	    break;
        	case 2:
        	    // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:483:7: expression
        	    {
        	        FOLLOWPUSH(FOLLOW_expression_in_initExpression870);
        	        expression49=expression(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleinitExpressionEx;
        	        }


        	        {
        	             returnCodeBlock= 
        	            expression49
        	            ;
        	             
        	        }


        	    }
        	    break;

            }
        }
    }

    // This is where rules clean up and exit
    //
    goto ruleinitExpressionEx; /* Prevent compiler warnings */
    ruleinitExpressionEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return returnCodeBlock;
}
/* $ANTLR end initExpression */

/**
 * $ANTLR start ifStatement
 * D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:485:1: ifStatement returns [CodeBlock* returnCodeBlock] : ^( IF expression ifBranchStatement= statement elseBranchStatement= statement ) ;
 */
static CodeBlock*
ifStatement(pGeoGenScriptDecls ctx)
{
    CodeBlock* returnCodeBlock;


    pANTLR3_BASE_TREE    IF50;
    CodeBlock* ifBranchStatement;
    #undef	RETURN_TYPE_ifBranchStatement
    #define	RETURN_TYPE_ifBranchStatement CodeBlock*

    CodeBlock* elseBranchStatement;
    #undef	RETURN_TYPE_elseBranchStatement
    #define	RETURN_TYPE_elseBranchStatement CodeBlock*

    CodeBlock* expression51;
    #undef	RETURN_TYPE_expression51
    #define	RETURN_TYPE_expression51 CodeBlock*

    /* Initialize rule variables
     */

     
    	returnCodeBlock= new CodeBlock();
     
    	ctx->codeBlockLevel++; 

    IF50       = NULL;

    {
        // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:491:34: ( ^( IF expression ifBranchStatement= statement elseBranchStatement= statement ) )
        // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:492:3: ^( IF expression ifBranchStatement= statement elseBranchStatement= statement )
        {
            IF50 = (pANTLR3_BASE_TREE) MATCHT(IF, &FOLLOW_IF_in_ifStatement896);
            if  (HASEXCEPTION())
            {
                goto ruleifStatementEx;
            }


            MATCHT(ANTLR3_TOKEN_DOWN, NULL);
            if  (HASEXCEPTION())
            {
                goto ruleifStatementEx;
            }

            FOLLOWPUSH(FOLLOW_expression_in_ifStatement898);
            expression51=expression(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleifStatementEx;
            }


            FOLLOWPUSH(FOLLOW_statement_in_ifStatement902);
            ifBranchStatement=statement(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleifStatementEx;
            }


            FOLLOWPUSH(FOLLOW_statement_in_ifStatement906);
            elseBranchStatement=statement(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleifStatementEx;
            }


            MATCHT(ANTLR3_TOKEN_UP, NULL);
            if  (HASEXCEPTION())
            {
                goto ruleifStatementEx;
            }



            {

                	CodeLocation location((IF50->getLine(IF50)), (IF50->getCharPositionInLine(IF50)));

                	
                returnCodeBlock
                ->MoveInstructionsFrom(*expression51
                );

                	instructions::IfInstruction* ifInstr = new instructions::IfInstruction(location);
                	
                	ifInstr->GetIfBranchCodeBlock().MoveInstructionsFrom(*ifBranchStatement
                );
                	delete ifBranchStatement
                ;
                	
                	ifInstr->GetElseBranchCodeBlock().MoveInstructionsFrom(*elseBranchStatement
                );
                	delete elseBranchStatement
                ;
                	
                	returnCodeBlock
                ->AddInstruction(ifInstr);

            }


        }

    }

    // This is where rules clean up and exit
    //
    goto ruleifStatementEx; /* Prevent compiler warnings */
    ruleifStatementEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
            else
            {
                {
                     ctx->codeBlockLevel--; 
                }
            }


    return returnCodeBlock;
}
/* $ANTLR end ifStatement */

/**
 * $ANTLR start switchStatement
 * D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:509:1: switchStatement : ^( SWITCH expression ( normalCase )* ( defaultCase )? ) ;
 */
static void
switchStatement(pGeoGenScriptDecls ctx)
{
    /* Initialize rule variables
     */

    {
        // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:509:16: ( ^( SWITCH expression ( normalCase )* ( defaultCase )? ) )
        // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:509:18: ^( SWITCH expression ( normalCase )* ( defaultCase )? )
        {
             MATCHT(SWITCH, &FOLLOW_SWITCH_in_switchStatement918);
            if  (HASEXCEPTION())
            {
                goto ruleswitchStatementEx;
            }


            MATCHT(ANTLR3_TOKEN_DOWN, NULL);
            if  (HASEXCEPTION())
            {
                goto ruleswitchStatementEx;
            }

            FOLLOWPUSH(FOLLOW_expression_in_switchStatement920);
            expression(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleswitchStatementEx;
            }


            // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:509:38: ( normalCase )*

            for (;;)
            {
                int alt25=2;
                switch ( LA(1) )
                {
                case CASE:
                	{
                		alt25=1;
                	}
                    break;

                }

                switch (alt25)
                {
            	case 1:
            	    // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:509:38: normalCase
            	    {
            	        FOLLOWPUSH(FOLLOW_normalCase_in_switchStatement922);
            	        normalCase(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleswitchStatementEx;
            	        }


            	    }
            	    break;

            	default:
            	    goto loop25;	/* break out of the loop */
            	    break;
                }
            }
            loop25: ; /* Jump out to here if this rule does not match */


            // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:509:50: ( defaultCase )?
            {
                int alt26=2;
                switch ( LA(1) )
                {
                    case DEFAULT:
                    	{
                    		alt26=1;
                    	}
                        break;
                }

                switch (alt26)
                {
            	case 1:
            	    // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:509:50: defaultCase
            	    {
            	        FOLLOWPUSH(FOLLOW_defaultCase_in_switchStatement925);
            	        defaultCase(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleswitchStatementEx;
            	        }


            	    }
            	    break;

                }
            }

            MATCHT(ANTLR3_TOKEN_UP, NULL);
            if  (HASEXCEPTION())
            {
                goto ruleswitchStatementEx;
            }



        }

    }

    // This is where rules clean up and exit
    //
    goto ruleswitchStatementEx; /* Prevent compiler warnings */
    ruleswitchStatementEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end switchStatement */

/**
 * $ANTLR start normalCase
 * D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:511:1: normalCase : ^( CASE label ^( BLOCK ( statement )* ) ) ;
 */
static void
normalCase(pGeoGenScriptDecls ctx)
{
    /* Initialize rule variables
     */

    {
        // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:511:11: ( ^( CASE label ^( BLOCK ( statement )* ) ) )
        // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:511:13: ^( CASE label ^( BLOCK ( statement )* ) )
        {
             MATCHT(CASE, &FOLLOW_CASE_in_normalCase935);
            if  (HASEXCEPTION())
            {
                goto rulenormalCaseEx;
            }


            MATCHT(ANTLR3_TOKEN_DOWN, NULL);
            if  (HASEXCEPTION())
            {
                goto rulenormalCaseEx;
            }

            FOLLOWPUSH(FOLLOW_label_in_normalCase937);
            label(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulenormalCaseEx;
            }


             MATCHT(BLOCK, &FOLLOW_BLOCK_in_normalCase940);
            if  (HASEXCEPTION())
            {
                goto rulenormalCaseEx;
            }


            if ( LA(1)==ANTLR3_TOKEN_DOWN ) {
                MATCHT(ANTLR3_TOKEN_DOWN, NULL);
                if  (HASEXCEPTION())
                {
                    goto rulenormalCaseEx;
                }

                // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:511:34: ( statement )*

                for (;;)
                {
                    int alt27=2;
                    switch ( LA(1) )
                    {
                    case BLOCK:
                    case BREAK:
                    case CONTINUE:
                    case COORDINATE:
                    case FALSE_LIT:
                    case FOR:
                    case GLOBAL:
                    case IDENTIFIER:
                    case IF:
                    case LEFT_BRACKET:
                    case LEFT_SQUARE_BRACKET:
                    case NUMBER:
                    case OPERATOR_ASSIGN:
                    case OPERATOR_ASSIGN_AND:
                    case OPERATOR_ASSIGN_DIVIDE:
                    case OPERATOR_ASSIGN_LSHIFT:
                    case OPERATOR_ASSIGN_MINUS:
                    case OPERATOR_ASSIGN_MODULO:
                    case OPERATOR_ASSIGN_OR:
                    case OPERATOR_ASSIGN_PLUS:
                    case OPERATOR_ASSIGN_RSHIFT:
                    case OPERATOR_ASSIGN_TIMES:
                    case OPERATOR_BIT_AND:
                    case OPERATOR_BIT_OR:
                    case OPERATOR_BIT_XOR:
                    case OPERATOR_DECREMENT_POST:
                    case OPERATOR_DECREMENT_PRE:
                    case OPERATOR_DIVIDE:
                    case OPERATOR_DOT:
                    case OPERATOR_EQUAL_TO:
                    case OPERATOR_EXPR_IF:
                    case OPERATOR_GREATER_THAN:
                    case OPERATOR_GREATER_THAN_OR_EQUAL_TO:
                    case OPERATOR_INCREMENT_POST:
                    case OPERATOR_INCREMENT_PRE:
                    case OPERATOR_IS:
                    case OPERATOR_LESS_THAN:
                    case OPERATOR_LESS_THAN_OR_EQUAL_TO:
                    case OPERATOR_LSHIFT:
                    case OPERATOR_MINUS:
                    case OPERATOR_MINUS_UN:
                    case OPERATOR_MODULO:
                    case OPERATOR_NOT:
                    case OPERATOR_NOT_EQUAL_TO:
                    case OPERATOR_PLUS:
                    case OPERATOR_PLUS_UN:
                    case OPERATOR_RELATIVE:
                    case OPERATOR_REL_AND:
                    case OPERATOR_REL_OR:
                    case OPERATOR_RSHIFT:
                    case OPERATOR_TIMES:
                    case RETURN:
                    case STRING:
                    case SWITCH:
                    case TRUE_LIT:
                    case VAR:
                    case WHILE:
                    case YIELD:
                    	{
                    		alt27=1;
                    	}
                        break;

                    }

                    switch (alt27)
                    {
                	case 1:
                	    // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:511:34: statement
                	    {
                	        FOLLOWPUSH(FOLLOW_statement_in_normalCase942);
                	        statement(ctx);

                	        FOLLOWPOP();
                	        if  (HASEXCEPTION())
                	        {
                	            goto rulenormalCaseEx;
                	        }


                	    }
                	    break;

                	default:
                	    goto loop27;	/* break out of the loop */
                	    break;
                    }
                }
                loop27: ; /* Jump out to here if this rule does not match */


                MATCHT(ANTLR3_TOKEN_UP, NULL);
                if  (HASEXCEPTION())
                {
                    goto rulenormalCaseEx;
                }

            }


            MATCHT(ANTLR3_TOKEN_UP, NULL);
            if  (HASEXCEPTION())
            {
                goto rulenormalCaseEx;
            }



        }

    }

    // This is where rules clean up and exit
    //
    goto rulenormalCaseEx; /* Prevent compiler warnings */
    rulenormalCaseEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end normalCase */

/**
 * $ANTLR start defaultCase
 * D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:512:1: defaultCase : ^( DEFAULT ^( BLOCK ( statement )* ) ) ;
 */
static void
defaultCase(pGeoGenScriptDecls ctx)
{
    /* Initialize rule variables
     */

    {
        // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:512:12: ( ^( DEFAULT ^( BLOCK ( statement )* ) ) )
        // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:512:14: ^( DEFAULT ^( BLOCK ( statement )* ) )
        {
             MATCHT(DEFAULT, &FOLLOW_DEFAULT_in_defaultCase952);
            if  (HASEXCEPTION())
            {
                goto ruledefaultCaseEx;
            }


            MATCHT(ANTLR3_TOKEN_DOWN, NULL);
            if  (HASEXCEPTION())
            {
                goto ruledefaultCaseEx;
            }

             MATCHT(BLOCK, &FOLLOW_BLOCK_in_defaultCase955);
            if  (HASEXCEPTION())
            {
                goto ruledefaultCaseEx;
            }


            if ( LA(1)==ANTLR3_TOKEN_DOWN ) {
                MATCHT(ANTLR3_TOKEN_DOWN, NULL);
                if  (HASEXCEPTION())
                {
                    goto ruledefaultCaseEx;
                }

                // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:512:32: ( statement )*

                for (;;)
                {
                    int alt28=2;
                    switch ( LA(1) )
                    {
                    case BLOCK:
                    case BREAK:
                    case CONTINUE:
                    case COORDINATE:
                    case FALSE_LIT:
                    case FOR:
                    case GLOBAL:
                    case IDENTIFIER:
                    case IF:
                    case LEFT_BRACKET:
                    case LEFT_SQUARE_BRACKET:
                    case NUMBER:
                    case OPERATOR_ASSIGN:
                    case OPERATOR_ASSIGN_AND:
                    case OPERATOR_ASSIGN_DIVIDE:
                    case OPERATOR_ASSIGN_LSHIFT:
                    case OPERATOR_ASSIGN_MINUS:
                    case OPERATOR_ASSIGN_MODULO:
                    case OPERATOR_ASSIGN_OR:
                    case OPERATOR_ASSIGN_PLUS:
                    case OPERATOR_ASSIGN_RSHIFT:
                    case OPERATOR_ASSIGN_TIMES:
                    case OPERATOR_BIT_AND:
                    case OPERATOR_BIT_OR:
                    case OPERATOR_BIT_XOR:
                    case OPERATOR_DECREMENT_POST:
                    case OPERATOR_DECREMENT_PRE:
                    case OPERATOR_DIVIDE:
                    case OPERATOR_DOT:
                    case OPERATOR_EQUAL_TO:
                    case OPERATOR_EXPR_IF:
                    case OPERATOR_GREATER_THAN:
                    case OPERATOR_GREATER_THAN_OR_EQUAL_TO:
                    case OPERATOR_INCREMENT_POST:
                    case OPERATOR_INCREMENT_PRE:
                    case OPERATOR_IS:
                    case OPERATOR_LESS_THAN:
                    case OPERATOR_LESS_THAN_OR_EQUAL_TO:
                    case OPERATOR_LSHIFT:
                    case OPERATOR_MINUS:
                    case OPERATOR_MINUS_UN:
                    case OPERATOR_MODULO:
                    case OPERATOR_NOT:
                    case OPERATOR_NOT_EQUAL_TO:
                    case OPERATOR_PLUS:
                    case OPERATOR_PLUS_UN:
                    case OPERATOR_RELATIVE:
                    case OPERATOR_REL_AND:
                    case OPERATOR_REL_OR:
                    case OPERATOR_RSHIFT:
                    case OPERATOR_TIMES:
                    case RETURN:
                    case STRING:
                    case SWITCH:
                    case TRUE_LIT:
                    case VAR:
                    case WHILE:
                    case YIELD:
                    	{
                    		alt28=1;
                    	}
                        break;

                    }

                    switch (alt28)
                    {
                	case 1:
                	    // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:512:32: statement
                	    {
                	        FOLLOWPUSH(FOLLOW_statement_in_defaultCase957);
                	        statement(ctx);

                	        FOLLOWPOP();
                	        if  (HASEXCEPTION())
                	        {
                	            goto ruledefaultCaseEx;
                	        }


                	    }
                	    break;

                	default:
                	    goto loop28;	/* break out of the loop */
                	    break;
                    }
                }
                loop28: ; /* Jump out to here if this rule does not match */


                MATCHT(ANTLR3_TOKEN_UP, NULL);
                if  (HASEXCEPTION())
                {
                    goto ruledefaultCaseEx;
                }

            }


            MATCHT(ANTLR3_TOKEN_UP, NULL);
            if  (HASEXCEPTION())
            {
                goto ruledefaultCaseEx;
            }



        }

    }

    // This is where rules clean up and exit
    //
    goto ruledefaultCaseEx; /* Prevent compiler warnings */
    ruledefaultCaseEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end defaultCase */

/**
 * $ANTLR start expression
 * D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:514:1: expression returns [CodeBlock* returnCodeBlock] : ( ^( OPERATOR_ASSIGN lvalueExpression rvalueExpression= expression ) | ^(op= OPERATOR_ASSIGN_PLUS e1= expression e2= expression ) | ^(op= '-=' e1= expression e2= expression ) | ^(op= '*=' e1= expression e2= expression ) | ^(op= '/=' e1= expression e2= expression ) | ^(op= '%=' e1= expression e2= expression ) | ^(op= '<<=' e1= expression e2= expression ) | ^(op= '>>=' e1= expression e2= expression ) | ^(op= '&=' e1= expression e2= expression ) | ^(op= '|=' e1= expression e2= expression ) | ^(op= 'is' e1= expression e2= expression ) | conditionalOperatorExpression | ^(op= '||' e1= expression e2= expression ) | ^(op= '&&' e1= expression e2= expression ) | ^(op= '^' e1= expression e2= expression ) | ^(op= '&' e1= expression e2= expression ) | ^(op= '|' e1= expression e2= expression ) | ^(op= '==' e1= expression e2= expression ) | ^(op= '!=' e1= expression e2= expression ) | ^(op= '<' e1= expression e2= expression ) | ^(op= '<=' e1= expression e2= expression ) | ^(op= '>' e1= expression e2= expression ) | ^(op= '>=' e1= expression e2= expression ) | ^(op= '<<' e1= expression e2= expression ) | ^(op= '>>' e1= expression e2= expression ) | ^(op= '+' e1= expression e2= expression ) | ^(op= '-' e1= expression e2= expression ) | ^(op= '*' e1= expression e2= expression ) | ^(op= '/' e1= expression e2= expression ) | ^(op= '%' e1= expression e2= expression ) | ^(op= OPERATOR_INCREMENT_PRE e1= expression ) | ^(op= OPERATOR_INCREMENT_POST e1= expression ) | ^(op= OPERATOR_DECREMENT_PRE e1= expression ) | ^(op= OPERATOR_DECREMENT_POST e1= expression ) | ^(op= OPERATOR_PLUS_UN e1= expression ) | ^(op= OPERATOR_MINUS_UN e1= expression ) | ^(op= OPERATOR_NOT e1= expression ) | ^(op= OPERATOR_RELATIVE e1= expression ) | ^( OPERATOR_DOT e1= expression IDENTIFIER ) | callExpression | indexAccessExpression | IDENTIFIER | TRUE_LIT | FALSE_LIT | NUMBER | STRING | coordinateExpression );
 */
static CodeBlock*
expression(pGeoGenScriptDecls ctx)
{
    CodeBlock* returnCodeBlock;


    pANTLR3_BASE_TREE    op;
    pANTLR3_BASE_TREE    OPERATOR_ASSIGN52;
    pANTLR3_BASE_TREE    OPERATOR_DOT55;
    pANTLR3_BASE_TREE    IDENTIFIER56;
    pANTLR3_BASE_TREE    IDENTIFIER59;
    pANTLR3_BASE_TREE    TRUE_LIT60;
    pANTLR3_BASE_TREE    FALSE_LIT61;
    pANTLR3_BASE_TREE    NUMBER62;
    pANTLR3_BASE_TREE    STRING63;
    CodeBlock* rvalueExpression;
    #undef	RETURN_TYPE_rvalueExpression
    #define	RETURN_TYPE_rvalueExpression CodeBlock*

    CodeBlock* e1;
    #undef	RETURN_TYPE_e1
    #define	RETURN_TYPE_e1 CodeBlock*

    CodeBlock* e2;
    #undef	RETURN_TYPE_e2
    #define	RETURN_TYPE_e2 CodeBlock*

    CodeBlock* lvalueExpression53;
    #undef	RETURN_TYPE_lvalueExpression53
    #define	RETURN_TYPE_lvalueExpression53 CodeBlock*

    CodeBlock* conditionalOperatorExpression54;
    #undef	RETURN_TYPE_conditionalOperatorExpression54
    #define	RETURN_TYPE_conditionalOperatorExpression54 CodeBlock*

    CodeBlock* callExpression57;
    #undef	RETURN_TYPE_callExpression57
    #define	RETURN_TYPE_callExpression57 CodeBlock*

    CodeBlock* indexAccessExpression58;
    #undef	RETURN_TYPE_indexAccessExpression58
    #define	RETURN_TYPE_indexAccessExpression58 CodeBlock*

    CodeBlock* coordinateExpression64;
    #undef	RETURN_TYPE_coordinateExpression64
    #define	RETURN_TYPE_coordinateExpression64 CodeBlock*

    /* Initialize rule variables
     */

     returnCodeBlock= new CodeBlock();
     
    op       = NULL;
    OPERATOR_ASSIGN52       = NULL;
    OPERATOR_DOT55       = NULL;
    IDENTIFIER56       = NULL;
    IDENTIFIER59       = NULL;
    TRUE_LIT60       = NULL;
    FALSE_LIT61       = NULL;
    NUMBER62       = NULL;
    STRING63       = NULL;

    {
        {
            //  D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:516:2: ( ^( OPERATOR_ASSIGN lvalueExpression rvalueExpression= expression ) | ^(op= OPERATOR_ASSIGN_PLUS e1= expression e2= expression ) | ^(op= '-=' e1= expression e2= expression ) | ^(op= '*=' e1= expression e2= expression ) | ^(op= '/=' e1= expression e2= expression ) | ^(op= '%=' e1= expression e2= expression ) | ^(op= '<<=' e1= expression e2= expression ) | ^(op= '>>=' e1= expression e2= expression ) | ^(op= '&=' e1= expression e2= expression ) | ^(op= '|=' e1= expression e2= expression ) | ^(op= 'is' e1= expression e2= expression ) | conditionalOperatorExpression | ^(op= '||' e1= expression e2= expression ) | ^(op= '&&' e1= expression e2= expression ) | ^(op= '^' e1= expression e2= expression ) | ^(op= '&' e1= expression e2= expression ) | ^(op= '|' e1= expression e2= expression ) | ^(op= '==' e1= expression e2= expression ) | ^(op= '!=' e1= expression e2= expression ) | ^(op= '<' e1= expression e2= expression ) | ^(op= '<=' e1= expression e2= expression ) | ^(op= '>' e1= expression e2= expression ) | ^(op= '>=' e1= expression e2= expression ) | ^(op= '<<' e1= expression e2= expression ) | ^(op= '>>' e1= expression e2= expression ) | ^(op= '+' e1= expression e2= expression ) | ^(op= '-' e1= expression e2= expression ) | ^(op= '*' e1= expression e2= expression ) | ^(op= '/' e1= expression e2= expression ) | ^(op= '%' e1= expression e2= expression ) | ^(op= OPERATOR_INCREMENT_PRE e1= expression ) | ^(op= OPERATOR_INCREMENT_POST e1= expression ) | ^(op= OPERATOR_DECREMENT_PRE e1= expression ) | ^(op= OPERATOR_DECREMENT_POST e1= expression ) | ^(op= OPERATOR_PLUS_UN e1= expression ) | ^(op= OPERATOR_MINUS_UN e1= expression ) | ^(op= OPERATOR_NOT e1= expression ) | ^(op= OPERATOR_RELATIVE e1= expression ) | ^( OPERATOR_DOT e1= expression IDENTIFIER ) | callExpression | indexAccessExpression | IDENTIFIER | TRUE_LIT | FALSE_LIT | NUMBER | STRING | coordinateExpression )

            ANTLR3_UINT32 alt29;

            alt29=47;

            switch ( LA(1) )
            {
            case OPERATOR_ASSIGN:
            	{
            		alt29=1;
            	}
                break;
            case OPERATOR_ASSIGN_PLUS:
            	{
            		alt29=2;
            	}
                break;
            case OPERATOR_ASSIGN_MINUS:
            	{
            		alt29=3;
            	}
                break;
            case OPERATOR_ASSIGN_TIMES:
            	{
            		alt29=4;
            	}
                break;
            case OPERATOR_ASSIGN_DIVIDE:
            	{
            		alt29=5;
            	}
                break;
            case OPERATOR_ASSIGN_MODULO:
            	{
            		alt29=6;
            	}
                break;
            case OPERATOR_ASSIGN_LSHIFT:
            	{
            		alt29=7;
            	}
                break;
            case OPERATOR_ASSIGN_RSHIFT:
            	{
            		alt29=8;
            	}
                break;
            case OPERATOR_ASSIGN_AND:
            	{
            		alt29=9;
            	}
                break;
            case OPERATOR_ASSIGN_OR:
            	{
            		alt29=10;
            	}
                break;
            case OPERATOR_IS:
            	{
            		alt29=11;
            	}
                break;
            case OPERATOR_EXPR_IF:
            	{
            		alt29=12;
            	}
                break;
            case OPERATOR_REL_OR:
            	{
            		alt29=13;
            	}
                break;
            case OPERATOR_REL_AND:
            	{
            		alt29=14;
            	}
                break;
            case OPERATOR_BIT_XOR:
            	{
            		alt29=15;
            	}
                break;
            case OPERATOR_BIT_AND:
            	{
            		alt29=16;
            	}
                break;
            case OPERATOR_BIT_OR:
            	{
            		alt29=17;
            	}
                break;
            case OPERATOR_EQUAL_TO:
            	{
            		alt29=18;
            	}
                break;
            case OPERATOR_NOT_EQUAL_TO:
            	{
            		alt29=19;
            	}
                break;
            case OPERATOR_LESS_THAN:
            	{
            		alt29=20;
            	}
                break;
            case OPERATOR_LESS_THAN_OR_EQUAL_TO:
            	{
            		alt29=21;
            	}
                break;
            case OPERATOR_GREATER_THAN:
            	{
            		alt29=22;
            	}
                break;
            case OPERATOR_GREATER_THAN_OR_EQUAL_TO:
            	{
            		alt29=23;
            	}
                break;
            case OPERATOR_LSHIFT:
            	{
            		alt29=24;
            	}
                break;
            case OPERATOR_RSHIFT:
            	{
            		alt29=25;
            	}
                break;
            case OPERATOR_PLUS:
            	{
            		alt29=26;
            	}
                break;
            case OPERATOR_MINUS:
            	{
            		alt29=27;
            	}
                break;
            case OPERATOR_TIMES:
            	{
            		alt29=28;
            	}
                break;
            case OPERATOR_DIVIDE:
            	{
            		alt29=29;
            	}
                break;
            case OPERATOR_MODULO:
            	{
            		alt29=30;
            	}
                break;
            case OPERATOR_INCREMENT_PRE:
            	{
            		alt29=31;
            	}
                break;
            case OPERATOR_INCREMENT_POST:
            	{
            		alt29=32;
            	}
                break;
            case OPERATOR_DECREMENT_PRE:
            	{
            		alt29=33;
            	}
                break;
            case OPERATOR_DECREMENT_POST:
            	{
            		alt29=34;
            	}
                break;
            case OPERATOR_PLUS_UN:
            	{
            		alt29=35;
            	}
                break;
            case OPERATOR_MINUS_UN:
            	{
            		alt29=36;
            	}
                break;
            case OPERATOR_NOT:
            	{
            		alt29=37;
            	}
                break;
            case OPERATOR_RELATIVE:
            	{
            		alt29=38;
            	}
                break;
            case OPERATOR_DOT:
            	{
            		alt29=39;
            	}
                break;
            case LEFT_BRACKET:
            	{
            		alt29=40;
            	}
                break;
            case LEFT_SQUARE_BRACKET:
            	{
            		alt29=41;
            	}
                break;
            case IDENTIFIER:
            	{
            		alt29=42;
            	}
                break;
            case TRUE_LIT:
            	{
            		alt29=43;
            	}
                break;
            case FALSE_LIT:
            	{
            		alt29=44;
            	}
                break;
            case NUMBER:
            	{
            		alt29=45;
            	}
                break;
            case STRING:
            	{
            		alt29=46;
            	}
                break;
            case COORDINATE:
            	{
            		alt29=47;
            	}
                break;

            default:
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 29;
                EXCEPTION->state        = 0;


                goto ruleexpressionEx;

            }

            switch (alt29)
            {
        	case 1:
        	    // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:517:2: ^( OPERATOR_ASSIGN lvalueExpression rvalueExpression= expression )
        	    {
        	        OPERATOR_ASSIGN52 = (pANTLR3_BASE_TREE) MATCHT(OPERATOR_ASSIGN, &FOLLOW_OPERATOR_ASSIGN_in_expression980);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_DOWN, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }

        	        FOLLOWPUSH(FOLLOW_lvalueExpression_in_expression982);
        	        lvalueExpression53=lvalueExpression(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }


        	        FOLLOWPUSH(FOLLOW_expression_in_expression986);
        	        rvalueExpression=expression(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_UP, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }



        	        {
        	             
        	            		CodeLocation location((OPERATOR_ASSIGN52->getLine(OPERATOR_ASSIGN52)), (OPERATOR_ASSIGN52->getCharPositionInLine(OPERATOR_ASSIGN52)));
        	            	
        	            		
        	            returnCodeBlock
        	            ->MoveInstructionsFrom(*rvalueExpression
        	            ); 
        	            		delete rvalueExpression
        	            ; 
        	            		
        	            		returnCodeBlock
        	            ->AddInstruction(new instructions::CallGlobalInstruction(location, "=", 1));
        	            		returnCodeBlock
        	            ->MoveInstructionsFrom(*lvalueExpression53
        	            ); 
        	            		delete lvalueExpression53
        	            ; 
        	            	
        	        }


        	    }
        	    break;
        	case 2:
        	    // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:528:4: ^(op= OPERATOR_ASSIGN_PLUS e1= expression e2= expression )
        	    {
        	        op = (pANTLR3_BASE_TREE) MATCHT(OPERATOR_ASSIGN_PLUS, &FOLLOW_OPERATOR_ASSIGN_PLUS_in_expression998);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_DOWN, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }

        	        FOLLOWPUSH(FOLLOW_expression_in_expression1002);
        	        e1=expression(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }


        	        FOLLOWPUSH(FOLLOW_expression_in_expression1006);
        	        e2=expression(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_UP, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }



        	        {
        	             binaryOperator(ctx, op, 
        	            e1
        	            , e2
        	            , returnCodeBlock
        	            );
        	        }


        	    }
        	    break;
        	case 3:
        	    // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:529:4: ^(op= '-=' e1= expression e2= expression )
        	    {
        	        op = (pANTLR3_BASE_TREE) MATCHT(OPERATOR_ASSIGN_MINUS, &FOLLOW_OPERATOR_ASSIGN_MINUS_in_expression1017);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_DOWN, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }

        	        FOLLOWPUSH(FOLLOW_expression_in_expression1021);
        	        e1=expression(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }


        	        FOLLOWPUSH(FOLLOW_expression_in_expression1025);
        	        e2=expression(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_UP, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }



        	        {
        	             binaryOperator(ctx, op, 
        	            e1
        	            , e2
        	            , returnCodeBlock
        	            );
        	        }


        	    }
        	    break;
        	case 4:
        	    // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:530:4: ^(op= '*=' e1= expression e2= expression )
        	    {
        	        op = (pANTLR3_BASE_TREE) MATCHT(OPERATOR_ASSIGN_TIMES, &FOLLOW_OPERATOR_ASSIGN_TIMES_in_expression1036);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_DOWN, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }

        	        FOLLOWPUSH(FOLLOW_expression_in_expression1040);
        	        e1=expression(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }


        	        FOLLOWPUSH(FOLLOW_expression_in_expression1044);
        	        e2=expression(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_UP, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }



        	        {
        	             binaryOperator(ctx, op, 
        	            e1
        	            , e2
        	            , returnCodeBlock
        	            );
        	        }


        	    }
        	    break;
        	case 5:
        	    // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:531:4: ^(op= '/=' e1= expression e2= expression )
        	    {
        	        op = (pANTLR3_BASE_TREE) MATCHT(OPERATOR_ASSIGN_DIVIDE, &FOLLOW_OPERATOR_ASSIGN_DIVIDE_in_expression1055);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_DOWN, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }

        	        FOLLOWPUSH(FOLLOW_expression_in_expression1059);
        	        e1=expression(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }


        	        FOLLOWPUSH(FOLLOW_expression_in_expression1063);
        	        e2=expression(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_UP, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }



        	        {
        	             binaryOperator(ctx, op, 
        	            e1
        	            , e2
        	            , returnCodeBlock
        	            );
        	        }


        	    }
        	    break;
        	case 6:
        	    // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:532:4: ^(op= '%=' e1= expression e2= expression )
        	    {
        	        op = (pANTLR3_BASE_TREE) MATCHT(OPERATOR_ASSIGN_MODULO, &FOLLOW_OPERATOR_ASSIGN_MODULO_in_expression1074);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_DOWN, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }

        	        FOLLOWPUSH(FOLLOW_expression_in_expression1078);
        	        e1=expression(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }


        	        FOLLOWPUSH(FOLLOW_expression_in_expression1082);
        	        e2=expression(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_UP, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }



        	        {
        	             binaryOperator(ctx, op, 
        	            e1
        	            , e2
        	            , returnCodeBlock
        	            );
        	        }


        	    }
        	    break;
        	case 7:
        	    // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:533:4: ^(op= '<<=' e1= expression e2= expression )
        	    {
        	        op = (pANTLR3_BASE_TREE) MATCHT(OPERATOR_ASSIGN_LSHIFT, &FOLLOW_OPERATOR_ASSIGN_LSHIFT_in_expression1093);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_DOWN, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }

        	        FOLLOWPUSH(FOLLOW_expression_in_expression1097);
        	        e1=expression(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }


        	        FOLLOWPUSH(FOLLOW_expression_in_expression1101);
        	        e2=expression(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_UP, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }



        	        {
        	             binaryOperator(ctx, op, 
        	            e1
        	            , e2
        	            , returnCodeBlock
        	            );
        	        }


        	    }
        	    break;
        	case 8:
        	    // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:534:4: ^(op= '>>=' e1= expression e2= expression )
        	    {
        	        op = (pANTLR3_BASE_TREE) MATCHT(OPERATOR_ASSIGN_RSHIFT, &FOLLOW_OPERATOR_ASSIGN_RSHIFT_in_expression1112);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_DOWN, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }

        	        FOLLOWPUSH(FOLLOW_expression_in_expression1116);
        	        e1=expression(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }


        	        FOLLOWPUSH(FOLLOW_expression_in_expression1120);
        	        e2=expression(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_UP, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }



        	        {
        	             binaryOperator(ctx, op, 
        	            e1
        	            , e2
        	            , returnCodeBlock
        	            );
        	        }


        	    }
        	    break;
        	case 9:
        	    // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:535:4: ^(op= '&=' e1= expression e2= expression )
        	    {
        	        op = (pANTLR3_BASE_TREE) MATCHT(OPERATOR_ASSIGN_AND, &FOLLOW_OPERATOR_ASSIGN_AND_in_expression1131);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_DOWN, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }

        	        FOLLOWPUSH(FOLLOW_expression_in_expression1135);
        	        e1=expression(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }


        	        FOLLOWPUSH(FOLLOW_expression_in_expression1139);
        	        e2=expression(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_UP, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }



        	        {
        	             binaryOperator(ctx, op, 
        	            e1
        	            , e2
        	            , returnCodeBlock
        	            );
        	        }


        	    }
        	    break;
        	case 10:
        	    // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:536:4: ^(op= '|=' e1= expression e2= expression )
        	    {
        	        op = (pANTLR3_BASE_TREE) MATCHT(OPERATOR_ASSIGN_OR, &FOLLOW_OPERATOR_ASSIGN_OR_in_expression1150);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_DOWN, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }

        	        FOLLOWPUSH(FOLLOW_expression_in_expression1154);
        	        e1=expression(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }


        	        FOLLOWPUSH(FOLLOW_expression_in_expression1158);
        	        e2=expression(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_UP, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }



        	        {
        	             binaryOperator(ctx, op, 
        	            e1
        	            , e2
        	            , returnCodeBlock
        	            );
        	        }


        	    }
        	    break;
        	case 11:
        	    // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:537:4: ^(op= 'is' e1= expression e2= expression )
        	    {
        	        op = (pANTLR3_BASE_TREE) MATCHT(OPERATOR_IS, &FOLLOW_OPERATOR_IS_in_expression1169);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_DOWN, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }

        	        FOLLOWPUSH(FOLLOW_expression_in_expression1173);
        	        e1=expression(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }


        	        FOLLOWPUSH(FOLLOW_expression_in_expression1177);
        	        e2=expression(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_UP, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }



        	        {
        	             binaryOperator(ctx, op, 
        	            e1
        	            , e2
        	            , returnCodeBlock
        	            );
        	        }


        	    }
        	    break;
        	case 12:
        	    // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:538:4: conditionalOperatorExpression
        	    {
        	        FOLLOWPUSH(FOLLOW_conditionalOperatorExpression_in_expression1185);
        	        conditionalOperatorExpression54=conditionalOperatorExpression(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }


        	        {
        	             returnCodeBlock
        	            ->MoveInstructionsFrom(*conditionalOperatorExpression54
        	            ); delete conditionalOperatorExpression54
        	            ;
        	        }


        	    }
        	    break;
        	case 13:
        	    // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:539:4: ^(op= '||' e1= expression e2= expression )
        	    {
        	        op = (pANTLR3_BASE_TREE) MATCHT(OPERATOR_REL_OR, &FOLLOW_OPERATOR_REL_OR_in_expression1196);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_DOWN, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }

        	        FOLLOWPUSH(FOLLOW_expression_in_expression1200);
        	        e1=expression(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }


        	        FOLLOWPUSH(FOLLOW_expression_in_expression1204);
        	        e2=expression(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_UP, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }



        	        {
        	             binaryOperator(ctx, op, 
        	            e1
        	            , e2
        	            , returnCodeBlock
        	            );
        	        }


        	    }
        	    break;
        	case 14:
        	    // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:540:4: ^(op= '&&' e1= expression e2= expression )
        	    {
        	        op = (pANTLR3_BASE_TREE) MATCHT(OPERATOR_REL_AND, &FOLLOW_OPERATOR_REL_AND_in_expression1215);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_DOWN, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }

        	        FOLLOWPUSH(FOLLOW_expression_in_expression1219);
        	        e1=expression(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }


        	        FOLLOWPUSH(FOLLOW_expression_in_expression1223);
        	        e2=expression(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_UP, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }



        	        {
        	             binaryOperator(ctx, op, 
        	            e1
        	            , e2
        	            , returnCodeBlock
        	            );
        	        }


        	    }
        	    break;
        	case 15:
        	    // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:541:4: ^(op= '^' e1= expression e2= expression )
        	    {
        	        op = (pANTLR3_BASE_TREE) MATCHT(OPERATOR_BIT_XOR, &FOLLOW_OPERATOR_BIT_XOR_in_expression1234);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_DOWN, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }

        	        FOLLOWPUSH(FOLLOW_expression_in_expression1238);
        	        e1=expression(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }


        	        FOLLOWPUSH(FOLLOW_expression_in_expression1242);
        	        e2=expression(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_UP, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }



        	        {
        	             binaryOperator(ctx, op, 
        	            e1
        	            , e2
        	            , returnCodeBlock
        	            );
        	        }


        	    }
        	    break;
        	case 16:
        	    // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:542:4: ^(op= '&' e1= expression e2= expression )
        	    {
        	        op = (pANTLR3_BASE_TREE) MATCHT(OPERATOR_BIT_AND, &FOLLOW_OPERATOR_BIT_AND_in_expression1253);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_DOWN, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }

        	        FOLLOWPUSH(FOLLOW_expression_in_expression1257);
        	        e1=expression(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }


        	        FOLLOWPUSH(FOLLOW_expression_in_expression1261);
        	        e2=expression(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_UP, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }



        	        {
        	             binaryOperator(ctx, op, 
        	            e1
        	            , e2
        	            , returnCodeBlock
        	            );
        	        }


        	    }
        	    break;
        	case 17:
        	    // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:543:4: ^(op= '|' e1= expression e2= expression )
        	    {
        	        op = (pANTLR3_BASE_TREE) MATCHT(OPERATOR_BIT_OR, &FOLLOW_OPERATOR_BIT_OR_in_expression1272);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_DOWN, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }

        	        FOLLOWPUSH(FOLLOW_expression_in_expression1276);
        	        e1=expression(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }


        	        FOLLOWPUSH(FOLLOW_expression_in_expression1280);
        	        e2=expression(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_UP, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }



        	        {
        	             binaryOperator(ctx, op, 
        	            e1
        	            , e2
        	            , returnCodeBlock
        	            );
        	        }


        	    }
        	    break;
        	case 18:
        	    // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:544:4: ^(op= '==' e1= expression e2= expression )
        	    {
        	        op = (pANTLR3_BASE_TREE) MATCHT(OPERATOR_EQUAL_TO, &FOLLOW_OPERATOR_EQUAL_TO_in_expression1291);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_DOWN, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }

        	        FOLLOWPUSH(FOLLOW_expression_in_expression1295);
        	        e1=expression(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }


        	        FOLLOWPUSH(FOLLOW_expression_in_expression1299);
        	        e2=expression(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_UP, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }



        	        {
        	             binaryOperator(ctx, op, 
        	            e1
        	            , e2
        	            , returnCodeBlock
        	            );
        	        }


        	    }
        	    break;
        	case 19:
        	    // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:545:4: ^(op= '!=' e1= expression e2= expression )
        	    {
        	        op = (pANTLR3_BASE_TREE) MATCHT(OPERATOR_NOT_EQUAL_TO, &FOLLOW_OPERATOR_NOT_EQUAL_TO_in_expression1310);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_DOWN, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }

        	        FOLLOWPUSH(FOLLOW_expression_in_expression1314);
        	        e1=expression(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }


        	        FOLLOWPUSH(FOLLOW_expression_in_expression1318);
        	        e2=expression(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_UP, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }



        	        {
        	             binaryOperator(ctx, op, 
        	            e1
        	            , e2
        	            , returnCodeBlock
        	            );
        	        }


        	    }
        	    break;
        	case 20:
        	    // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:546:4: ^(op= '<' e1= expression e2= expression )
        	    {
        	        op = (pANTLR3_BASE_TREE) MATCHT(OPERATOR_LESS_THAN, &FOLLOW_OPERATOR_LESS_THAN_in_expression1329);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_DOWN, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }

        	        FOLLOWPUSH(FOLLOW_expression_in_expression1333);
        	        e1=expression(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }


        	        FOLLOWPUSH(FOLLOW_expression_in_expression1337);
        	        e2=expression(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_UP, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }



        	        {
        	             binaryOperator(ctx, op, 
        	            e1
        	            , e2
        	            , returnCodeBlock
        	            );
        	        }


        	    }
        	    break;
        	case 21:
        	    // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:547:4: ^(op= '<=' e1= expression e2= expression )
        	    {
        	        op = (pANTLR3_BASE_TREE) MATCHT(OPERATOR_LESS_THAN_OR_EQUAL_TO, &FOLLOW_OPERATOR_LESS_THAN_OR_EQUAL_TO_in_expression1348);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_DOWN, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }

        	        FOLLOWPUSH(FOLLOW_expression_in_expression1352);
        	        e1=expression(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }


        	        FOLLOWPUSH(FOLLOW_expression_in_expression1356);
        	        e2=expression(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_UP, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }



        	        {
        	             binaryOperator(ctx, op, 
        	            e1
        	            , e2
        	            , returnCodeBlock
        	            );
        	        }


        	    }
        	    break;
        	case 22:
        	    // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:548:4: ^(op= '>' e1= expression e2= expression )
        	    {
        	        op = (pANTLR3_BASE_TREE) MATCHT(OPERATOR_GREATER_THAN, &FOLLOW_OPERATOR_GREATER_THAN_in_expression1367);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_DOWN, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }

        	        FOLLOWPUSH(FOLLOW_expression_in_expression1371);
        	        e1=expression(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }


        	        FOLLOWPUSH(FOLLOW_expression_in_expression1375);
        	        e2=expression(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_UP, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }



        	        {
        	             binaryOperator(ctx, op, 
        	            e1
        	            , e2
        	            , returnCodeBlock
        	            );
        	        }


        	    }
        	    break;
        	case 23:
        	    // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:549:4: ^(op= '>=' e1= expression e2= expression )
        	    {
        	        op = (pANTLR3_BASE_TREE) MATCHT(OPERATOR_GREATER_THAN_OR_EQUAL_TO, &FOLLOW_OPERATOR_GREATER_THAN_OR_EQUAL_TO_in_expression1386);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_DOWN, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }

        	        FOLLOWPUSH(FOLLOW_expression_in_expression1390);
        	        e1=expression(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }


        	        FOLLOWPUSH(FOLLOW_expression_in_expression1394);
        	        e2=expression(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_UP, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }



        	        {
        	             binaryOperator(ctx, op, 
        	            e1
        	            , e2
        	            , returnCodeBlock
        	            );
        	        }


        	    }
        	    break;
        	case 24:
        	    // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:550:4: ^(op= '<<' e1= expression e2= expression )
        	    {
        	        op = (pANTLR3_BASE_TREE) MATCHT(OPERATOR_LSHIFT, &FOLLOW_OPERATOR_LSHIFT_in_expression1405);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_DOWN, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }

        	        FOLLOWPUSH(FOLLOW_expression_in_expression1409);
        	        e1=expression(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }


        	        FOLLOWPUSH(FOLLOW_expression_in_expression1413);
        	        e2=expression(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_UP, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }



        	        {
        	             binaryOperator(ctx, op, 
        	            e1
        	            , e2
        	            , returnCodeBlock
        	            );
        	        }


        	    }
        	    break;
        	case 25:
        	    // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:551:4: ^(op= '>>' e1= expression e2= expression )
        	    {
        	        op = (pANTLR3_BASE_TREE) MATCHT(OPERATOR_RSHIFT, &FOLLOW_OPERATOR_RSHIFT_in_expression1424);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_DOWN, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }

        	        FOLLOWPUSH(FOLLOW_expression_in_expression1428);
        	        e1=expression(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }


        	        FOLLOWPUSH(FOLLOW_expression_in_expression1432);
        	        e2=expression(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_UP, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }



        	        {
        	             binaryOperator(ctx, op, 
        	            e1
        	            , e2
        	            , returnCodeBlock
        	            );
        	        }


        	    }
        	    break;
        	case 26:
        	    // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:552:4: ^(op= '+' e1= expression e2= expression )
        	    {
        	        op = (pANTLR3_BASE_TREE) MATCHT(OPERATOR_PLUS, &FOLLOW_OPERATOR_PLUS_in_expression1443);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_DOWN, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }

        	        FOLLOWPUSH(FOLLOW_expression_in_expression1447);
        	        e1=expression(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }


        	        FOLLOWPUSH(FOLLOW_expression_in_expression1451);
        	        e2=expression(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_UP, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }



        	        {
        	             binaryOperator(ctx, op, 
        	            e1
        	            , e2
        	            , returnCodeBlock
        	            );
        	        }


        	    }
        	    break;
        	case 27:
        	    // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:553:4: ^(op= '-' e1= expression e2= expression )
        	    {
        	        op = (pANTLR3_BASE_TREE) MATCHT(OPERATOR_MINUS, &FOLLOW_OPERATOR_MINUS_in_expression1462);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_DOWN, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }

        	        FOLLOWPUSH(FOLLOW_expression_in_expression1466);
        	        e1=expression(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }


        	        FOLLOWPUSH(FOLLOW_expression_in_expression1470);
        	        e2=expression(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_UP, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }



        	        {
        	             binaryOperator(ctx, op, 
        	            e1
        	            , e2
        	            , returnCodeBlock
        	            );
        	        }


        	    }
        	    break;
        	case 28:
        	    // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:554:4: ^(op= '*' e1= expression e2= expression )
        	    {
        	        op = (pANTLR3_BASE_TREE) MATCHT(OPERATOR_TIMES, &FOLLOW_OPERATOR_TIMES_in_expression1481);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_DOWN, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }

        	        FOLLOWPUSH(FOLLOW_expression_in_expression1485);
        	        e1=expression(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }


        	        FOLLOWPUSH(FOLLOW_expression_in_expression1489);
        	        e2=expression(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_UP, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }



        	        {
        	             binaryOperator(ctx, op, 
        	            e1
        	            , e2
        	            , returnCodeBlock
        	            );
        	        }


        	    }
        	    break;
        	case 29:
        	    // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:555:4: ^(op= '/' e1= expression e2= expression )
        	    {
        	        op = (pANTLR3_BASE_TREE) MATCHT(OPERATOR_DIVIDE, &FOLLOW_OPERATOR_DIVIDE_in_expression1500);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_DOWN, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }

        	        FOLLOWPUSH(FOLLOW_expression_in_expression1504);
        	        e1=expression(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }


        	        FOLLOWPUSH(FOLLOW_expression_in_expression1508);
        	        e2=expression(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_UP, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }



        	        {
        	             binaryOperator(ctx, op, 
        	            e1
        	            , e2
        	            , returnCodeBlock
        	            );
        	        }


        	    }
        	    break;
        	case 30:
        	    // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:556:4: ^(op= '%' e1= expression e2= expression )
        	    {
        	        op = (pANTLR3_BASE_TREE) MATCHT(OPERATOR_MODULO, &FOLLOW_OPERATOR_MODULO_in_expression1519);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_DOWN, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }

        	        FOLLOWPUSH(FOLLOW_expression_in_expression1523);
        	        e1=expression(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }


        	        FOLLOWPUSH(FOLLOW_expression_in_expression1527);
        	        e2=expression(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_UP, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }



        	        {
        	             binaryOperator(ctx, op, 
        	            e1
        	            , e2
        	            , returnCodeBlock
        	            );
        	        }


        	    }
        	    break;
        	case 31:
        	    // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:557:4: ^(op= OPERATOR_INCREMENT_PRE e1= expression )
        	    {
        	        op = (pANTLR3_BASE_TREE) MATCHT(OPERATOR_INCREMENT_PRE, &FOLLOW_OPERATOR_INCREMENT_PRE_in_expression1538);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_DOWN, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }

        	        FOLLOWPUSH(FOLLOW_expression_in_expression1542);
        	        e1=expression(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_UP, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }



        	        {
        	             unaryOperator(ctx, op, "++pre", 
        	            e1
        	            , returnCodeBlock
        	            );
        	        }


        	    }
        	    break;
        	case 32:
        	    // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:558:4: ^(op= OPERATOR_INCREMENT_POST e1= expression )
        	    {
        	        op = (pANTLR3_BASE_TREE) MATCHT(OPERATOR_INCREMENT_POST, &FOLLOW_OPERATOR_INCREMENT_POST_in_expression1554);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_DOWN, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }

        	        FOLLOWPUSH(FOLLOW_expression_in_expression1558);
        	        e1=expression(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_UP, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }



        	        {
        	             unaryOperator(ctx, op, "++post", 
        	            e1
        	            , returnCodeBlock
        	            );
        	        }


        	    }
        	    break;
        	case 33:
        	    // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:559:4: ^(op= OPERATOR_DECREMENT_PRE e1= expression )
        	    {
        	        op = (pANTLR3_BASE_TREE) MATCHT(OPERATOR_DECREMENT_PRE, &FOLLOW_OPERATOR_DECREMENT_PRE_in_expression1571);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_DOWN, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }

        	        FOLLOWPUSH(FOLLOW_expression_in_expression1575);
        	        e1=expression(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_UP, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }



        	        {
        	             unaryOperator(ctx, op, "--pre", 
        	            e1
        	            , returnCodeBlock
        	            );
        	        }


        	    }
        	    break;
        	case 34:
        	    // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:560:4: ^(op= OPERATOR_DECREMENT_POST e1= expression )
        	    {
        	        op = (pANTLR3_BASE_TREE) MATCHT(OPERATOR_DECREMENT_POST, &FOLLOW_OPERATOR_DECREMENT_POST_in_expression1587);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_DOWN, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }

        	        FOLLOWPUSH(FOLLOW_expression_in_expression1591);
        	        e1=expression(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_UP, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }



        	        {
        	             unaryOperator(ctx, op, "--post", 
        	            e1
        	            , returnCodeBlock
        	            );
        	        }


        	    }
        	    break;
        	case 35:
        	    // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:561:4: ^(op= OPERATOR_PLUS_UN e1= expression )
        	    {
        	        op = (pANTLR3_BASE_TREE) MATCHT(OPERATOR_PLUS_UN, &FOLLOW_OPERATOR_PLUS_UN_in_expression1606);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_DOWN, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }

        	        FOLLOWPUSH(FOLLOW_expression_in_expression1610);
        	        e1=expression(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_UP, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }



        	        {
        	             unaryOperator(ctx, op, "+un", 
        	            e1
        	            , returnCodeBlock
        	            );
        	        }


        	    }
        	    break;
        	case 36:
        	    // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:562:4: ^(op= OPERATOR_MINUS_UN e1= expression )
        	    {
        	        op = (pANTLR3_BASE_TREE) MATCHT(OPERATOR_MINUS_UN, &FOLLOW_OPERATOR_MINUS_UN_in_expression1625);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_DOWN, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }

        	        FOLLOWPUSH(FOLLOW_expression_in_expression1629);
        	        e1=expression(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_UP, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }



        	        {
        	             unaryOperator(ctx, op, "-un", 
        	            e1
        	            , returnCodeBlock
        	            );
        	        }


        	    }
        	    break;
        	case 37:
        	    // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:563:4: ^(op= OPERATOR_NOT e1= expression )
        	    {
        	        op = (pANTLR3_BASE_TREE) MATCHT(OPERATOR_NOT, &FOLLOW_OPERATOR_NOT_in_expression1645);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_DOWN, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }

        	        FOLLOWPUSH(FOLLOW_expression_in_expression1649);
        	        e1=expression(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_UP, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }



        	        {
        	             unaryOperator(ctx, op, "!", 
        	            e1
        	            , returnCodeBlock
        	            );
        	        }


        	    }
        	    break;
        	case 38:
        	    // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:564:4: ^(op= OPERATOR_RELATIVE e1= expression )
        	    {
        	        op = (pANTLR3_BASE_TREE) MATCHT(OPERATOR_RELATIVE, &FOLLOW_OPERATOR_RELATIVE_in_expression1666);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_DOWN, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }

        	        FOLLOWPUSH(FOLLOW_expression_in_expression1670);
        	        e1=expression(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_UP, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }



        	        {
        	             unaryOperator(ctx, op, "@", 
        	            e1
        	            , returnCodeBlock
        	            );
        	        }


        	    }
        	    break;
        	case 39:
        	    // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:565:4: ^( OPERATOR_DOT e1= expression IDENTIFIER )
        	    {
        	        OPERATOR_DOT55 = (pANTLR3_BASE_TREE) MATCHT(OPERATOR_DOT, &FOLLOW_OPERATOR_DOT_in_expression1686);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_DOWN, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }

        	        FOLLOWPUSH(FOLLOW_expression_in_expression1690);
        	        e1=expression(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }


        	        IDENTIFIER56 = (pANTLR3_BASE_TREE) MATCHT(IDENTIFIER, &FOLLOW_IDENTIFIER_in_expression1692);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_UP, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }



        	        {
        	             
        	            		CodeLocation location((OPERATOR_DOT55->getLine(OPERATOR_DOT55)), (OPERATOR_DOT55->getCharPositionInLine(OPERATOR_DOT55)));
        	            	
        	            		
        	            returnCodeBlock
        	            ->MoveInstructionsFrom(*e1
        	            ); 
        	            		delete e1
        	            ; 
        	            		
        	            		returnCodeBlock
        	            ->AddInstruction(new instructions::LoadMemberValueInstruction(location, (char*)(IDENTIFIER56->getText(IDENTIFIER56))->chars));
        	            	
        	        }


        	    }
        	    break;
        	case 40:
        	    // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:574:4: callExpression
        	    {
        	        FOLLOWPUSH(FOLLOW_callExpression_in_expression1702);
        	        callExpression57=callExpression(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }


        	        {
        	             returnCodeBlock
        	            ->MoveInstructionsFrom(*callExpression57
        	            ); delete callExpression57
        	            ;
        	        }


        	    }
        	    break;
        	case 41:
        	    // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:575:4: indexAccessExpression
        	    {
        	        FOLLOWPUSH(FOLLOW_indexAccessExpression_in_expression1710);
        	        indexAccessExpression58=indexAccessExpression(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }


        	        {
        	             returnCodeBlock
        	            ->MoveInstructionsFrom(*indexAccessExpression58
        	            ); delete indexAccessExpression58
        	            ;
        	        }


        	    }
        	    break;
        	case 42:
        	    // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:576:4: IDENTIFIER
        	    {
        	        IDENTIFIER59 = (pANTLR3_BASE_TREE) MATCHT(IDENTIFIER, &FOLLOW_IDENTIFIER_in_expression1718);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }


        	        {
        	             
        	            		CodeLocation location((IDENTIFIER59->getLine(IDENTIFIER59)), (IDENTIFIER59->getCharPositionInLine(IDENTIFIER59)));
        	            		
        	            returnCodeBlock
        	            ->AddInstruction(new instructions::LoadScopeValueInstruction(location, (char*)(IDENTIFIER59->getText(IDENTIFIER59))->chars)); 
        	            	
        	        }


        	    }
        	    break;
        	case 43:
        	    // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:582:4: TRUE_LIT
        	    {
        	        TRUE_LIT60 = (pANTLR3_BASE_TREE) MATCHT(TRUE_LIT, &FOLLOW_TRUE_LIT_in_expression1729);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }


        	        {
        	             
        	            		CodeLocation location((TRUE_LIT60->getLine(TRUE_LIT60)), (TRUE_LIT60->getCharPositionInLine(TRUE_LIT60)));
        	            		
        	            returnCodeBlock
        	            ->AddInstruction(new instructions::LoadConstBooleanInstruction(location, true));	
        	            	
        	        }


        	    }
        	    break;
        	case 44:
        	    // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:587:4: FALSE_LIT
        	    {
        	        FALSE_LIT61 = (pANTLR3_BASE_TREE) MATCHT(FALSE_LIT, &FOLLOW_FALSE_LIT_in_expression1737);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }


        	        {
        	             
        	            		CodeLocation location((FALSE_LIT61->getLine(FALSE_LIT61)), (FALSE_LIT61->getCharPositionInLine(FALSE_LIT61)));
        	            		
        	            returnCodeBlock
        	            ->AddInstruction(new instructions::LoadConstBooleanInstruction(location, false));
        	            	
        	        }


        	    }
        	    break;
        	case 45:
        	    // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:592:4: NUMBER
        	    {
        	        NUMBER62 = (pANTLR3_BASE_TREE) MATCHT(NUMBER, &FOLLOW_NUMBER_in_expression1746);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }


        	        {
        	             
        	            		CodeLocation location((NUMBER62->getLine(NUMBER62)), (NUMBER62->getCharPositionInLine(NUMBER62)));	
        	            		
        	            returnCodeBlock
        	            ->AddInstruction(new instructions::LoadConstNumberInstruction(location, StringToNumber((char*)(NUMBER62->getText(NUMBER62))->chars)));
        	            	
        	        }


        	    }
        	    break;
        	case 46:
        	    // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:597:4: STRING
        	    {
        	        STRING63 = (pANTLR3_BASE_TREE) MATCHT(STRING, &FOLLOW_STRING_in_expression1755);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }


        	        {
        	             
        	            		CodeLocation location((STRING63->getLine(STRING63)), (STRING63->getCharPositionInLine(STRING63)));	
        	            		
        	            returnCodeBlock
        	            ->AddInstruction(new instructions::LoadConstStringInstruction(location, (char*)(STRING63->getText(STRING63))->chars));
        	            	
        	        }


        	    }
        	    break;
        	case 47:
        	    // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:602:4: coordinateExpression
        	    {
        	        FOLLOWPUSH(FOLLOW_coordinateExpression_in_expression1764);
        	        coordinateExpression64=coordinateExpression(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }


        	        {
        	             returnCodeBlock
        	            ->MoveInstructionsFrom(*coordinateExpression64
        	            ); delete coordinateExpression64
        	            ;
        	        }


        	    }
        	    break;

            }
        }
    }

    // This is where rules clean up and exit
    //
    goto ruleexpressionEx; /* Prevent compiler warnings */
    ruleexpressionEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return returnCodeBlock;
}
/* $ANTLR end expression */

/**
 * $ANTLR start coordinateExpression
 * D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:605:1: coordinateExpression returns [CodeBlock* returnCodeBlock] : ^( COORDINATE ( expression )* ) ;
 */
static CodeBlock*
coordinateExpression(pGeoGenScriptDecls ctx)
{
    CodeBlock* returnCodeBlock;


    pANTLR3_BASE_TREE    COORDINATE66;
    CodeBlock* expression65;
    #undef	RETURN_TYPE_expression65
    #define	RETURN_TYPE_expression65 CodeBlock*

    /* Initialize rule variables
     */

     returnCodeBlock= new CodeBlock();
     std::vector<CodeBlock*> argumentCodeBlocks; 
    COORDINATE66       = NULL;

    {
        // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:607:3: ( ^( COORDINATE ( expression )* ) )
        // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:608:3: ^( COORDINATE ( expression )* )
        {
            COORDINATE66 = (pANTLR3_BASE_TREE) MATCHT(COORDINATE, &FOLLOW_COORDINATE_in_coordinateExpression1788);
            if  (HASEXCEPTION())
            {
                goto rulecoordinateExpressionEx;
            }


            if ( LA(1)==ANTLR3_TOKEN_DOWN ) {
                MATCHT(ANTLR3_TOKEN_DOWN, NULL);
                if  (HASEXCEPTION())
                {
                    goto rulecoordinateExpressionEx;
                }

                // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:608:14: ( expression )*

                for (;;)
                {
                    int alt30=2;
                    switch ( LA(1) )
                    {
                    case COORDINATE:
                    case FALSE_LIT:
                    case IDENTIFIER:
                    case LEFT_BRACKET:
                    case LEFT_SQUARE_BRACKET:
                    case NUMBER:
                    case OPERATOR_ASSIGN:
                    case OPERATOR_ASSIGN_AND:
                    case OPERATOR_ASSIGN_DIVIDE:
                    case OPERATOR_ASSIGN_LSHIFT:
                    case OPERATOR_ASSIGN_MINUS:
                    case OPERATOR_ASSIGN_MODULO:
                    case OPERATOR_ASSIGN_OR:
                    case OPERATOR_ASSIGN_PLUS:
                    case OPERATOR_ASSIGN_RSHIFT:
                    case OPERATOR_ASSIGN_TIMES:
                    case OPERATOR_BIT_AND:
                    case OPERATOR_BIT_OR:
                    case OPERATOR_BIT_XOR:
                    case OPERATOR_DECREMENT_POST:
                    case OPERATOR_DECREMENT_PRE:
                    case OPERATOR_DIVIDE:
                    case OPERATOR_DOT:
                    case OPERATOR_EQUAL_TO:
                    case OPERATOR_EXPR_IF:
                    case OPERATOR_GREATER_THAN:
                    case OPERATOR_GREATER_THAN_OR_EQUAL_TO:
                    case OPERATOR_INCREMENT_POST:
                    case OPERATOR_INCREMENT_PRE:
                    case OPERATOR_IS:
                    case OPERATOR_LESS_THAN:
                    case OPERATOR_LESS_THAN_OR_EQUAL_TO:
                    case OPERATOR_LSHIFT:
                    case OPERATOR_MINUS:
                    case OPERATOR_MINUS_UN:
                    case OPERATOR_MODULO:
                    case OPERATOR_NOT:
                    case OPERATOR_NOT_EQUAL_TO:
                    case OPERATOR_PLUS:
                    case OPERATOR_PLUS_UN:
                    case OPERATOR_RELATIVE:
                    case OPERATOR_REL_AND:
                    case OPERATOR_REL_OR:
                    case OPERATOR_RSHIFT:
                    case OPERATOR_TIMES:
                    case STRING:
                    case TRUE_LIT:
                    	{
                    		alt30=1;
                    	}
                        break;

                    }

                    switch (alt30)
                    {
                	case 1:
                	    // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:608:15: expression
                	    {
                	        FOLLOWPUSH(FOLLOW_expression_in_coordinateExpression1791);
                	        expression65=expression(ctx);

                	        FOLLOWPOP();
                	        if  (HASEXCEPTION())
                	        {
                	            goto rulecoordinateExpressionEx;
                	        }


                	        {
                	             argumentCodeBlocks.push_back(expression65
                	            ); 
                	        }


                	    }
                	    break;

                	default:
                	    goto loop30;	/* break out of the loop */
                	    break;
                    }
                }
                loop30: ; /* Jump out to here if this rule does not match */


                MATCHT(ANTLR3_TOKEN_UP, NULL);
                if  (HASEXCEPTION())
                {
                    goto rulecoordinateExpressionEx;
                }

            }


            {

                	CodeLocation location((COORDINATE66->getLine(COORDINATE66)), (COORDINATE66->getCharPositionInLine(COORDINATE66)));
                		// The arguments are stored on the stack in reverse order.
                	for(int i = argumentCodeBlocks.size() - 1; i >= 0; i--)
                	{
                		
                returnCodeBlock
                ->MoveInstructionsFrom(*argumentCodeBlocks[i]); delete argumentCodeBlocks[i]; 
                	}
                	
                	if(argumentCodeBlocks.size() < 1 || argumentCodeBlocks.size() > 2)
                	{
                		throw InternalErrorException("Incorrect number of arguments in coordinate literal.");
                	}
                	
                	if(argumentCodeBlocks.size() == 1){
                		returnCodeBlock
                ->AddInstruction(new instructions::LoadScopeValueInstruction(location, "Coordinate"));	
                	}
                	else if(argumentCodeBlocks.size() == 2){
                		returnCodeBlock
                ->AddInstruction(new instructions::LoadScopeValueInstruction(location, "Point"));	
                	}
                	
                	returnCodeBlock
                ->AddInstruction(new instructions::CallMemberInstruction(location, "Create", argumentCodeBlocks.size()));	

            }


        }

    }

    // This is where rules clean up and exit
    //
    goto rulecoordinateExpressionEx; /* Prevent compiler warnings */
    rulecoordinateExpressionEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return returnCodeBlock;
}
/* $ANTLR end coordinateExpression */

/**
 * $ANTLR start callExpression
 * D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:632:1: callExpression returns [CodeBlock* returnCodeBlock] : ( ^( '(' IDENTIFIER ( expression )* ) | ^( '(' ^( '.' e1= expression IDENTIFIER ) (e2= expression )* ) );
 */
static CodeBlock*
callExpression(pGeoGenScriptDecls ctx)
{
    CodeBlock* returnCodeBlock;


    pANTLR3_BASE_TREE    IDENTIFIER68;
    pANTLR3_BASE_TREE    IDENTIFIER69;
    CodeBlock* e1;
    #undef	RETURN_TYPE_e1
    #define	RETURN_TYPE_e1 CodeBlock*

    CodeBlock* e2;
    #undef	RETURN_TYPE_e2
    #define	RETURN_TYPE_e2 CodeBlock*

    CodeBlock* expression67;
    #undef	RETURN_TYPE_expression67
    #define	RETURN_TYPE_expression67 CodeBlock*

    /* Initialize rule variables
     */

     returnCodeBlock= new CodeBlock();
     std::vector<CodeBlock*> argumentCodeBlocks; 
    IDENTIFIER68       = NULL;
    IDENTIFIER69       = NULL;

    {
        {
            //  D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:634:3: ( ^( '(' IDENTIFIER ( expression )* ) | ^( '(' ^( '.' e1= expression IDENTIFIER ) (e2= expression )* ) )

            ANTLR3_UINT32 alt33;

            alt33=2;

            switch ( LA(1) )
            {
            case LEFT_BRACKET:
            	{
            		switch ( LA(2) )
            		{
            		case DOWN:
            			{
            				switch ( LA(3) )
            				{
            				case IDENTIFIER:
            					{
            						alt33=1;
            					}
            				    break;
            				case OPERATOR_DOT:
            					{
            						alt33=2;
            					}
            				    break;

            				default:
            				    CONSTRUCTEX();
            				    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            				    EXCEPTION->message      = (void *)"";
            				    EXCEPTION->decisionNum  = 33;
            				    EXCEPTION->state        = 2;


            				    goto rulecallExpressionEx;

            				}

            			}
            		    break;

            		default:
            		    CONSTRUCTEX();
            		    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            		    EXCEPTION->message      = (void *)"";
            		    EXCEPTION->decisionNum  = 33;
            		    EXCEPTION->state        = 1;


            		    goto rulecallExpressionEx;

            		}

            	}
                break;

            default:
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 33;
                EXCEPTION->state        = 0;


                goto rulecallExpressionEx;

            }

            switch (alt33)
            {
        	case 1:
        	    // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:635:3: ^( '(' IDENTIFIER ( expression )* )
        	    {
        	         MATCHT(LEFT_BRACKET, &FOLLOW_LEFT_BRACKET_in_callExpression1819);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulecallExpressionEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_DOWN, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulecallExpressionEx;
        	        }

        	        IDENTIFIER68 = (pANTLR3_BASE_TREE) MATCHT(IDENTIFIER, &FOLLOW_IDENTIFIER_in_callExpression1821);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulecallExpressionEx;
        	        }


        	        // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:635:18: ( expression )*

        	        for (;;)
        	        {
        	            int alt31=2;
        	            switch ( LA(1) )
        	            {
        	            case COORDINATE:
        	            case FALSE_LIT:
        	            case IDENTIFIER:
        	            case LEFT_BRACKET:
        	            case LEFT_SQUARE_BRACKET:
        	            case NUMBER:
        	            case OPERATOR_ASSIGN:
        	            case OPERATOR_ASSIGN_AND:
        	            case OPERATOR_ASSIGN_DIVIDE:
        	            case OPERATOR_ASSIGN_LSHIFT:
        	            case OPERATOR_ASSIGN_MINUS:
        	            case OPERATOR_ASSIGN_MODULO:
        	            case OPERATOR_ASSIGN_OR:
        	            case OPERATOR_ASSIGN_PLUS:
        	            case OPERATOR_ASSIGN_RSHIFT:
        	            case OPERATOR_ASSIGN_TIMES:
        	            case OPERATOR_BIT_AND:
        	            case OPERATOR_BIT_OR:
        	            case OPERATOR_BIT_XOR:
        	            case OPERATOR_DECREMENT_POST:
        	            case OPERATOR_DECREMENT_PRE:
        	            case OPERATOR_DIVIDE:
        	            case OPERATOR_DOT:
        	            case OPERATOR_EQUAL_TO:
        	            case OPERATOR_EXPR_IF:
        	            case OPERATOR_GREATER_THAN:
        	            case OPERATOR_GREATER_THAN_OR_EQUAL_TO:
        	            case OPERATOR_INCREMENT_POST:
        	            case OPERATOR_INCREMENT_PRE:
        	            case OPERATOR_IS:
        	            case OPERATOR_LESS_THAN:
        	            case OPERATOR_LESS_THAN_OR_EQUAL_TO:
        	            case OPERATOR_LSHIFT:
        	            case OPERATOR_MINUS:
        	            case OPERATOR_MINUS_UN:
        	            case OPERATOR_MODULO:
        	            case OPERATOR_NOT:
        	            case OPERATOR_NOT_EQUAL_TO:
        	            case OPERATOR_PLUS:
        	            case OPERATOR_PLUS_UN:
        	            case OPERATOR_RELATIVE:
        	            case OPERATOR_REL_AND:
        	            case OPERATOR_REL_OR:
        	            case OPERATOR_RSHIFT:
        	            case OPERATOR_TIMES:
        	            case STRING:
        	            case TRUE_LIT:
        	            	{
        	            		alt31=1;
        	            	}
        	                break;

        	            }

        	            switch (alt31)
        	            {
        	        	case 1:
        	        	    // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:635:19: expression
        	        	    {
        	        	        FOLLOWPUSH(FOLLOW_expression_in_callExpression1824);
        	        	        expression67=expression(ctx);

        	        	        FOLLOWPOP();
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto rulecallExpressionEx;
        	        	        }


        	        	        {
        	        	             argumentCodeBlocks.push_back(expression67
        	        	            ); 
        	        	        }


        	        	    }
        	        	    break;

        	        	default:
        	        	    goto loop31;	/* break out of the loop */
        	        	    break;
        	            }
        	        }
        	        loop31: ; /* Jump out to here if this rule does not match */


        	        MATCHT(ANTLR3_TOKEN_UP, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulecallExpressionEx;
        	        }



        	        {

        	            	CodeLocation location((IDENTIFIER68->getLine(IDENTIFIER68)), (IDENTIFIER68->getCharPositionInLine(IDENTIFIER68)));

        	            	// The arguments are stored on the stack in reverse order.
        	            	for(int i = argumentCodeBlocks.size() - 1; i >= 0; i--)
        	            	{
        	            		
        	            returnCodeBlock
        	            ->MoveInstructionsFrom(*argumentCodeBlocks[i]); delete argumentCodeBlocks[i]; 
        	            	}

        	            	returnCodeBlock
        	            ->AddInstruction(new instructions::CallGlobalInstruction(location, (char*)(IDENTIFIER68->getText(IDENTIFIER68))->chars, argumentCodeBlocks.size()));

        	        }


        	    }
        	    break;
        	case 2:
        	    // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:648:3: ^( '(' ^( '.' e1= expression IDENTIFIER ) (e2= expression )* )
        	    {
        	         MATCHT(LEFT_BRACKET, &FOLLOW_LEFT_BRACKET_in_callExpression1839);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulecallExpressionEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_DOWN, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulecallExpressionEx;
        	        }

        	         MATCHT(OPERATOR_DOT, &FOLLOW_OPERATOR_DOT_in_callExpression1842);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulecallExpressionEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_DOWN, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulecallExpressionEx;
        	        }

        	        FOLLOWPUSH(FOLLOW_expression_in_callExpression1846);
        	        e1=expression(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulecallExpressionEx;
        	        }


        	        IDENTIFIER69 = (pANTLR3_BASE_TREE) MATCHT(IDENTIFIER, &FOLLOW_IDENTIFIER_in_callExpression1848);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulecallExpressionEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_UP, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulecallExpressionEx;
        	        }



        	        // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:648:39: (e2= expression )*

        	        for (;;)
        	        {
        	            int alt32=2;
        	            switch ( LA(1) )
        	            {
        	            case COORDINATE:
        	            case FALSE_LIT:
        	            case IDENTIFIER:
        	            case LEFT_BRACKET:
        	            case LEFT_SQUARE_BRACKET:
        	            case NUMBER:
        	            case OPERATOR_ASSIGN:
        	            case OPERATOR_ASSIGN_AND:
        	            case OPERATOR_ASSIGN_DIVIDE:
        	            case OPERATOR_ASSIGN_LSHIFT:
        	            case OPERATOR_ASSIGN_MINUS:
        	            case OPERATOR_ASSIGN_MODULO:
        	            case OPERATOR_ASSIGN_OR:
        	            case OPERATOR_ASSIGN_PLUS:
        	            case OPERATOR_ASSIGN_RSHIFT:
        	            case OPERATOR_ASSIGN_TIMES:
        	            case OPERATOR_BIT_AND:
        	            case OPERATOR_BIT_OR:
        	            case OPERATOR_BIT_XOR:
        	            case OPERATOR_DECREMENT_POST:
        	            case OPERATOR_DECREMENT_PRE:
        	            case OPERATOR_DIVIDE:
        	            case OPERATOR_DOT:
        	            case OPERATOR_EQUAL_TO:
        	            case OPERATOR_EXPR_IF:
        	            case OPERATOR_GREATER_THAN:
        	            case OPERATOR_GREATER_THAN_OR_EQUAL_TO:
        	            case OPERATOR_INCREMENT_POST:
        	            case OPERATOR_INCREMENT_PRE:
        	            case OPERATOR_IS:
        	            case OPERATOR_LESS_THAN:
        	            case OPERATOR_LESS_THAN_OR_EQUAL_TO:
        	            case OPERATOR_LSHIFT:
        	            case OPERATOR_MINUS:
        	            case OPERATOR_MINUS_UN:
        	            case OPERATOR_MODULO:
        	            case OPERATOR_NOT:
        	            case OPERATOR_NOT_EQUAL_TO:
        	            case OPERATOR_PLUS:
        	            case OPERATOR_PLUS_UN:
        	            case OPERATOR_RELATIVE:
        	            case OPERATOR_REL_AND:
        	            case OPERATOR_REL_OR:
        	            case OPERATOR_RSHIFT:
        	            case OPERATOR_TIMES:
        	            case STRING:
        	            case TRUE_LIT:
        	            	{
        	            		alt32=1;
        	            	}
        	                break;

        	            }

        	            switch (alt32)
        	            {
        	        	case 1:
        	        	    // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:648:40: e2= expression
        	        	    {
        	        	        FOLLOWPUSH(FOLLOW_expression_in_callExpression1854);
        	        	        e2=expression(ctx);

        	        	        FOLLOWPOP();
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto rulecallExpressionEx;
        	        	        }


        	        	        {
        	        	             argumentCodeBlocks.push_back(e2
        	        	            ); 
        	        	        }


        	        	    }
        	        	    break;

        	        	default:
        	        	    goto loop32;	/* break out of the loop */
        	        	    break;
        	            }
        	        }
        	        loop32: ; /* Jump out to here if this rule does not match */


        	        MATCHT(ANTLR3_TOKEN_UP, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulecallExpressionEx;
        	        }



        	        {

        	            	CodeLocation location((IDENTIFIER69->getLine(IDENTIFIER69)), (IDENTIFIER69->getCharPositionInLine(IDENTIFIER69)));

        	            	// The arguments are stored on the stack in reverse order.
        	            	for(int i = argumentCodeBlocks.size() - 1; i >= 0; i--)
        	            	{
        	            		
        	            returnCodeBlock
        	            ->MoveInstructionsFrom(*argumentCodeBlocks[i]); delete argumentCodeBlocks[i]; 
        	            	}

        	            	returnCodeBlock
        	            ->MoveInstructionsFrom(*e1
        	            ); delete e1
        	            ; 
        	            	
        	            	returnCodeBlock
        	            ->AddInstruction(new instructions::CallMemberInstruction(location, (char*)(IDENTIFIER69->getText(IDENTIFIER69))->chars, argumentCodeBlocks.size()));

        	        }


        	    }
        	    break;

            }
        }
    }

    // This is where rules clean up and exit
    //
    goto rulecallExpressionEx; /* Prevent compiler warnings */
    rulecallExpressionEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return returnCodeBlock;
}
/* $ANTLR end callExpression */

/**
 * $ANTLR start indexAccessExpression
 * D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:664:1: indexAccessExpression returns [CodeBlock* returnCodeBlock] : ^( LEFT_SQUARE_BRACKET e1= expression (e2= expression )* ) ;
 */
static CodeBlock*
indexAccessExpression(pGeoGenScriptDecls ctx)
{
    CodeBlock* returnCodeBlock;


    pANTLR3_BASE_TREE    LEFT_SQUARE_BRACKET70;
    CodeBlock* e1;
    #undef	RETURN_TYPE_e1
    #define	RETURN_TYPE_e1 CodeBlock*

    CodeBlock* e2;
    #undef	RETURN_TYPE_e2
    #define	RETURN_TYPE_e2 CodeBlock*

    /* Initialize rule variables
     */

     returnCodeBlock= new CodeBlock();
     std::vector<CodeBlock*> argumentCodeBlocks; 
    LEFT_SQUARE_BRACKET70       = NULL;

    {
        // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:666:3: ( ^( LEFT_SQUARE_BRACKET e1= expression (e2= expression )* ) )
        // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:667:3: ^( LEFT_SQUARE_BRACKET e1= expression (e2= expression )* )
        {
            LEFT_SQUARE_BRACKET70 = (pANTLR3_BASE_TREE) MATCHT(LEFT_SQUARE_BRACKET, &FOLLOW_LEFT_SQUARE_BRACKET_in_indexAccessExpression1883);
            if  (HASEXCEPTION())
            {
                goto ruleindexAccessExpressionEx;
            }


            MATCHT(ANTLR3_TOKEN_DOWN, NULL);
            if  (HASEXCEPTION())
            {
                goto ruleindexAccessExpressionEx;
            }

            FOLLOWPUSH(FOLLOW_expression_in_indexAccessExpression1887);
            e1=expression(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleindexAccessExpressionEx;
            }


            // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:667:37: (e2= expression )*

            for (;;)
            {
                int alt34=2;
                switch ( LA(1) )
                {
                case COORDINATE:
                case FALSE_LIT:
                case IDENTIFIER:
                case LEFT_BRACKET:
                case LEFT_SQUARE_BRACKET:
                case NUMBER:
                case OPERATOR_ASSIGN:
                case OPERATOR_ASSIGN_AND:
                case OPERATOR_ASSIGN_DIVIDE:
                case OPERATOR_ASSIGN_LSHIFT:
                case OPERATOR_ASSIGN_MINUS:
                case OPERATOR_ASSIGN_MODULO:
                case OPERATOR_ASSIGN_OR:
                case OPERATOR_ASSIGN_PLUS:
                case OPERATOR_ASSIGN_RSHIFT:
                case OPERATOR_ASSIGN_TIMES:
                case OPERATOR_BIT_AND:
                case OPERATOR_BIT_OR:
                case OPERATOR_BIT_XOR:
                case OPERATOR_DECREMENT_POST:
                case OPERATOR_DECREMENT_PRE:
                case OPERATOR_DIVIDE:
                case OPERATOR_DOT:
                case OPERATOR_EQUAL_TO:
                case OPERATOR_EXPR_IF:
                case OPERATOR_GREATER_THAN:
                case OPERATOR_GREATER_THAN_OR_EQUAL_TO:
                case OPERATOR_INCREMENT_POST:
                case OPERATOR_INCREMENT_PRE:
                case OPERATOR_IS:
                case OPERATOR_LESS_THAN:
                case OPERATOR_LESS_THAN_OR_EQUAL_TO:
                case OPERATOR_LSHIFT:
                case OPERATOR_MINUS:
                case OPERATOR_MINUS_UN:
                case OPERATOR_MODULO:
                case OPERATOR_NOT:
                case OPERATOR_NOT_EQUAL_TO:
                case OPERATOR_PLUS:
                case OPERATOR_PLUS_UN:
                case OPERATOR_RELATIVE:
                case OPERATOR_REL_AND:
                case OPERATOR_REL_OR:
                case OPERATOR_RSHIFT:
                case OPERATOR_TIMES:
                case STRING:
                case TRUE_LIT:
                	{
                		alt34=1;
                	}
                    break;

                }

                switch (alt34)
                {
            	case 1:
            	    // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:667:38: e2= expression
            	    {
            	        FOLLOWPUSH(FOLLOW_expression_in_indexAccessExpression1892);
            	        e2=expression(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleindexAccessExpressionEx;
            	        }


            	        {
            	             argumentCodeBlocks.push_back(e2
            	            ); 
            	        }


            	    }
            	    break;

            	default:
            	    goto loop34;	/* break out of the loop */
            	    break;
                }
            }
            loop34: ; /* Jump out to here if this rule does not match */


            MATCHT(ANTLR3_TOKEN_UP, NULL);
            if  (HASEXCEPTION())
            {
                goto ruleindexAccessExpressionEx;
            }



            {

                	CodeLocation location((LEFT_SQUARE_BRACKET70->getLine(LEFT_SQUARE_BRACKET70)), (LEFT_SQUARE_BRACKET70->getCharPositionInLine(LEFT_SQUARE_BRACKET70)));

                	// The arguments are stored on the stack in reverse order.
                	for(int i = argumentCodeBlocks.size() - 1; i >= 0; i--)
                	{
                		
                returnCodeBlock
                ->MoveInstructionsFrom(*argumentCodeBlocks[i]); delete argumentCodeBlocks[i]; 
                	}

                	returnCodeBlock
                ->MoveInstructionsFrom(*e1
                ); delete e1
                ; 
                	
                	returnCodeBlock
                ->AddInstruction(new instructions::CallMemberInstruction(location, "[]", argumentCodeBlocks.size()));

            }


        }

    }

    // This is where rules clean up and exit
    //
    goto ruleindexAccessExpressionEx; /* Prevent compiler warnings */
    ruleindexAccessExpressionEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return returnCodeBlock;
}
/* $ANTLR end indexAccessExpression */

/**
 * $ANTLR start conditionalOperatorExpression
 * D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:682:1: conditionalOperatorExpression returns [CodeBlock* returnCodeBlock] : ^( OPERATOR_EXPR_IF conditionExpression= expression ifExpression= expression elseExpression= expression ) ;
 */
static CodeBlock*
conditionalOperatorExpression(pGeoGenScriptDecls ctx)
{
    CodeBlock* returnCodeBlock;


    pANTLR3_BASE_TREE    OPERATOR_EXPR_IF71;
    CodeBlock* conditionExpression;
    #undef	RETURN_TYPE_conditionExpression
    #define	RETURN_TYPE_conditionExpression CodeBlock*

    CodeBlock* ifExpression;
    #undef	RETURN_TYPE_ifExpression
    #define	RETURN_TYPE_ifExpression CodeBlock*

    CodeBlock* elseExpression;
    #undef	RETURN_TYPE_elseExpression
    #define	RETURN_TYPE_elseExpression CodeBlock*

    /* Initialize rule variables
     */

     returnCodeBlock= new CodeBlock();
     
    OPERATOR_EXPR_IF71       = NULL;

    {
        // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:684:3: ( ^( OPERATOR_EXPR_IF conditionExpression= expression ifExpression= expression elseExpression= expression ) )
        // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:685:3: ^( OPERATOR_EXPR_IF conditionExpression= expression ifExpression= expression elseExpression= expression )
        {
            OPERATOR_EXPR_IF71 = (pANTLR3_BASE_TREE) MATCHT(OPERATOR_EXPR_IF, &FOLLOW_OPERATOR_EXPR_IF_in_conditionalOperatorExpression1920);
            if  (HASEXCEPTION())
            {
                goto ruleconditionalOperatorExpressionEx;
            }


            MATCHT(ANTLR3_TOKEN_DOWN, NULL);
            if  (HASEXCEPTION())
            {
                goto ruleconditionalOperatorExpressionEx;
            }

            FOLLOWPUSH(FOLLOW_expression_in_conditionalOperatorExpression1924);
            conditionExpression=expression(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleconditionalOperatorExpressionEx;
            }


            FOLLOWPUSH(FOLLOW_expression_in_conditionalOperatorExpression1928);
            ifExpression=expression(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleconditionalOperatorExpressionEx;
            }


            FOLLOWPUSH(FOLLOW_expression_in_conditionalOperatorExpression1932);
            elseExpression=expression(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleconditionalOperatorExpressionEx;
            }


            MATCHT(ANTLR3_TOKEN_UP, NULL);
            if  (HASEXCEPTION())
            {
                goto ruleconditionalOperatorExpressionEx;
            }



            {

                	CodeLocation location((OPERATOR_EXPR_IF71->getLine(OPERATOR_EXPR_IF71)), (OPERATOR_EXPR_IF71->getCharPositionInLine(OPERATOR_EXPR_IF71)));

                	
                returnCodeBlock
                ->MoveInstructionsFrom(*conditionExpression
                );
                	delete conditionExpression
                ;

                	instructions::IfInstruction* ifInstruction = new instructions::IfInstruction(location);
                	
                	ifInstruction->GetIfBranchCodeBlock().MoveInstructionsFrom(*ifExpression
                );
                	delete ifExpression
                ;

                	ifInstruction->GetElseBranchCodeBlock().MoveInstructionsFrom(*elseExpression
                );
                	delete elseExpression
                ;
                	
                	returnCodeBlock
                ->AddInstruction(ifInstruction);

            }


        }

    }

    // This is where rules clean up and exit
    //
    goto ruleconditionalOperatorExpressionEx; /* Prevent compiler warnings */
    ruleconditionalOperatorExpressionEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return returnCodeBlock;
}
/* $ANTLR end conditionalOperatorExpression */

/**
 * $ANTLR start lvalueExpression
 * D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:704:1: lvalueExpression returns [CodeBlock* returnCodeBlock] : ( IDENTIFIER | ^( OPERATOR_DOT e1= expression IDENTIFIER ) | lvalueIndexAccessExpression );
 */
static CodeBlock*
lvalueExpression(pGeoGenScriptDecls ctx)
{
    CodeBlock* returnCodeBlock;


    pANTLR3_BASE_TREE    IDENTIFIER72;
    pANTLR3_BASE_TREE    OPERATOR_DOT73;
    pANTLR3_BASE_TREE    IDENTIFIER74;
    CodeBlock* e1;
    #undef	RETURN_TYPE_e1
    #define	RETURN_TYPE_e1 CodeBlock*

    CodeBlock* lvalueIndexAccessExpression75;
    #undef	RETURN_TYPE_lvalueIndexAccessExpression75
    #define	RETURN_TYPE_lvalueIndexAccessExpression75 CodeBlock*

    /* Initialize rule variables
     */

     returnCodeBlock= new CodeBlock();
     
    IDENTIFIER72       = NULL;
    OPERATOR_DOT73       = NULL;
    IDENTIFIER74       = NULL;

    {
        {
            //  D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:706:2: ( IDENTIFIER | ^( OPERATOR_DOT e1= expression IDENTIFIER ) | lvalueIndexAccessExpression )

            ANTLR3_UINT32 alt35;

            alt35=3;

            switch ( LA(1) )
            {
            case IDENTIFIER:
            	{
            		alt35=1;
            	}
                break;
            case OPERATOR_DOT:
            	{
            		alt35=2;
            	}
                break;
            case LEFT_SQUARE_BRACKET:
            	{
            		alt35=3;
            	}
                break;

            default:
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 35;
                EXCEPTION->state        = 0;


                goto rulelvalueExpressionEx;

            }

            switch (alt35)
            {
        	case 1:
        	    // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:707:2: IDENTIFIER
        	    {
        	        IDENTIFIER72 = (pANTLR3_BASE_TREE) MATCHT(IDENTIFIER, &FOLLOW_IDENTIFIER_in_lvalueExpression1955);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulelvalueExpressionEx;
        	        }


        	        {
        	             
        	            		CodeLocation location((IDENTIFIER72->getLine(IDENTIFIER72)), (IDENTIFIER72->getCharPositionInLine(IDENTIFIER72)));
        	            		
        	            returnCodeBlock
        	            ->AddInstruction(new instructions::StoreScopeValueInstruction(location, (char*)(IDENTIFIER72->getText(IDENTIFIER72))->chars));  
        	            	
        	        }


        	    }
        	    break;
        	case 2:
        	    // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:712:4: ^( OPERATOR_DOT e1= expression IDENTIFIER )
        	    {
        	        OPERATOR_DOT73 = (pANTLR3_BASE_TREE) MATCHT(OPERATOR_DOT, &FOLLOW_OPERATOR_DOT_in_lvalueExpression1965);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulelvalueExpressionEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_DOWN, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulelvalueExpressionEx;
        	        }

        	        FOLLOWPUSH(FOLLOW_expression_in_lvalueExpression1969);
        	        e1=expression(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulelvalueExpressionEx;
        	        }


        	        IDENTIFIER74 = (pANTLR3_BASE_TREE) MATCHT(IDENTIFIER, &FOLLOW_IDENTIFIER_in_lvalueExpression1971);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulelvalueExpressionEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_UP, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulelvalueExpressionEx;
        	        }



        	        {

        	            		CodeLocation location((OPERATOR_DOT73->getLine(OPERATOR_DOT73)), (OPERATOR_DOT73->getCharPositionInLine(OPERATOR_DOT73)));
        	            	
        	            		
        	            returnCodeBlock
        	            ->MoveInstructionsFrom(*e1
        	            ); 
        	            		delete e1
        	            ; 
        	            		
        	            		returnCodeBlock
        	            ->AddInstruction(new instructions::StoreMemberValueInstruction(location, (char*)(IDENTIFIER74->getText(IDENTIFIER74))->chars));
        	            	
        	        }


        	    }
        	    break;
        	case 3:
        	    // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:721:4: lvalueIndexAccessExpression
        	    {
        	        FOLLOWPUSH(FOLLOW_lvalueIndexAccessExpression_in_lvalueExpression1981);
        	        lvalueIndexAccessExpression75=lvalueIndexAccessExpression(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulelvalueExpressionEx;
        	        }


        	        {
        	             
        	            		returnCodeBlock
        	            ->MoveInstructionsFrom(*lvalueIndexAccessExpression75
        	            ); 
        	            		delete lvalueIndexAccessExpression75
        	            ; 
        	            	
        	        }


        	    }
        	    break;

            }
        }
    }

    // This is where rules clean up and exit
    //
    goto rulelvalueExpressionEx; /* Prevent compiler warnings */
    rulelvalueExpressionEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return returnCodeBlock;
}
/* $ANTLR end lvalueExpression */

/**
 * $ANTLR start lvalueIndexAccessExpression
 * D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:727:1: lvalueIndexAccessExpression returns [CodeBlock* returnCodeBlock] : ^( LEFT_SQUARE_BRACKET e1= expression (e2= expression )* ) ;
 */
static CodeBlock*
lvalueIndexAccessExpression(pGeoGenScriptDecls ctx)
{
    CodeBlock* returnCodeBlock;


    pANTLR3_BASE_TREE    LEFT_SQUARE_BRACKET76;
    CodeBlock* e1;
    #undef	RETURN_TYPE_e1
    #define	RETURN_TYPE_e1 CodeBlock*

    CodeBlock* e2;
    #undef	RETURN_TYPE_e2
    #define	RETURN_TYPE_e2 CodeBlock*

    /* Initialize rule variables
     */

     returnCodeBlock= new CodeBlock();
     std::vector<CodeBlock*> argumentCodeBlocks; 
    LEFT_SQUARE_BRACKET76       = NULL;

    {
        // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:729:3: ( ^( LEFT_SQUARE_BRACKET e1= expression (e2= expression )* ) )
        // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:730:3: ^( LEFT_SQUARE_BRACKET e1= expression (e2= expression )* )
        {
            LEFT_SQUARE_BRACKET76 = (pANTLR3_BASE_TREE) MATCHT(LEFT_SQUARE_BRACKET, &FOLLOW_LEFT_SQUARE_BRACKET_in_lvalueIndexAccessExpression2007);
            if  (HASEXCEPTION())
            {
                goto rulelvalueIndexAccessExpressionEx;
            }


            MATCHT(ANTLR3_TOKEN_DOWN, NULL);
            if  (HASEXCEPTION())
            {
                goto rulelvalueIndexAccessExpressionEx;
            }

            FOLLOWPUSH(FOLLOW_expression_in_lvalueIndexAccessExpression2011);
            e1=expression(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulelvalueIndexAccessExpressionEx;
            }


            // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:730:37: (e2= expression )*

            for (;;)
            {
                int alt36=2;
                switch ( LA(1) )
                {
                case COORDINATE:
                case FALSE_LIT:
                case IDENTIFIER:
                case LEFT_BRACKET:
                case LEFT_SQUARE_BRACKET:
                case NUMBER:
                case OPERATOR_ASSIGN:
                case OPERATOR_ASSIGN_AND:
                case OPERATOR_ASSIGN_DIVIDE:
                case OPERATOR_ASSIGN_LSHIFT:
                case OPERATOR_ASSIGN_MINUS:
                case OPERATOR_ASSIGN_MODULO:
                case OPERATOR_ASSIGN_OR:
                case OPERATOR_ASSIGN_PLUS:
                case OPERATOR_ASSIGN_RSHIFT:
                case OPERATOR_ASSIGN_TIMES:
                case OPERATOR_BIT_AND:
                case OPERATOR_BIT_OR:
                case OPERATOR_BIT_XOR:
                case OPERATOR_DECREMENT_POST:
                case OPERATOR_DECREMENT_PRE:
                case OPERATOR_DIVIDE:
                case OPERATOR_DOT:
                case OPERATOR_EQUAL_TO:
                case OPERATOR_EXPR_IF:
                case OPERATOR_GREATER_THAN:
                case OPERATOR_GREATER_THAN_OR_EQUAL_TO:
                case OPERATOR_INCREMENT_POST:
                case OPERATOR_INCREMENT_PRE:
                case OPERATOR_IS:
                case OPERATOR_LESS_THAN:
                case OPERATOR_LESS_THAN_OR_EQUAL_TO:
                case OPERATOR_LSHIFT:
                case OPERATOR_MINUS:
                case OPERATOR_MINUS_UN:
                case OPERATOR_MODULO:
                case OPERATOR_NOT:
                case OPERATOR_NOT_EQUAL_TO:
                case OPERATOR_PLUS:
                case OPERATOR_PLUS_UN:
                case OPERATOR_RELATIVE:
                case OPERATOR_REL_AND:
                case OPERATOR_REL_OR:
                case OPERATOR_RSHIFT:
                case OPERATOR_TIMES:
                case STRING:
                case TRUE_LIT:
                	{
                		alt36=1;
                	}
                    break;

                }

                switch (alt36)
                {
            	case 1:
            	    // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:730:38: e2= expression
            	    {
            	        FOLLOWPUSH(FOLLOW_expression_in_lvalueIndexAccessExpression2016);
            	        e2=expression(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulelvalueIndexAccessExpressionEx;
            	        }


            	        {
            	             argumentCodeBlocks.push_back(e2
            	            ); 
            	        }


            	    }
            	    break;

            	default:
            	    goto loop36;	/* break out of the loop */
            	    break;
                }
            }
            loop36: ; /* Jump out to here if this rule does not match */


            MATCHT(ANTLR3_TOKEN_UP, NULL);
            if  (HASEXCEPTION())
            {
                goto rulelvalueIndexAccessExpressionEx;
            }



            {

                	CodeLocation location((LEFT_SQUARE_BRACKET76->getLine(LEFT_SQUARE_BRACKET76)), (LEFT_SQUARE_BRACKET76->getCharPositionInLine(LEFT_SQUARE_BRACKET76)));

                	// The arguments are stored on the stack in reverse order.
                	for(int i = argumentCodeBlocks.size() - 1; i >= 0; i--)
                	{
                		
                returnCodeBlock
                ->MoveInstructionsFrom(*argumentCodeBlocks[i]); delete argumentCodeBlocks[i]; 
                	}

                	returnCodeBlock
                ->MoveInstructionsFrom(*e1
                ); delete e1
                ; 
                	
                	// +1 for the value being written into the array
                	returnCodeBlock
                ->AddInstruction(new instructions::CallMemberInstruction(location, "[]=", argumentCodeBlocks.size() + 1));

            }


        }

    }

    // This is where rules clean up and exit
    //
    goto rulelvalueIndexAccessExpressionEx; /* Prevent compiler warnings */
    rulelvalueIndexAccessExpressionEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return returnCodeBlock;
}
/* $ANTLR end lvalueIndexAccessExpression */

/**
 * $ANTLR start unkeyedCollectionLiteral
 * D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:815:1: unkeyedCollectionLiteral : '{' ( expression ( ',' expression )* ) '}' ;
 */
static void
unkeyedCollectionLiteral(pGeoGenScriptDecls ctx)
{
    /* Initialize rule variables
     */

    {
        // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:815:25: ( '{' ( expression ( ',' expression )* ) '}' )
        // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:816:5: '{' ( expression ( ',' expression )* ) '}'
        {
             MATCHT(LEFT_CURLY_BRACKET, &FOLLOW_LEFT_CURLY_BRACKET_in_unkeyedCollectionLiteral2077);
            if  (HASEXCEPTION())
            {
                goto ruleunkeyedCollectionLiteralEx;
            }


            // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:816:9: ( expression ( ',' expression )* )
            // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:816:10: expression ( ',' expression )*
            {
                FOLLOWPUSH(FOLLOW_expression_in_unkeyedCollectionLiteral2080);
                expression(ctx);

                FOLLOWPOP();
                if  (HASEXCEPTION())
                {
                    goto ruleunkeyedCollectionLiteralEx;
                }


                // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:816:21: ( ',' expression )*

                for (;;)
                {
                    int alt37=2;
                    switch ( LA(1) )
                    {
                    case COMMA:
                    	{
                    		alt37=1;
                    	}
                        break;

                    }

                    switch (alt37)
                    {
                	case 1:
                	    // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:816:22: ',' expression
                	    {
                	         MATCHT(COMMA, &FOLLOW_COMMA_in_unkeyedCollectionLiteral2083);
                	        if  (HASEXCEPTION())
                	        {
                	            goto ruleunkeyedCollectionLiteralEx;
                	        }


                	        FOLLOWPUSH(FOLLOW_expression_in_unkeyedCollectionLiteral2085);
                	        expression(ctx);

                	        FOLLOWPOP();
                	        if  (HASEXCEPTION())
                	        {
                	            goto ruleunkeyedCollectionLiteralEx;
                	        }


                	    }
                	    break;

                	default:
                	    goto loop37;	/* break out of the loop */
                	    break;
                    }
                }
                loop37: ; /* Jump out to here if this rule does not match */


            }


             MATCHT(RIGTH_CURLY_BRACKET, &FOLLOW_RIGTH_CURLY_BRACKET_in_unkeyedCollectionLiteral2090);
            if  (HASEXCEPTION())
            {
                goto ruleunkeyedCollectionLiteralEx;
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto ruleunkeyedCollectionLiteralEx; /* Prevent compiler warnings */
    ruleunkeyedCollectionLiteralEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end unkeyedCollectionLiteral */

/**
 * $ANTLR start label
 * D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:818:1: label : ( ^( IDENTCHAIN ( IDENTIFIER )+ ) | 'true' | 'false' | NUMBER | STRING );
 */
static void
label(pGeoGenScriptDecls ctx)
{
    /* Initialize rule variables
     */

    {
        {
            //  D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:818:6: ( ^( IDENTCHAIN ( IDENTIFIER )+ ) | 'true' | 'false' | NUMBER | STRING )

            ANTLR3_UINT32 alt39;

            alt39=5;

            switch ( LA(1) )
            {
            case IDENTCHAIN:
            	{
            		alt39=1;
            	}
                break;
            case TRUE_LIT:
            	{
            		alt39=2;
            	}
                break;
            case FALSE_LIT:
            	{
            		alt39=3;
            	}
                break;
            case NUMBER:
            	{
            		alt39=4;
            	}
                break;
            case STRING:
            	{
            		alt39=5;
            	}
                break;

            default:
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 39;
                EXCEPTION->state        = 0;


                goto rulelabelEx;

            }

            switch (alt39)
            {
        	case 1:
        	    // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:819:2: ^( IDENTCHAIN ( IDENTIFIER )+ )
        	    {
        	         MATCHT(IDENTCHAIN, &FOLLOW_IDENTCHAIN_in_label2107);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulelabelEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_DOWN, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulelabelEx;
        	        }

        	        // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:819:15: ( IDENTIFIER )+
        	        {
        	            int cnt38=0;

        	            for (;;)
        	            {
        	                int alt38=2;
        	        	switch ( LA(1) )
        	        	{
        	        	case IDENTIFIER:
        	        		{
        	        			alt38=1;
        	        		}
        	        	    break;

        	        	}

        	        	switch (alt38)
        	        	{
        	        	    case 1:
        	        	        // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:819:15: IDENTIFIER
        	        	        {
        	        	             MATCHT(IDENTIFIER, &FOLLOW_IDENTIFIER_in_label2109);
        	        	            if  (HASEXCEPTION())
        	        	            {
        	        	                goto rulelabelEx;
        	        	            }


        	        	        }
        	        	        break;

        	        	    default:

        	        		if ( cnt38 >= 1 )
        	        		{
        	        		    goto loop38;
        	        		}
        	        		/* mismatchedSetEx()
        	        		 */
        	        		CONSTRUCTEX();
        	        		EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;
        	        		EXCEPTION->name = (void *)ANTLR3_EARLY_EXIT_NAME;


        	        		goto rulelabelEx;
        	        	}
        	        	cnt38++;
        	            }
        	            loop38: ;	/* Jump to here if this rule does not match */
        	        }

        	        MATCHT(ANTLR3_TOKEN_UP, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulelabelEx;
        	        }



        	    }
        	    break;
        	case 2:
        	    // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:820:4: 'true'
        	    {
        	         MATCHT(TRUE_LIT, &FOLLOW_TRUE_LIT_in_label2116);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulelabelEx;
        	        }


        	    }
        	    break;
        	case 3:
        	    // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:821:11: 'false'
        	    {
        	         MATCHT(FALSE_LIT, &FOLLOW_FALSE_LIT_in_label2128);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulelabelEx;
        	        }


        	    }
        	    break;
        	case 4:
        	    // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:822:4: NUMBER
        	    {
        	         MATCHT(NUMBER, &FOLLOW_NUMBER_in_label2133);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulelabelEx;
        	        }


        	    }
        	    break;
        	case 5:
        	    // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:823:4: STRING
        	    {
        	         MATCHT(STRING, &FOLLOW_STRING_in_label2138);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulelabelEx;
        	        }


        	    }
        	    break;

            }
        }
    }

    // This is where rules clean up and exit
    //
    goto rulelabelEx; /* Prevent compiler warnings */
    rulelabelEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end label */
/* End of parsing rules
 * ==============================================
 */

/* ==============================================
 * Syntactic predicates
 */
/* End of syntactic predicates
 * ==============================================
 */






/* End of code
 * =============================================================================
 */
