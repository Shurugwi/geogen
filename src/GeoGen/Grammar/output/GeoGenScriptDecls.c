/** \file
 *  This C source file was generated by $ANTLR version null
 *
 *     -  From the grammar source file : D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g
 *     -                            On : 2013-11-30 21:33:18
 *     -           for the tree parser : GeoGenScriptDeclsTreeParser
 *
 * Editing it, at least manually, is not wise.
 *
 * C language generator and runtime by Jim Idle, jimi|hereisanat|idle|dotgoeshere|ws.
 *
 *
*/
// [The "BSD license"]
// Copyright (c) 2005-2009 Jim Idle, Temporal Wave LLC
// http://www.temporal-wave.com
// http://www.linkedin.com/in/jimidle
//
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. The name of the author may not be used to endorse or promote products
//    derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

/* -----------------------------------------
 * Include the ANTLR3 generated header file.
 */
#include    "GeoGenScriptDecls.h"
/* ----------------------------------------- */





/* MACROS that hide the C interface implementations from the
 * generated code, which makes it a little more understandable to the human eye.
 * I am very much against using C pre-processor macros for function calls and bits
 * of code as you cannot see what is happening when single stepping in debuggers
 * and so on. The exception (in my book at least) is for generated code, where you are
 * not maintaining it, but may wish to read and understand it. If you single step it, you know that input()
 * hides some indirect calls, but is always referring to the input stream. This is
 * probably more readable than ctx->input->istream->input(snarfle0->blarg) and allows me to rejig
 * the runtime interfaces without changing the generated code too often, without
 * confusing the reader of the generated output, who may not wish to know the gory
 * details of the interface inheritance.
 */

#define		CTX	ctx

/* Aids in accessing scopes for grammar programmers
 */
#undef	SCOPE_TYPE
#undef	SCOPE_STACK
#undef	SCOPE_TOP
#define	SCOPE_TYPE(scope)   pGeoGenScriptDecls_##scope##_SCOPE
#define SCOPE_STACK(scope)  pGeoGenScriptDecls_##scope##Stack
#define	SCOPE_TOP(scope)    ctx->pGeoGenScriptDecls_##scope##Top
#define	SCOPE_SIZE(scope)		ctx->pGeoGenScriptDecls_##scope##Stack_limit
#define SCOPE_INSTANCE(scope, i)	(ctx->SCOPE_STACK(scope)->get(ctx->SCOPE_STACK(scope),i))

/* Macros for accessing things in the parser
 */

#undef	    PARSER
#undef	    RECOGNIZER
#undef	    HAVEPARSEDRULE
#undef	    INPUT
#undef	    STRSTREAM
#undef	    HASEXCEPTION
#undef	    EXCEPTION
#undef	    MATCHT
#undef	    MATCHANYT
#undef	    FOLLOWSTACK
#undef	    FOLLOWPUSH
#undef	    FOLLOWPOP
#undef	    PRECOVER
#undef	    PREPORTERROR
#undef	    LA
#undef	    LT
#undef	    CONSTRUCTEX
#undef	    CONSUME
#undef	    MARK
#undef	    REWIND
#undef	    REWINDLAST
#undef	    PERRORRECOVERY
#undef	    HASFAILED
#undef	    FAILEDFLAG
#undef	    RECOVERFROMMISMATCHEDSET
#undef	    RECOVERFROMMISMATCHEDELEMENT
#undef	    BACKTRACKING
#undef      ADAPTOR
#undef	    RULEMEMO
#undef		SEEK
#undef		INDEX
#undef		DBG

#define	    PARSER							ctx->pTreeParser
#define	    RECOGNIZER						PARSER->rec
#define		PSRSTATE						RECOGNIZER->state
#define	    HAVEPARSEDRULE(r)				RECOGNIZER->alreadyParsedRule(RECOGNIZER, r)
#define	    INPUT							PARSER->ctnstream
#define		ISTREAM							INPUT->tnstream->istream
#define	    STRSTREAM						INPUT->tnstream
#define	    HASEXCEPTION()					(PSRSTATE->error == ANTLR3_TRUE)
#define	    EXCEPTION						PSRSTATE->exception
#define	    MATCHT(t, fs)					RECOGNIZER->match(RECOGNIZER, t, fs)
#define	    MATCHANYT()						RECOGNIZER->matchAny(RECOGNIZER)
#define	    FOLLOWSTACK					    PSRSTATE->following
#define	    FOLLOWPUSH(x)					FOLLOWSTACK->push(FOLLOWSTACK, ((void *)(&(x))), NULL)
#define	    FOLLOWPOP()						FOLLOWSTACK->pop(FOLLOWSTACK)
#define	    PRECOVER()						RECOGNIZER->recover(RECOGNIZER)
#define	    PREPORTERROR()					RECOGNIZER->reportError(RECOGNIZER)
#define	    LA(n)							ISTREAM->_LA(ISTREAM, n)
#define	    LT(n)							INPUT->tnstream->_LT(INPUT->tnstream, n)
#define	    CONSTRUCTEX()					RECOGNIZER->exConstruct(RECOGNIZER)
#define	    CONSUME()						ISTREAM->consume(ISTREAM)
#define	    MARK()							ISTREAM->mark(ISTREAM)
#define	    REWIND(m)						ISTREAM->rewind(ISTREAM, m)
#define	    REWINDLAST()					ISTREAM->rewindLast(ISTREAM)
#define	    PERRORRECOVERY					PSRSTATE->errorRecovery
#define	    FAILEDFLAG						PSRSTATE->failed
#define	    HASFAILED()						(FAILEDFLAG == ANTLR3_TRUE)
#define	    BACKTRACKING					PSRSTATE->backtracking
#define	    RECOVERFROMMISMATCHEDSET(s)		RECOGNIZER->recoverFromMismatchedSet(RECOGNIZER, s)
#define	    RECOVERFROMMISMATCHEDELEMENT(e)	RECOGNIZER->recoverFromMismatchedElement(RECOGNIZER, s)
#define     ADAPTOR                         INPUT->adaptor
#define		RULEMEMO						PSRSTATE->ruleMemo
#define		SEEK(n)							ISTREAM->seek(ISTREAM, n)
#define		INDEX()							ISTREAM->index(ISTREAM)
#define		DBG								RECOGNIZER->debugger



#define		TOKTEXT(tok, txt)				tok, (pANTLR3_UINT8)txt

/* The 4 tokens defined below may well clash with your own #defines or token types. If so
 * then for the present you must use different names for your defines as these are hard coded
 * in the code generator. It would be better not to use such names internally, and maybe
 * we can change this in a forthcoming release. I deliberately do not #undef these
 * here as this will at least give you a redefined error somewhere if they clash.
 */
#define	    UP	    ANTLR3_TOKEN_UP
#define	    DOWN    ANTLR3_TOKEN_DOWN
#define	    EOR	    ANTLR3_TOKEN_EOR
#define	    INVALID ANTLR3_TOKEN_INVALID


/* =============================================================================
 * Functions to create and destroy scopes. First come the rule scopes, followed
 * by the global declared scopes.
 */



/* ============================================================================= */

/* =============================================================================
 * Start of recognizer
 */


/** \brief Table of all token names in symbolic order, mainly used for
 *         error reporting.
 */
pANTLR3_UINT8   GeoGenScriptDeclsTokenNames[83+4]
     = {
        (pANTLR3_UINT8) "<invalid>",       /* String to print to indicate an invalid token */
        (pANTLR3_UINT8) "<EOR>",
        (pANTLR3_UINT8) "<DOWN>",
        (pANTLR3_UINT8) "<UP>",
        (pANTLR3_UINT8) "AS",
        (pANTLR3_UINT8) "AT",
        (pANTLR3_UINT8) "BLOCK",
        (pANTLR3_UINT8) "BREAK",
        (pANTLR3_UINT8) "CASE",
        (pANTLR3_UINT8) "COLLECTION",
        (pANTLR3_UINT8) "COLON",
        (pANTLR3_UINT8) "COMMA",
        (pANTLR3_UINT8) "COMMENT",
        (pANTLR3_UINT8) "CONDITION_EXPRESSION",
        (pANTLR3_UINT8) "CONTINUE",
        (pANTLR3_UINT8) "COORDINATE",
        (pANTLR3_UINT8) "DECLARATIONS",
        (pANTLR3_UINT8) "DEFAULT",
        (pANTLR3_UINT8) "ELSE",
        (pANTLR3_UINT8) "ENUM",
        (pANTLR3_UINT8) "ESC_SEQ",
        (pANTLR3_UINT8) "FALSE_LIT",
        (pANTLR3_UINT8) "FOR",
        (pANTLR3_UINT8) "FUNCTION",
        (pANTLR3_UINT8) "HEX_DIGIT",
        (pANTLR3_UINT8) "IDENTCHAIN",
        (pANTLR3_UINT8) "IDENTIFIER",
        (pANTLR3_UINT8) "IF",
        (pANTLR3_UINT8) "INCREMENT_EXPRESSION",
        (pANTLR3_UINT8) "INITIALIZATION_EXPRESSION",
        (pANTLR3_UINT8) "INTEGER",
        (pANTLR3_UINT8) "LEFT_BRACKET",
        (pANTLR3_UINT8) "LEFT_CURLY_BRACKET",
        (pANTLR3_UINT8) "LEFT_SQUARE_BRACKET",
        (pANTLR3_UINT8) "METADATA",
        (pANTLR3_UINT8) "NUMBER",
        (pANTLR3_UINT8) "OPERATOR_ASSIGN",
        (pANTLR3_UINT8) "OPERATOR_ASSIGN_AND",
        (pANTLR3_UINT8) "OPERATOR_ASSIGN_DIVIDE",
        (pANTLR3_UINT8) "OPERATOR_ASSIGN_LSHIFT",
        (pANTLR3_UINT8) "OPERATOR_ASSIGN_MINUS",
        (pANTLR3_UINT8) "OPERATOR_ASSIGN_MODULO",
        (pANTLR3_UINT8) "OPERATOR_ASSIGN_OR",
        (pANTLR3_UINT8) "OPERATOR_ASSIGN_PLUS",
        (pANTLR3_UINT8) "OPERATOR_ASSIGN_RSHIFT",
        (pANTLR3_UINT8) "OPERATOR_ASSIGN_TIMES",
        (pANTLR3_UINT8) "OPERATOR_ASSIGN_XOR",
        (pANTLR3_UINT8) "OPERATOR_BIT_AND",
        (pANTLR3_UINT8) "OPERATOR_BIT_OR",
        (pANTLR3_UINT8) "OPERATOR_BIT_XOR",
        (pANTLR3_UINT8) "OPERATOR_CALL",
        (pANTLR3_UINT8) "OPERATOR_DECREMENT",
        (pANTLR3_UINT8) "OPERATOR_DIVIDE",
        (pANTLR3_UINT8) "OPERATOR_DOT",
        (pANTLR3_UINT8) "OPERATOR_EQUAL_TO",
        (pANTLR3_UINT8) "OPERATOR_EXPR_IF",
        (pANTLR3_UINT8) "OPERATOR_GREATER_THAN",
        (pANTLR3_UINT8) "OPERATOR_GREATER_THAN_OR_EQUAL_TO",
        (pANTLR3_UINT8) "OPERATOR_INCREMENT",
        (pANTLR3_UINT8) "OPERATOR_IS",
        (pANTLR3_UINT8) "OPERATOR_LESS_THAN",
        (pANTLR3_UINT8) "OPERATOR_LESS_THAN_OR_EQUAL_TO",
        (pANTLR3_UINT8) "OPERATOR_LSHIFT",
        (pANTLR3_UINT8) "OPERATOR_MINUS",
        (pANTLR3_UINT8) "OPERATOR_MODULO",
        (pANTLR3_UINT8) "OPERATOR_NOT",
        (pANTLR3_UINT8) "OPERATOR_NOT_EQUAL_TO",
        (pANTLR3_UINT8) "OPERATOR_PLUS",
        (pANTLR3_UINT8) "OPERATOR_REL_AND",
        (pANTLR3_UINT8) "OPERATOR_REL_OR",
        (pANTLR3_UINT8) "OPERATOR_RSHIFT",
        (pANTLR3_UINT8) "OPERATOR_SUBSCRIPT",
        (pANTLR3_UINT8) "OPERATOR_TIMES",
        (pANTLR3_UINT8) "PARAMETERS",
        (pANTLR3_UINT8) "RETURN",
        (pANTLR3_UINT8) "RIGHT_BRACKET",
        (pANTLR3_UINT8) "RIGHT_SQUARE_BRACKET",
        (pANTLR3_UINT8) "RIGTH_CURLY_BRACKET",
        (pANTLR3_UINT8) "SCRIPT",
        (pANTLR3_UINT8) "SEMICOLON",
        (pANTLR3_UINT8) "STRING",
        (pANTLR3_UINT8) "SWITCH",
        (pANTLR3_UINT8) "TRUE_LIT",
        (pANTLR3_UINT8) "VAR",
        (pANTLR3_UINT8) "WHILE",
        (pANTLR3_UINT8) "WHITESPACE",
        (pANTLR3_UINT8) "YIELD"
       };



// Forward declare the locally static matching functions we have generated.
//
static 
 void
	script    (pGeoGenScriptDecls ctx);
static 
 void
	metadata    (pGeoGenScriptDecls ctx);
static 
 void
	keyValueCollection    (pGeoGenScriptDecls ctx);
static 
 void
	keyValuePair    (pGeoGenScriptDecls ctx);
static 
 void
	keyValueValue    (pGeoGenScriptDecls ctx);
static 
 void
	declaration    (pGeoGenScriptDecls ctx);
static 
 void
	enumDeclaration    (pGeoGenScriptDecls ctx);
static 
 void
	enumValues    (pGeoGenScriptDecls ctx);
static 
 void
	enumValue    (pGeoGenScriptDecls ctx);
static 
 void
	functionDeclaration    (pGeoGenScriptDecls ctx);
static 
 void
	formalParameters    (pGeoGenScriptDecls ctx);
static 
 void
	block    (pGeoGenScriptDecls ctx);
static 
 void
	statement    (pGeoGenScriptDecls ctx);
static 
 void
	variableDeclaration    (pGeoGenScriptDecls ctx);
static 
 void
	yieldStatement    (pGeoGenScriptDecls ctx);
static 
 void
	returnStatement    (pGeoGenScriptDecls ctx);
static 
 void
	whileStatement    (pGeoGenScriptDecls ctx);
static 
 void
	forStatement    (pGeoGenScriptDecls ctx);
static 
 void
	initExpression    (pGeoGenScriptDecls ctx);
static 
 void
	ifStatement    (pGeoGenScriptDecls ctx);
static 
 void
	switchStatement    (pGeoGenScriptDecls ctx);
static 
 void
	normalCase    (pGeoGenScriptDecls ctx);
static 
 void
	defaultCase    (pGeoGenScriptDecls ctx);
static 
 void
	expression    (pGeoGenScriptDecls ctx);
static 
 void
	unkeyedCollectionLiteral    (pGeoGenScriptDecls ctx);
static 
 void
	coordinateLiteral    (pGeoGenScriptDecls ctx);
static 
 void
	label    (pGeoGenScriptDecls ctx);
static void	GeoGenScriptDeclsFree(pGeoGenScriptDecls ctx);
static void     GeoGenScriptDeclsReset (pGeoGenScriptDecls ctx);

/* For use in tree output where we are accumulating rule labels via label += ruleRef
 * we need a function that knows how to free a return scope when the list is destroyed.
 * We cannot just use ANTLR3_FREE because in debug tracking mode, this is a macro.
 */
static	void ANTLR3_CDECL freeScope(void * scope)
{
    ANTLR3_FREE(scope);
}

/** \brief Name of the grammar file that generated this code
 */
static const char fileName[] = "D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g";

/** \brief Return the name of the grammar file that generated this code.
 */
static const char * getGrammarFileName()
{
	return fileName;
}
/** \brief Create a new GeoGenScriptDecls parser and return a context for it.
 *
 * \param[in] instream Pointer to an input stream interface.
 *
 * \return Pointer to new parser context upon success.
 */
ANTLR3_API pGeoGenScriptDecls
GeoGenScriptDeclsNew   (pANTLR3_COMMON_TREE_NODE_STREAM instream)
{
	// See if we can create a new parser with the standard constructor
	//
	return GeoGenScriptDeclsNewSSD(instream, NULL);
}

/** \brief Create a new GeoGenScriptDecls parser and return a context for it.
 *
 * \param[in] instream Pointer to an input stream interface.
 *
 * \return Pointer to new parser context upon success.
 */
ANTLR3_API pGeoGenScriptDecls
GeoGenScriptDeclsNewSSD   (pANTLR3_COMMON_TREE_NODE_STREAM instream, pANTLR3_RECOGNIZER_SHARED_STATE state)
{
    pGeoGenScriptDecls ctx;	    /* Context structure we will build and return   */

    ctx	= (pGeoGenScriptDecls) ANTLR3_CALLOC(1, sizeof(GeoGenScriptDecls));

    if	(ctx == NULL)
    {
		// Failed to allocate memory for parser context
		//
        return  NULL;
    }

    /* -------------------------------------------------------------------
     * Memory for basic structure is allocated, now to fill in
     * the base ANTLR3 structures. We initialize the function pointers
     * for the standard ANTLR3 parser function set, but upon return
     * from here, the programmer may set the pointers to provide custom
     * implementations of each function.
     *
     * We don't use the macros defined in GeoGenScriptDecls.h here, in order that you can get a sense
     * of what goes where.
     */

    /* Create a base Tree parser/recognizer, using the supplied tree node stream
     */
    ctx->pTreeParser		= antlr3TreeParserNewStream(ANTLR3_SIZE_HINT, instream, state);

    /* Install the implementation of our GeoGenScriptDecls interface
     */
    ctx->script	= script;
    ctx->metadata	= metadata;
    ctx->keyValueCollection	= keyValueCollection;
    ctx->keyValuePair	= keyValuePair;
    ctx->keyValueValue	= keyValueValue;
    ctx->declaration	= declaration;
    ctx->enumDeclaration	= enumDeclaration;
    ctx->enumValues	= enumValues;
    ctx->enumValue	= enumValue;
    ctx->functionDeclaration	= functionDeclaration;
    ctx->formalParameters	= formalParameters;
    ctx->block	= block;
    ctx->statement	= statement;
    ctx->variableDeclaration	= variableDeclaration;
    ctx->yieldStatement	= yieldStatement;
    ctx->returnStatement	= returnStatement;
    ctx->whileStatement	= whileStatement;
    ctx->forStatement	= forStatement;
    ctx->initExpression	= initExpression;
    ctx->ifStatement	= ifStatement;
    ctx->switchStatement	= switchStatement;
    ctx->normalCase	= normalCase;
    ctx->defaultCase	= defaultCase;
    ctx->expression	= expression;
    ctx->unkeyedCollectionLiteral	= unkeyedCollectionLiteral;
    ctx->coordinateLiteral	= coordinateLiteral;
    ctx->label	= label;
    ctx->free			= GeoGenScriptDeclsFree;
    ctx->reset			= GeoGenScriptDeclsReset;
    ctx->getGrammarFileName	= getGrammarFileName;

    /* Install the scope pushing methods.
     */

    /* Install the token table
     */
    PSRSTATE->tokenNames   = GeoGenScriptDeclsTokenNames;


    /* Return the newly built parser to the caller
     */
    return  ctx;
}

static void
GeoGenScriptDeclsReset (pGeoGenScriptDecls ctx)
{
    RECOGNIZER->reset(RECOGNIZER);
}

/** Free the parser resources
 */
 static void
 GeoGenScriptDeclsFree(pGeoGenScriptDecls ctx)
 {
    /* Free any scope memory
     */

	// Free this parser
	//
    ctx->pTreeParser->free(ctx->pTreeParser);

    ANTLR3_FREE(ctx);

    /* Everything is released, so we can return
     */
    return;
 }

/** Return token names used by this 
tree parser

 *
 * The returned pointer is used as an index into the token names table (using the token
 * number as the index).
 *
 * \return Pointer to first char * in the table.
 */
static pANTLR3_UINT8    *getTokenNames()
{
        return GeoGenScriptDeclsTokenNames;
}


/* Declare the bitsets
 */
/** Bitset defining follow set for error recovery in rule state: FOLLOW_SCRIPT_in_script72  */
static	ANTLR3_BITWORD FOLLOW_SCRIPT_in_script72_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_SCRIPT_in_script72	= { FOLLOW_SCRIPT_in_script72_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_metadata_in_script74  */
static	ANTLR3_BITWORD FOLLOW_metadata_in_script74_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000010000) };
static  ANTLR3_BITSET_LIST FOLLOW_metadata_in_script74	= { FOLLOW_metadata_in_script74_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_DECLARATIONS_in_script78  */
static	ANTLR3_BITWORD FOLLOW_DECLARATIONS_in_script78_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_DECLARATIONS_in_script78	= { FOLLOW_DECLARATIONS_in_script78_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_declaration_in_script80  */
static	ANTLR3_BITWORD FOLLOW_declaration_in_script80_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000880008) };
static  ANTLR3_BITSET_LIST FOLLOW_declaration_in_script80	= { FOLLOW_declaration_in_script80_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_block_in_script84  */
static	ANTLR3_BITWORD FOLLOW_block_in_script84_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_block_in_script84	= { FOLLOW_block_in_script84_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_METADATA_in_metadata101  */
static	ANTLR3_BITWORD FOLLOW_METADATA_in_metadata101_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_METADATA_in_metadata101	= { FOLLOW_METADATA_in_metadata101_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_keyValueCollection_in_metadata103  */
static	ANTLR3_BITWORD FOLLOW_keyValueCollection_in_metadata103_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_keyValueCollection_in_metadata103	= { FOLLOW_keyValueCollection_in_metadata103_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_COLLECTION_in_keyValueCollection112  */
static	ANTLR3_BITWORD FOLLOW_COLLECTION_in_keyValueCollection112_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_COLLECTION_in_keyValueCollection112	= { FOLLOW_COLLECTION_in_keyValueCollection112_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_keyValuePair_in_keyValueCollection114  */
static	ANTLR3_BITWORD FOLLOW_keyValuePair_in_keyValueCollection114_bits[]	= { ANTLR3_UINT64_LIT(0x0000000804000008) };
static  ANTLR3_BITSET_LIST FOLLOW_keyValuePair_in_keyValueCollection114	= { FOLLOW_keyValuePair_in_keyValueCollection114_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_IDENTIFIER_in_keyValuePair126  */
static	ANTLR3_BITWORD FOLLOW_IDENTIFIER_in_keyValuePair126_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_IDENTIFIER_in_keyValuePair126	= { FOLLOW_IDENTIFIER_in_keyValuePair126_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_keyValueValue_in_keyValuePair128  */
static	ANTLR3_BITWORD FOLLOW_keyValueValue_in_keyValuePair128_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_keyValueValue_in_keyValuePair128	= { FOLLOW_keyValueValue_in_keyValuePair128_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_NUMBER_in_keyValuePair135  */
static	ANTLR3_BITWORD FOLLOW_NUMBER_in_keyValuePair135_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_NUMBER_in_keyValuePair135	= { FOLLOW_NUMBER_in_keyValuePair135_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_keyValueValue_in_keyValuePair137  */
static	ANTLR3_BITWORD FOLLOW_keyValueValue_in_keyValuePair137_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000028) };
static  ANTLR3_BITSET_LIST FOLLOW_keyValueValue_in_keyValuePair137	= { FOLLOW_keyValueValue_in_keyValuePair137_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_AT_in_keyValuePair139  */
static	ANTLR3_BITWORD FOLLOW_AT_in_keyValuePair139_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_AT_in_keyValuePair139	= { FOLLOW_AT_in_keyValuePair139_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_keyValueValue148  */
static	ANTLR3_BITWORD FOLLOW_expression_in_keyValueValue148_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_keyValueValue148	= { FOLLOW_expression_in_keyValueValue148_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_keyValueCollection_in_keyValueValue152  */
static	ANTLR3_BITWORD FOLLOW_keyValueCollection_in_keyValueValue152_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_keyValueCollection_in_keyValueValue152	= { FOLLOW_keyValueCollection_in_keyValueValue152_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_enumDeclaration_in_declaration159  */
static	ANTLR3_BITWORD FOLLOW_enumDeclaration_in_declaration159_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_enumDeclaration_in_declaration159	= { FOLLOW_enumDeclaration_in_declaration159_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_functionDeclaration_in_declaration163  */
static	ANTLR3_BITWORD FOLLOW_functionDeclaration_in_declaration163_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_functionDeclaration_in_declaration163	= { FOLLOW_functionDeclaration_in_declaration163_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ENUM_in_enumDeclaration171  */
static	ANTLR3_BITWORD FOLLOW_ENUM_in_enumDeclaration171_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_ENUM_in_enumDeclaration171	= { FOLLOW_ENUM_in_enumDeclaration171_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_IDENTIFIER_in_enumDeclaration173  */
static	ANTLR3_BITWORD FOLLOW_IDENTIFIER_in_enumDeclaration173_bits[]	= { ANTLR3_UINT64_LIT(0x0000000004000008) };
static  ANTLR3_BITSET_LIST FOLLOW_IDENTIFIER_in_enumDeclaration173	= { FOLLOW_IDENTIFIER_in_enumDeclaration173_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_enumValues_in_enumDeclaration175  */
static	ANTLR3_BITWORD FOLLOW_enumValues_in_enumDeclaration175_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_enumValues_in_enumDeclaration175	= { FOLLOW_enumValues_in_enumDeclaration175_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_enumValue_in_enumValues184  */
static	ANTLR3_BITWORD FOLLOW_enumValue_in_enumValues184_bits[]	= { ANTLR3_UINT64_LIT(0x0000000004000002) };
static  ANTLR3_BITSET_LIST FOLLOW_enumValue_in_enumValues184	= { FOLLOW_enumValue_in_enumValues184_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_IDENTIFIER_in_enumValue193  */
static	ANTLR3_BITWORD FOLLOW_IDENTIFIER_in_enumValue193_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_IDENTIFIER_in_enumValue193	= { FOLLOW_IDENTIFIER_in_enumValue193_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_enumValue195  */
static	ANTLR3_BITWORD FOLLOW_expression_in_enumValue195_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_enumValue195	= { FOLLOW_expression_in_enumValue195_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_FUNCTION_in_functionDeclaration205  */
static	ANTLR3_BITWORD FOLLOW_FUNCTION_in_functionDeclaration205_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_FUNCTION_in_functionDeclaration205	= { FOLLOW_FUNCTION_in_functionDeclaration205_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_IDENTIFIER_in_functionDeclaration207  */
static	ANTLR3_BITWORD FOLLOW_IDENTIFIER_in_functionDeclaration207_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000200) };
static  ANTLR3_BITSET_LIST FOLLOW_IDENTIFIER_in_functionDeclaration207	= { FOLLOW_IDENTIFIER_in_functionDeclaration207_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_formalParameters_in_functionDeclaration209  */
static	ANTLR3_BITWORD FOLLOW_formalParameters_in_functionDeclaration209_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000040) };
static  ANTLR3_BITSET_LIST FOLLOW_formalParameters_in_functionDeclaration209	= { FOLLOW_formalParameters_in_functionDeclaration209_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_block_in_functionDeclaration211  */
static	ANTLR3_BITWORD FOLLOW_block_in_functionDeclaration211_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_block_in_functionDeclaration211	= { FOLLOW_block_in_functionDeclaration211_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_PARAMETERS_in_formalParameters222  */
static	ANTLR3_BITWORD FOLLOW_PARAMETERS_in_formalParameters222_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_PARAMETERS_in_formalParameters222	= { FOLLOW_PARAMETERS_in_formalParameters222_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_IDENTIFIER_in_formalParameters224  */
static	ANTLR3_BITWORD FOLLOW_IDENTIFIER_in_formalParameters224_bits[]	= { ANTLR3_UINT64_LIT(0x0000000004000008) };
static  ANTLR3_BITSET_LIST FOLLOW_IDENTIFIER_in_formalParameters224	= { FOLLOW_IDENTIFIER_in_formalParameters224_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_BLOCK_in_block234  */
static	ANTLR3_BITWORD FOLLOW_BLOCK_in_block234_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_BLOCK_in_block234	= { FOLLOW_BLOCK_in_block234_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_statement_in_block236  */
static	ANTLR3_BITWORD FOLLOW_statement_in_block236_bits[]	= { ANTLR3_UINT64_LIT(0xFBF2FFFA8C60C0C8), ANTLR3_UINT64_LIT(0x00000000005F057D) };
static  ANTLR3_BITSET_LIST FOLLOW_statement_in_block236	= { FOLLOW_statement_in_block236_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_BREAK_in_statement254  */
static	ANTLR3_BITWORD FOLLOW_BREAK_in_statement254_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_BREAK_in_statement254	= { FOLLOW_BREAK_in_statement254_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_CONTINUE_in_statement262  */
static	ANTLR3_BITWORD FOLLOW_CONTINUE_in_statement262_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_CONTINUE_in_statement262	= { FOLLOW_CONTINUE_in_statement262_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_variableDeclaration_in_statement270  */
static	ANTLR3_BITWORD FOLLOW_variableDeclaration_in_statement270_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_variableDeclaration_in_statement270	= { FOLLOW_variableDeclaration_in_statement270_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_statement278  */
static	ANTLR3_BITWORD FOLLOW_expression_in_statement278_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_statement278	= { FOLLOW_expression_in_statement278_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_yieldStatement_in_statement286  */
static	ANTLR3_BITWORD FOLLOW_yieldStatement_in_statement286_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_yieldStatement_in_statement286	= { FOLLOW_yieldStatement_in_statement286_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_returnStatement_in_statement294  */
static	ANTLR3_BITWORD FOLLOW_returnStatement_in_statement294_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_returnStatement_in_statement294	= { FOLLOW_returnStatement_in_statement294_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_whileStatement_in_statement302  */
static	ANTLR3_BITWORD FOLLOW_whileStatement_in_statement302_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_whileStatement_in_statement302	= { FOLLOW_whileStatement_in_statement302_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_forStatement_in_statement310  */
static	ANTLR3_BITWORD FOLLOW_forStatement_in_statement310_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_forStatement_in_statement310	= { FOLLOW_forStatement_in_statement310_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ifStatement_in_statement318  */
static	ANTLR3_BITWORD FOLLOW_ifStatement_in_statement318_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_ifStatement_in_statement318	= { FOLLOW_ifStatement_in_statement318_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_switchStatement_in_statement326  */
static	ANTLR3_BITWORD FOLLOW_switchStatement_in_statement326_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_switchStatement_in_statement326	= { FOLLOW_switchStatement_in_statement326_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_block_in_statement334  */
static	ANTLR3_BITWORD FOLLOW_block_in_statement334_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_block_in_statement334	= { FOLLOW_block_in_statement334_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_VAR_in_variableDeclaration346  */
static	ANTLR3_BITWORD FOLLOW_VAR_in_variableDeclaration346_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_VAR_in_variableDeclaration346	= { FOLLOW_VAR_in_variableDeclaration346_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_IDENTIFIER_in_variableDeclaration348  */
static	ANTLR3_BITWORD FOLLOW_IDENTIFIER_in_variableDeclaration348_bits[]	= { ANTLR3_UINT64_LIT(0xFBF2FFFA84208008), ANTLR3_UINT64_LIT(0x000000000005017D) };
static  ANTLR3_BITSET_LIST FOLLOW_IDENTIFIER_in_variableDeclaration348	= { FOLLOW_IDENTIFIER_in_variableDeclaration348_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_variableDeclaration350  */
static	ANTLR3_BITWORD FOLLOW_expression_in_variableDeclaration350_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_variableDeclaration350	= { FOLLOW_expression_in_variableDeclaration350_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_YIELD_in_yieldStatement360  */
static	ANTLR3_BITWORD FOLLOW_YIELD_in_yieldStatement360_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_YIELD_in_yieldStatement360	= { FOLLOW_YIELD_in_yieldStatement360_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_yieldStatement362  */
static	ANTLR3_BITWORD FOLLOW_expression_in_yieldStatement362_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008), ANTLR3_UINT64_LIT(0x0000000000010000) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_yieldStatement362	= { FOLLOW_expression_in_yieldStatement362_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_STRING_in_yieldStatement364  */
static	ANTLR3_BITWORD FOLLOW_STRING_in_yieldStatement364_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_STRING_in_yieldStatement364	= { FOLLOW_STRING_in_yieldStatement364_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_RETURN_in_returnStatement375  */
static	ANTLR3_BITWORD FOLLOW_RETURN_in_returnStatement375_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_RETURN_in_returnStatement375	= { FOLLOW_RETURN_in_returnStatement375_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_returnStatement377  */
static	ANTLR3_BITWORD FOLLOW_expression_in_returnStatement377_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_returnStatement377	= { FOLLOW_expression_in_returnStatement377_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_WHILE_in_whileStatement387  */
static	ANTLR3_BITWORD FOLLOW_WHILE_in_whileStatement387_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_WHILE_in_whileStatement387	= { FOLLOW_WHILE_in_whileStatement387_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_whileStatement389  */
static	ANTLR3_BITWORD FOLLOW_expression_in_whileStatement389_bits[]	= { ANTLR3_UINT64_LIT(0xFBF2FFFA8C60C0C0), ANTLR3_UINT64_LIT(0x00000000005F057D) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_whileStatement389	= { FOLLOW_expression_in_whileStatement389_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_statement_in_whileStatement391  */
static	ANTLR3_BITWORD FOLLOW_statement_in_whileStatement391_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_statement_in_whileStatement391	= { FOLLOW_statement_in_whileStatement391_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_FOR_in_forStatement401  */
static	ANTLR3_BITWORD FOLLOW_FOR_in_forStatement401_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_FOR_in_forStatement401	= { FOLLOW_FOR_in_forStatement401_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_INITIALIZATION_EXPRESSION_in_forStatement404  */
static	ANTLR3_BITWORD FOLLOW_INITIALIZATION_EXPRESSION_in_forStatement404_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_INITIALIZATION_EXPRESSION_in_forStatement404	= { FOLLOW_INITIALIZATION_EXPRESSION_in_forStatement404_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_initExpression_in_forStatement406  */
static	ANTLR3_BITWORD FOLLOW_initExpression_in_forStatement406_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_initExpression_in_forStatement406	= { FOLLOW_initExpression_in_forStatement406_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_CONDITION_EXPRESSION_in_forStatement411  */
static	ANTLR3_BITWORD FOLLOW_CONDITION_EXPRESSION_in_forStatement411_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_CONDITION_EXPRESSION_in_forStatement411	= { FOLLOW_CONDITION_EXPRESSION_in_forStatement411_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_forStatement413  */
static	ANTLR3_BITWORD FOLLOW_expression_in_forStatement413_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_forStatement413	= { FOLLOW_expression_in_forStatement413_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_INCREMENT_EXPRESSION_in_forStatement418  */
static	ANTLR3_BITWORD FOLLOW_INCREMENT_EXPRESSION_in_forStatement418_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_INCREMENT_EXPRESSION_in_forStatement418	= { FOLLOW_INCREMENT_EXPRESSION_in_forStatement418_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_forStatement420  */
static	ANTLR3_BITWORD FOLLOW_expression_in_forStatement420_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_forStatement420	= { FOLLOW_expression_in_forStatement420_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_statement_in_forStatement424  */
static	ANTLR3_BITWORD FOLLOW_statement_in_forStatement424_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_statement_in_forStatement424	= { FOLLOW_statement_in_forStatement424_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_VAR_in_initExpression438  */
static	ANTLR3_BITWORD FOLLOW_VAR_in_initExpression438_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_VAR_in_initExpression438	= { FOLLOW_VAR_in_initExpression438_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_IDENTIFIER_in_initExpression440  */
static	ANTLR3_BITWORD FOLLOW_IDENTIFIER_in_initExpression440_bits[]	= { ANTLR3_UINT64_LIT(0xFBF2FFFA84208000), ANTLR3_UINT64_LIT(0x000000000005017D) };
static  ANTLR3_BITSET_LIST FOLLOW_IDENTIFIER_in_initExpression440	= { FOLLOW_IDENTIFIER_in_initExpression440_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_initExpression442  */
static	ANTLR3_BITWORD FOLLOW_expression_in_initExpression442_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_initExpression442	= { FOLLOW_expression_in_initExpression442_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_initExpression451  */
static	ANTLR3_BITWORD FOLLOW_expression_in_initExpression451_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_initExpression451	= { FOLLOW_expression_in_initExpression451_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_IF_in_ifStatement459  */
static	ANTLR3_BITWORD FOLLOW_IF_in_ifStatement459_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_IF_in_ifStatement459	= { FOLLOW_IF_in_ifStatement459_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_ifStatement461  */
static	ANTLR3_BITWORD FOLLOW_expression_in_ifStatement461_bits[]	= { ANTLR3_UINT64_LIT(0xFBF2FFFA8C60C0C0), ANTLR3_UINT64_LIT(0x00000000005F057D) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_ifStatement461	= { FOLLOW_expression_in_ifStatement461_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_statement_in_ifStatement463  */
static	ANTLR3_BITWORD FOLLOW_statement_in_ifStatement463_bits[]	= { ANTLR3_UINT64_LIT(0xFBF2FFFA8C60C0C8), ANTLR3_UINT64_LIT(0x00000000005F057D) };
static  ANTLR3_BITSET_LIST FOLLOW_statement_in_ifStatement463	= { FOLLOW_statement_in_ifStatement463_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_statement_in_ifStatement465  */
static	ANTLR3_BITWORD FOLLOW_statement_in_ifStatement465_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_statement_in_ifStatement465	= { FOLLOW_statement_in_ifStatement465_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_SWITCH_in_switchStatement475  */
static	ANTLR3_BITWORD FOLLOW_SWITCH_in_switchStatement475_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_SWITCH_in_switchStatement475	= { FOLLOW_SWITCH_in_switchStatement475_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_switchStatement477  */
static	ANTLR3_BITWORD FOLLOW_expression_in_switchStatement477_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000020108) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_switchStatement477	= { FOLLOW_expression_in_switchStatement477_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_normalCase_in_switchStatement479  */
static	ANTLR3_BITWORD FOLLOW_normalCase_in_switchStatement479_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000020108) };
static  ANTLR3_BITSET_LIST FOLLOW_normalCase_in_switchStatement479	= { FOLLOW_normalCase_in_switchStatement479_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_defaultCase_in_switchStatement482  */
static	ANTLR3_BITWORD FOLLOW_defaultCase_in_switchStatement482_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_defaultCase_in_switchStatement482	= { FOLLOW_defaultCase_in_switchStatement482_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_CASE_in_normalCase492  */
static	ANTLR3_BITWORD FOLLOW_CASE_in_normalCase492_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_CASE_in_normalCase492	= { FOLLOW_CASE_in_normalCase492_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_label_in_normalCase494  */
static	ANTLR3_BITWORD FOLLOW_label_in_normalCase494_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000040) };
static  ANTLR3_BITSET_LIST FOLLOW_label_in_normalCase494	= { FOLLOW_label_in_normalCase494_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_BLOCK_in_normalCase497  */
static	ANTLR3_BITWORD FOLLOW_BLOCK_in_normalCase497_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_BLOCK_in_normalCase497	= { FOLLOW_BLOCK_in_normalCase497_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_statement_in_normalCase499  */
static	ANTLR3_BITWORD FOLLOW_statement_in_normalCase499_bits[]	= { ANTLR3_UINT64_LIT(0xFBF2FFFA8C60C0C8), ANTLR3_UINT64_LIT(0x00000000005F057D) };
static  ANTLR3_BITSET_LIST FOLLOW_statement_in_normalCase499	= { FOLLOW_statement_in_normalCase499_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_DEFAULT_in_defaultCase509  */
static	ANTLR3_BITWORD FOLLOW_DEFAULT_in_defaultCase509_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_DEFAULT_in_defaultCase509	= { FOLLOW_DEFAULT_in_defaultCase509_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_BLOCK_in_defaultCase512  */
static	ANTLR3_BITWORD FOLLOW_BLOCK_in_defaultCase512_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_BLOCK_in_defaultCase512	= { FOLLOW_BLOCK_in_defaultCase512_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_statement_in_defaultCase514  */
static	ANTLR3_BITWORD FOLLOW_statement_in_defaultCase514_bits[]	= { ANTLR3_UINT64_LIT(0xFBF2FFFA8C60C0C8), ANTLR3_UINT64_LIT(0x00000000005F057D) };
static  ANTLR3_BITSET_LIST FOLLOW_statement_in_defaultCase514	= { FOLLOW_statement_in_defaultCase514_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_set_in_expression526  */
static	ANTLR3_BITWORD FOLLOW_set_in_expression526_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_set_in_expression526	= { FOLLOW_set_in_expression526_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_expression574  */
static	ANTLR3_BITWORD FOLLOW_expression_in_expression574_bits[]	= { ANTLR3_UINT64_LIT(0xFBF2FFFA84208000), ANTLR3_UINT64_LIT(0x000000000005017D) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_expression574	= { FOLLOW_expression_in_expression574_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_expression576  */
static	ANTLR3_BITWORD FOLLOW_expression_in_expression576_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_expression576	= { FOLLOW_expression_in_expression576_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_OPERATOR_EXPR_IF_in_expression583  */
static	ANTLR3_BITWORD FOLLOW_OPERATOR_EXPR_IF_in_expression583_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_OPERATOR_EXPR_IF_in_expression583	= { FOLLOW_OPERATOR_EXPR_IF_in_expression583_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_expression585  */
static	ANTLR3_BITWORD FOLLOW_expression_in_expression585_bits[]	= { ANTLR3_UINT64_LIT(0xFBF2FFFA84208000), ANTLR3_UINT64_LIT(0x000000000005017D) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_expression585	= { FOLLOW_expression_in_expression585_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_expression588  */
static	ANTLR3_BITWORD FOLLOW_expression_in_expression588_bits[]	= { ANTLR3_UINT64_LIT(0xFBF2FFFA84208000), ANTLR3_UINT64_LIT(0x000000000005017D) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_expression588	= { FOLLOW_expression_in_expression588_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_expression590  */
static	ANTLR3_BITWORD FOLLOW_expression_in_expression590_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_expression590	= { FOLLOW_expression_in_expression590_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_OPERATOR_REL_OR_in_expression597  */
static	ANTLR3_BITWORD FOLLOW_OPERATOR_REL_OR_in_expression597_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_OPERATOR_REL_OR_in_expression597	= { FOLLOW_OPERATOR_REL_OR_in_expression597_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_expression599  */
static	ANTLR3_BITWORD FOLLOW_expression_in_expression599_bits[]	= { ANTLR3_UINT64_LIT(0xFBF2FFFA84208000), ANTLR3_UINT64_LIT(0x000000000005017D) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_expression599	= { FOLLOW_expression_in_expression599_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_expression601  */
static	ANTLR3_BITWORD FOLLOW_expression_in_expression601_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_expression601	= { FOLLOW_expression_in_expression601_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_OPERATOR_REL_AND_in_expression608  */
static	ANTLR3_BITWORD FOLLOW_OPERATOR_REL_AND_in_expression608_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_OPERATOR_REL_AND_in_expression608	= { FOLLOW_OPERATOR_REL_AND_in_expression608_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_expression610  */
static	ANTLR3_BITWORD FOLLOW_expression_in_expression610_bits[]	= { ANTLR3_UINT64_LIT(0xFBF2FFFA84208000), ANTLR3_UINT64_LIT(0x000000000005017D) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_expression610	= { FOLLOW_expression_in_expression610_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_expression612  */
static	ANTLR3_BITWORD FOLLOW_expression_in_expression612_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_expression612	= { FOLLOW_expression_in_expression612_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_OPERATOR_BIT_XOR_in_expression619  */
static	ANTLR3_BITWORD FOLLOW_OPERATOR_BIT_XOR_in_expression619_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_OPERATOR_BIT_XOR_in_expression619	= { FOLLOW_OPERATOR_BIT_XOR_in_expression619_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_expression621  */
static	ANTLR3_BITWORD FOLLOW_expression_in_expression621_bits[]	= { ANTLR3_UINT64_LIT(0xFBF2FFFA84208000), ANTLR3_UINT64_LIT(0x000000000005017D) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_expression621	= { FOLLOW_expression_in_expression621_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_expression623  */
static	ANTLR3_BITWORD FOLLOW_expression_in_expression623_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_expression623	= { FOLLOW_expression_in_expression623_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_OPERATOR_BIT_AND_in_expression630  */
static	ANTLR3_BITWORD FOLLOW_OPERATOR_BIT_AND_in_expression630_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_OPERATOR_BIT_AND_in_expression630	= { FOLLOW_OPERATOR_BIT_AND_in_expression630_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_expression632  */
static	ANTLR3_BITWORD FOLLOW_expression_in_expression632_bits[]	= { ANTLR3_UINT64_LIT(0xFBF2FFFA84208000), ANTLR3_UINT64_LIT(0x000000000005017D) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_expression632	= { FOLLOW_expression_in_expression632_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_expression634  */
static	ANTLR3_BITWORD FOLLOW_expression_in_expression634_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_expression634	= { FOLLOW_expression_in_expression634_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_set_in_expression641  */
static	ANTLR3_BITWORD FOLLOW_set_in_expression641_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_set_in_expression641	= { FOLLOW_set_in_expression641_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_expression649  */
static	ANTLR3_BITWORD FOLLOW_expression_in_expression649_bits[]	= { ANTLR3_UINT64_LIT(0xFBF2FFFA84208000), ANTLR3_UINT64_LIT(0x000000000005017D) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_expression649	= { FOLLOW_expression_in_expression649_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_expression651  */
static	ANTLR3_BITWORD FOLLOW_expression_in_expression651_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_expression651	= { FOLLOW_expression_in_expression651_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_set_in_expression658  */
static	ANTLR3_BITWORD FOLLOW_set_in_expression658_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_set_in_expression658	= { FOLLOW_set_in_expression658_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_expression674  */
static	ANTLR3_BITWORD FOLLOW_expression_in_expression674_bits[]	= { ANTLR3_UINT64_LIT(0xFBF2FFFA84208000), ANTLR3_UINT64_LIT(0x000000000005017D) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_expression674	= { FOLLOW_expression_in_expression674_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_expression676  */
static	ANTLR3_BITWORD FOLLOW_expression_in_expression676_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_expression676	= { FOLLOW_expression_in_expression676_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_set_in_expression683  */
static	ANTLR3_BITWORD FOLLOW_set_in_expression683_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_set_in_expression683	= { FOLLOW_set_in_expression683_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_expression691  */
static	ANTLR3_BITWORD FOLLOW_expression_in_expression691_bits[]	= { ANTLR3_UINT64_LIT(0xFBF2FFFA84208000), ANTLR3_UINT64_LIT(0x000000000005017D) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_expression691	= { FOLLOW_expression_in_expression691_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_expression693  */
static	ANTLR3_BITWORD FOLLOW_expression_in_expression693_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_expression693	= { FOLLOW_expression_in_expression693_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_set_in_expression700  */
static	ANTLR3_BITWORD FOLLOW_set_in_expression700_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_set_in_expression700	= { FOLLOW_set_in_expression700_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_expression708  */
static	ANTLR3_BITWORD FOLLOW_expression_in_expression708_bits[]	= { ANTLR3_UINT64_LIT(0xFBF2FFFA84208000), ANTLR3_UINT64_LIT(0x000000000005017D) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_expression708	= { FOLLOW_expression_in_expression708_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_expression710  */
static	ANTLR3_BITWORD FOLLOW_expression_in_expression710_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_expression710	= { FOLLOW_expression_in_expression710_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_set_in_expression717  */
static	ANTLR3_BITWORD FOLLOW_set_in_expression717_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_set_in_expression717	= { FOLLOW_set_in_expression717_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_expression729  */
static	ANTLR3_BITWORD FOLLOW_expression_in_expression729_bits[]	= { ANTLR3_UINT64_LIT(0xFBF2FFFA84208000), ANTLR3_UINT64_LIT(0x000000000005017D) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_expression729	= { FOLLOW_expression_in_expression729_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_expression731  */
static	ANTLR3_BITWORD FOLLOW_expression_in_expression731_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_expression731	= { FOLLOW_expression_in_expression731_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_OPERATOR_DOT_in_expression739  */
static	ANTLR3_BITWORD FOLLOW_OPERATOR_DOT_in_expression739_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_OPERATOR_DOT_in_expression739	= { FOLLOW_OPERATOR_DOT_in_expression739_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_expression741  */
static	ANTLR3_BITWORD FOLLOW_expression_in_expression741_bits[]	= { ANTLR3_UINT64_LIT(0xFBF2FFFA84208000), ANTLR3_UINT64_LIT(0x000000000005017D) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_expression741	= { FOLLOW_expression_in_expression741_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_expression743  */
static	ANTLR3_BITWORD FOLLOW_expression_in_expression743_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_expression743	= { FOLLOW_expression_in_expression743_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LEFT_BRACKET_in_expression750  */
static	ANTLR3_BITWORD FOLLOW_LEFT_BRACKET_in_expression750_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_LEFT_BRACKET_in_expression750	= { FOLLOW_LEFT_BRACKET_in_expression750_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_expression752  */
static	ANTLR3_BITWORD FOLLOW_expression_in_expression752_bits[]	= { ANTLR3_UINT64_LIT(0xFBF2FFFA84208008), ANTLR3_UINT64_LIT(0x000000000005017D) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_expression752	= { FOLLOW_expression_in_expression752_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_expression754  */
static	ANTLR3_BITWORD FOLLOW_expression_in_expression754_bits[]	= { ANTLR3_UINT64_LIT(0xFBF2FFFA84208008), ANTLR3_UINT64_LIT(0x000000000005017D) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_expression754	= { FOLLOW_expression_in_expression754_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LEFT_SQUARE_BRACKET_in_expression762  */
static	ANTLR3_BITWORD FOLLOW_LEFT_SQUARE_BRACKET_in_expression762_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_LEFT_SQUARE_BRACKET_in_expression762	= { FOLLOW_LEFT_SQUARE_BRACKET_in_expression762_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_expression764  */
static	ANTLR3_BITWORD FOLLOW_expression_in_expression764_bits[]	= { ANTLR3_UINT64_LIT(0xFBF2FFFA84208008), ANTLR3_UINT64_LIT(0x000000000005017D) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_expression764	= { FOLLOW_expression_in_expression764_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_expression766  */
static	ANTLR3_BITWORD FOLLOW_expression_in_expression766_bits[]	= { ANTLR3_UINT64_LIT(0xFBF2FFFA84208008), ANTLR3_UINT64_LIT(0x000000000005017D) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_expression766	= { FOLLOW_expression_in_expression766_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_IDENTIFIER_in_expression773  */
static	ANTLR3_BITWORD FOLLOW_IDENTIFIER_in_expression773_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_IDENTIFIER_in_expression773	= { FOLLOW_IDENTIFIER_in_expression773_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_coordinateLiteral_in_expression780  */
static	ANTLR3_BITWORD FOLLOW_coordinateLiteral_in_expression780_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_coordinateLiteral_in_expression780	= { FOLLOW_coordinateLiteral_in_expression780_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_TRUE_LIT_in_expression785  */
static	ANTLR3_BITWORD FOLLOW_TRUE_LIT_in_expression785_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_TRUE_LIT_in_expression785	= { FOLLOW_TRUE_LIT_in_expression785_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_FALSE_LIT_in_expression790  */
static	ANTLR3_BITWORD FOLLOW_FALSE_LIT_in_expression790_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_FALSE_LIT_in_expression790	= { FOLLOW_FALSE_LIT_in_expression790_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_NUMBER_in_expression795  */
static	ANTLR3_BITWORD FOLLOW_NUMBER_in_expression795_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_NUMBER_in_expression795	= { FOLLOW_NUMBER_in_expression795_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_STRING_in_expression800  */
static	ANTLR3_BITWORD FOLLOW_STRING_in_expression800_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_STRING_in_expression800	= { FOLLOW_STRING_in_expression800_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LEFT_CURLY_BRACKET_in_unkeyedCollectionLiteral852  */
static	ANTLR3_BITWORD FOLLOW_LEFT_CURLY_BRACKET_in_unkeyedCollectionLiteral852_bits[]	= { ANTLR3_UINT64_LIT(0xFBF2FFFA84208000), ANTLR3_UINT64_LIT(0x000000000005017D) };
static  ANTLR3_BITSET_LIST FOLLOW_LEFT_CURLY_BRACKET_in_unkeyedCollectionLiteral852	= { FOLLOW_LEFT_CURLY_BRACKET_in_unkeyedCollectionLiteral852_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_unkeyedCollectionLiteral855  */
static	ANTLR3_BITWORD FOLLOW_expression_in_unkeyedCollectionLiteral855_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000800), ANTLR3_UINT64_LIT(0x0000000000002000) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_unkeyedCollectionLiteral855	= { FOLLOW_expression_in_unkeyedCollectionLiteral855_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_COMMA_in_unkeyedCollectionLiteral858  */
static	ANTLR3_BITWORD FOLLOW_COMMA_in_unkeyedCollectionLiteral858_bits[]	= { ANTLR3_UINT64_LIT(0xFBF2FFFA84208000), ANTLR3_UINT64_LIT(0x000000000005017D) };
static  ANTLR3_BITSET_LIST FOLLOW_COMMA_in_unkeyedCollectionLiteral858	= { FOLLOW_COMMA_in_unkeyedCollectionLiteral858_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_unkeyedCollectionLiteral860  */
static	ANTLR3_BITWORD FOLLOW_expression_in_unkeyedCollectionLiteral860_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000800), ANTLR3_UINT64_LIT(0x0000000000002000) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_unkeyedCollectionLiteral860	= { FOLLOW_expression_in_unkeyedCollectionLiteral860_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_RIGTH_CURLY_BRACKET_in_unkeyedCollectionLiteral865  */
static	ANTLR3_BITWORD FOLLOW_RIGTH_CURLY_BRACKET_in_unkeyedCollectionLiteral865_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_RIGTH_CURLY_BRACKET_in_unkeyedCollectionLiteral865	= { FOLLOW_RIGTH_CURLY_BRACKET_in_unkeyedCollectionLiteral865_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_COORDINATE_in_coordinateLiteral873  */
static	ANTLR3_BITWORD FOLLOW_COORDINATE_in_coordinateLiteral873_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_COORDINATE_in_coordinateLiteral873	= { FOLLOW_COORDINATE_in_coordinateLiteral873_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_coordinateLiteral875  */
static	ANTLR3_BITWORD FOLLOW_expression_in_coordinateLiteral875_bits[]	= { ANTLR3_UINT64_LIT(0xFBF2FFFA84208008), ANTLR3_UINT64_LIT(0x000000000005017D) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_coordinateLiteral875	= { FOLLOW_expression_in_coordinateLiteral875_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_IDENTCHAIN_in_label894  */
static	ANTLR3_BITWORD FOLLOW_IDENTCHAIN_in_label894_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_IDENTCHAIN_in_label894	= { FOLLOW_IDENTCHAIN_in_label894_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_IDENTIFIER_in_label896  */
static	ANTLR3_BITWORD FOLLOW_IDENTIFIER_in_label896_bits[]	= { ANTLR3_UINT64_LIT(0x0000000004000008) };
static  ANTLR3_BITSET_LIST FOLLOW_IDENTIFIER_in_label896	= { FOLLOW_IDENTIFIER_in_label896_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_TRUE_LIT_in_label903  */
static	ANTLR3_BITWORD FOLLOW_TRUE_LIT_in_label903_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_TRUE_LIT_in_label903	= { FOLLOW_TRUE_LIT_in_label903_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_FALSE_LIT_in_label915  */
static	ANTLR3_BITWORD FOLLOW_FALSE_LIT_in_label915_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_FALSE_LIT_in_label915	= { FOLLOW_FALSE_LIT_in_label915_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_NUMBER_in_label920  */
static	ANTLR3_BITWORD FOLLOW_NUMBER_in_label920_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_NUMBER_in_label920	= { FOLLOW_NUMBER_in_label920_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_STRING_in_label925  */
static	ANTLR3_BITWORD FOLLOW_STRING_in_label925_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_STRING_in_label925	= { FOLLOW_STRING_in_label925_bits, 1	};


/* ==============================================
 * Parsing rules
 */
/**
 * $ANTLR start script
 * D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:22:1: script : ^( SCRIPT ( metadata )? ^( DECLARATIONS ( declaration )* ) block ) ;
 */
static void
script(pGeoGenScriptDecls ctx)
{
    /* Initialize rule variables
     */

    {
        // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:22:7: ( ^( SCRIPT ( metadata )? ^( DECLARATIONS ( declaration )* ) block ) )
        // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:22:9: ^( SCRIPT ( metadata )? ^( DECLARATIONS ( declaration )* ) block )
        {
             MATCHT(SCRIPT, &FOLLOW_SCRIPT_in_script72);
            if  (HASEXCEPTION())
            {
                goto rulescriptEx;
            }


            MATCHT(ANTLR3_TOKEN_DOWN, NULL);
            if  (HASEXCEPTION())
            {
                goto rulescriptEx;
            }

            // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:22:18: ( metadata )?
            {
                int alt1=2;
                switch ( LA(1) )
                {
                    case METADATA:
                    	{
                    		alt1=1;
                    	}
                        break;
                }

                switch (alt1)
                {
            	case 1:
            	    // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:22:18: metadata
            	    {
            	        FOLLOWPUSH(FOLLOW_metadata_in_script74);
            	        metadata(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulescriptEx;
            	        }


            	    }
            	    break;

                }
            }

             MATCHT(DECLARATIONS, &FOLLOW_DECLARATIONS_in_script78);
            if  (HASEXCEPTION())
            {
                goto rulescriptEx;
            }


            if ( LA(1)==ANTLR3_TOKEN_DOWN ) {
                MATCHT(ANTLR3_TOKEN_DOWN, NULL);
                if  (HASEXCEPTION())
                {
                    goto rulescriptEx;
                }

                // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:22:43: ( declaration )*

                for (;;)
                {
                    int alt2=2;
                    switch ( LA(1) )
                    {
                    case ENUM:
                    case FUNCTION:
                    	{
                    		alt2=1;
                    	}
                        break;

                    }

                    switch (alt2)
                    {
                	case 1:
                	    // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:22:43: declaration
                	    {
                	        FOLLOWPUSH(FOLLOW_declaration_in_script80);
                	        declaration(ctx);

                	        FOLLOWPOP();
                	        if  (HASEXCEPTION())
                	        {
                	            goto rulescriptEx;
                	        }


                	    }
                	    break;

                	default:
                	    goto loop2;	/* break out of the loop */
                	    break;
                    }
                }
                loop2: ; /* Jump out to here if this rule does not match */


                MATCHT(ANTLR3_TOKEN_UP, NULL);
                if  (HASEXCEPTION())
                {
                    goto rulescriptEx;
                }

            }


            FOLLOWPUSH(FOLLOW_block_in_script84);
            block(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulescriptEx;
            }


            MATCHT(ANTLR3_TOKEN_UP, NULL);
            if  (HASEXCEPTION())
            {
                goto rulescriptEx;
            }



        }

    }

    // This is where rules clean up and exit
    //
    goto rulescriptEx; /* Prevent compiler warnings */
    rulescriptEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end script */

/**
 * $ANTLR start metadata
 * D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:24:1: metadata : ^( 'metadata' keyValueCollection ) ;
 */
static void
metadata(pGeoGenScriptDecls ctx)
{
    /* Initialize rule variables
     */

    {
        // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:24:9: ( ^( 'metadata' keyValueCollection ) )
        // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:24:11: ^( 'metadata' keyValueCollection )
        {
             MATCHT(METADATA, &FOLLOW_METADATA_in_metadata101);
            if  (HASEXCEPTION())
            {
                goto rulemetadataEx;
            }


            MATCHT(ANTLR3_TOKEN_DOWN, NULL);
            if  (HASEXCEPTION())
            {
                goto rulemetadataEx;
            }

            FOLLOWPUSH(FOLLOW_keyValueCollection_in_metadata103);
            keyValueCollection(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulemetadataEx;
            }


            MATCHT(ANTLR3_TOKEN_UP, NULL);
            if  (HASEXCEPTION())
            {
                goto rulemetadataEx;
            }



        }

    }

    // This is where rules clean up and exit
    //
    goto rulemetadataEx; /* Prevent compiler warnings */
    rulemetadataEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end metadata */

/**
 * $ANTLR start keyValueCollection
 * D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:26:1: keyValueCollection : ^( COLLECTION ( keyValuePair )* ) ;
 */
static void
keyValueCollection(pGeoGenScriptDecls ctx)
{
    /* Initialize rule variables
     */

    {
        // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:26:19: ( ^( COLLECTION ( keyValuePair )* ) )
        // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:26:21: ^( COLLECTION ( keyValuePair )* )
        {
             MATCHT(COLLECTION, &FOLLOW_COLLECTION_in_keyValueCollection112);
            if  (HASEXCEPTION())
            {
                goto rulekeyValueCollectionEx;
            }


            if ( LA(1)==ANTLR3_TOKEN_DOWN ) {
                MATCHT(ANTLR3_TOKEN_DOWN, NULL);
                if  (HASEXCEPTION())
                {
                    goto rulekeyValueCollectionEx;
                }

                // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:26:34: ( keyValuePair )*

                for (;;)
                {
                    int alt3=2;
                    switch ( LA(1) )
                    {
                    case IDENTIFIER:
                    case NUMBER:
                    	{
                    		alt3=1;
                    	}
                        break;

                    }

                    switch (alt3)
                    {
                	case 1:
                	    // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:26:34: keyValuePair
                	    {
                	        FOLLOWPUSH(FOLLOW_keyValuePair_in_keyValueCollection114);
                	        keyValuePair(ctx);

                	        FOLLOWPOP();
                	        if  (HASEXCEPTION())
                	        {
                	            goto rulekeyValueCollectionEx;
                	        }


                	    }
                	    break;

                	default:
                	    goto loop3;	/* break out of the loop */
                	    break;
                    }
                }
                loop3: ; /* Jump out to here if this rule does not match */


                MATCHT(ANTLR3_TOKEN_UP, NULL);
                if  (HASEXCEPTION())
                {
                    goto rulekeyValueCollectionEx;
                }

            }


        }

    }

    // This is where rules clean up and exit
    //
    goto rulekeyValueCollectionEx; /* Prevent compiler warnings */
    rulekeyValueCollectionEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end keyValueCollection */

/**
 * $ANTLR start keyValuePair
 * D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:28:1: keyValuePair : ( ^( IDENTIFIER keyValueValue ) | ^( NUMBER keyValueValue ( '@' )? ) );
 */
static void
keyValuePair(pGeoGenScriptDecls ctx)
{
    /* Initialize rule variables
     */

    {
        {
            //  D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:28:13: ( ^( IDENTIFIER keyValueValue ) | ^( NUMBER keyValueValue ( '@' )? ) )

            ANTLR3_UINT32 alt5;

            alt5=2;

            switch ( LA(1) )
            {
            case IDENTIFIER:
            	{
            		alt5=1;
            	}
                break;
            case NUMBER:
            	{
            		alt5=2;
            	}
                break;

            default:
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 5;
                EXCEPTION->state        = 0;


                goto rulekeyValuePairEx;

            }

            switch (alt5)
            {
        	case 1:
        	    // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:29:2: ^( IDENTIFIER keyValueValue )
        	    {
        	         MATCHT(IDENTIFIER, &FOLLOW_IDENTIFIER_in_keyValuePair126);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulekeyValuePairEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_DOWN, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulekeyValuePairEx;
        	        }

        	        FOLLOWPUSH(FOLLOW_keyValueValue_in_keyValuePair128);
        	        keyValueValue(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulekeyValuePairEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_UP, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulekeyValuePairEx;
        	        }



        	    }
        	    break;
        	case 2:
        	    // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:30:4: ^( NUMBER keyValueValue ( '@' )? )
        	    {
        	         MATCHT(NUMBER, &FOLLOW_NUMBER_in_keyValuePair135);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulekeyValuePairEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_DOWN, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulekeyValuePairEx;
        	        }

        	        FOLLOWPUSH(FOLLOW_keyValueValue_in_keyValuePair137);
        	        keyValueValue(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulekeyValuePairEx;
        	        }


        	        // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:30:27: ( '@' )?
        	        {
        	            int alt4=2;
        	            switch ( LA(1) )
        	            {
        	                case AT:
        	                	{
        	                		alt4=1;
        	                	}
        	                    break;
        	            }

        	            switch (alt4)
        	            {
        	        	case 1:
        	        	    // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:30:27: '@'
        	        	    {
        	        	         MATCHT(AT, &FOLLOW_AT_in_keyValuePair139);
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto rulekeyValuePairEx;
        	        	        }


        	        	    }
        	        	    break;

        	            }
        	        }

        	        MATCHT(ANTLR3_TOKEN_UP, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulekeyValuePairEx;
        	        }



        	    }
        	    break;

            }
        }
    }

    // This is where rules clean up and exit
    //
    goto rulekeyValuePairEx; /* Prevent compiler warnings */
    rulekeyValuePairEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end keyValuePair */

/**
 * $ANTLR start keyValueValue
 * D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:32:1: keyValueValue : ( expression | keyValueCollection );
 */
static void
keyValueValue(pGeoGenScriptDecls ctx)
{
    /* Initialize rule variables
     */

    {
        {
            //  D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:32:14: ( expression | keyValueCollection )

            ANTLR3_UINT32 alt6;

            alt6=2;

            switch ( LA(1) )
            {
            case COORDINATE:
            case FALSE_LIT:
            case IDENTIFIER:
            case LEFT_BRACKET:
            case LEFT_SQUARE_BRACKET:
            case NUMBER:
            case OPERATOR_ASSIGN:
            case OPERATOR_ASSIGN_AND:
            case OPERATOR_ASSIGN_DIVIDE:
            case OPERATOR_ASSIGN_LSHIFT:
            case OPERATOR_ASSIGN_MINUS:
            case OPERATOR_ASSIGN_MODULO:
            case OPERATOR_ASSIGN_OR:
            case OPERATOR_ASSIGN_PLUS:
            case OPERATOR_ASSIGN_RSHIFT:
            case OPERATOR_ASSIGN_TIMES:
            case OPERATOR_ASSIGN_XOR:
            case OPERATOR_BIT_AND:
            case OPERATOR_BIT_XOR:
            case OPERATOR_DIVIDE:
            case OPERATOR_DOT:
            case OPERATOR_EQUAL_TO:
            case OPERATOR_EXPR_IF:
            case OPERATOR_GREATER_THAN:
            case OPERATOR_GREATER_THAN_OR_EQUAL_TO:
            case OPERATOR_IS:
            case OPERATOR_LESS_THAN:
            case OPERATOR_LESS_THAN_OR_EQUAL_TO:
            case OPERATOR_LSHIFT:
            case OPERATOR_MINUS:
            case OPERATOR_MODULO:
            case OPERATOR_NOT_EQUAL_TO:
            case OPERATOR_PLUS:
            case OPERATOR_REL_AND:
            case OPERATOR_REL_OR:
            case OPERATOR_RSHIFT:
            case OPERATOR_TIMES:
            case STRING:
            case TRUE_LIT:
            	{
            		alt6=1;
            	}
                break;
            case COLLECTION:
            	{
            		alt6=2;
            	}
                break;

            default:
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 6;
                EXCEPTION->state        = 0;


                goto rulekeyValueValueEx;

            }

            switch (alt6)
            {
        	case 1:
        	    // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:32:16: expression
        	    {
        	        FOLLOWPUSH(FOLLOW_expression_in_keyValueValue148);
        	        expression(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulekeyValueValueEx;
        	        }


        	    }
        	    break;
        	case 2:
        	    // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:32:29: keyValueCollection
        	    {
        	        FOLLOWPUSH(FOLLOW_keyValueCollection_in_keyValueValue152);
        	        keyValueCollection(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulekeyValueValueEx;
        	        }


        	    }
        	    break;

            }
        }
    }

    // This is where rules clean up and exit
    //
    goto rulekeyValueValueEx; /* Prevent compiler warnings */
    rulekeyValueValueEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end keyValueValue */

/**
 * $ANTLR start declaration
 * D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:34:1: declaration : ( enumDeclaration | functionDeclaration );
 */
static void
declaration(pGeoGenScriptDecls ctx)
{
    /* Initialize rule variables
     */

    {
        {
            //  D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:34:12: ( enumDeclaration | functionDeclaration )

            ANTLR3_UINT32 alt7;

            alt7=2;

            switch ( LA(1) )
            {
            case ENUM:
            	{
            		alt7=1;
            	}
                break;
            case FUNCTION:
            	{
            		alt7=2;
            	}
                break;

            default:
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 7;
                EXCEPTION->state        = 0;


                goto ruledeclarationEx;

            }

            switch (alt7)
            {
        	case 1:
        	    // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:34:14: enumDeclaration
        	    {
        	        FOLLOWPUSH(FOLLOW_enumDeclaration_in_declaration159);
        	        enumDeclaration(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruledeclarationEx;
        	        }


        	    }
        	    break;
        	case 2:
        	    // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:34:32: functionDeclaration
        	    {
        	        FOLLOWPUSH(FOLLOW_functionDeclaration_in_declaration163);
        	        functionDeclaration(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruledeclarationEx;
        	        }


        	    }
        	    break;

            }
        }
    }

    // This is where rules clean up and exit
    //
    goto ruledeclarationEx; /* Prevent compiler warnings */
    ruledeclarationEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end declaration */

/**
 * $ANTLR start enumDeclaration
 * D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:36:1: enumDeclaration : ^( 'enum' IDENTIFIER ( enumValues )? ) ;
 */
static void
enumDeclaration(pGeoGenScriptDecls ctx)
{
    /* Initialize rule variables
     */

    {
        // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:36:16: ( ^( 'enum' IDENTIFIER ( enumValues )? ) )
        // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:36:18: ^( 'enum' IDENTIFIER ( enumValues )? )
        {
             MATCHT(ENUM, &FOLLOW_ENUM_in_enumDeclaration171);
            if  (HASEXCEPTION())
            {
                goto ruleenumDeclarationEx;
            }


            MATCHT(ANTLR3_TOKEN_DOWN, NULL);
            if  (HASEXCEPTION())
            {
                goto ruleenumDeclarationEx;
            }

             MATCHT(IDENTIFIER, &FOLLOW_IDENTIFIER_in_enumDeclaration173);
            if  (HASEXCEPTION())
            {
                goto ruleenumDeclarationEx;
            }


            // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:36:38: ( enumValues )?
            {
                int alt8=2;
                switch ( LA(1) )
                {
                    case IDENTIFIER:
                    	{
                    		alt8=1;
                    	}
                        break;
                }

                switch (alt8)
                {
            	case 1:
            	    // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:36:38: enumValues
            	    {
            	        FOLLOWPUSH(FOLLOW_enumValues_in_enumDeclaration175);
            	        enumValues(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleenumDeclarationEx;
            	        }


            	    }
            	    break;

                }
            }

            MATCHT(ANTLR3_TOKEN_UP, NULL);
            if  (HASEXCEPTION())
            {
                goto ruleenumDeclarationEx;
            }



        }

    }

    // This is where rules clean up and exit
    //
    goto ruleenumDeclarationEx; /* Prevent compiler warnings */
    ruleenumDeclarationEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end enumDeclaration */

/**
 * $ANTLR start enumValues
 * D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:38:1: enumValues : ( enumValue )+ ;
 */
static void
enumValues(pGeoGenScriptDecls ctx)
{
    /* Initialize rule variables
     */

    {
        // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:38:11: ( ( enumValue )+ )
        // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:38:13: ( enumValue )+
        {
            // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:38:13: ( enumValue )+
            {
                int cnt9=0;

                for (;;)
                {
                    int alt9=2;
            	switch ( LA(1) )
            	{
            	case IDENTIFIER:
            		{
            			alt9=1;
            		}
            	    break;

            	}

            	switch (alt9)
            	{
            	    case 1:
            	        // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:38:13: enumValue
            	        {
            	            FOLLOWPUSH(FOLLOW_enumValue_in_enumValues184);
            	            enumValue(ctx);

            	            FOLLOWPOP();
            	            if  (HASEXCEPTION())
            	            {
            	                goto ruleenumValuesEx;
            	            }


            	        }
            	        break;

            	    default:

            		if ( cnt9 >= 1 )
            		{
            		    goto loop9;
            		}
            		/* mismatchedSetEx()
            		 */
            		CONSTRUCTEX();
            		EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;
            		EXCEPTION->name = (void *)ANTLR3_EARLY_EXIT_NAME;


            		goto ruleenumValuesEx;
            	}
            	cnt9++;
                }
                loop9: ;	/* Jump to here if this rule does not match */
            }

        }

    }

    // This is where rules clean up and exit
    //
    goto ruleenumValuesEx; /* Prevent compiler warnings */
    ruleenumValuesEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end enumValues */

/**
 * $ANTLR start enumValue
 * D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:40:1: enumValue : ^( IDENTIFIER ( expression )? ) ;
 */
static void
enumValue(pGeoGenScriptDecls ctx)
{
    /* Initialize rule variables
     */

    {
        // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:40:10: ( ^( IDENTIFIER ( expression )? ) )
        // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:40:12: ^( IDENTIFIER ( expression )? )
        {
             MATCHT(IDENTIFIER, &FOLLOW_IDENTIFIER_in_enumValue193);
            if  (HASEXCEPTION())
            {
                goto ruleenumValueEx;
            }


            if ( LA(1)==ANTLR3_TOKEN_DOWN ) {
                MATCHT(ANTLR3_TOKEN_DOWN, NULL);
                if  (HASEXCEPTION())
                {
                    goto ruleenumValueEx;
                }

                // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:40:25: ( expression )?
                {
                    int alt10=2;
                    switch ( LA(1) )
                    {
                        case COORDINATE:
                        case FALSE_LIT:
                        case IDENTIFIER:
                        case LEFT_BRACKET:
                        case LEFT_SQUARE_BRACKET:
                        case NUMBER:
                        case OPERATOR_ASSIGN:
                        case OPERATOR_ASSIGN_AND:
                        case OPERATOR_ASSIGN_DIVIDE:
                        case OPERATOR_ASSIGN_LSHIFT:
                        case OPERATOR_ASSIGN_MINUS:
                        case OPERATOR_ASSIGN_MODULO:
                        case OPERATOR_ASSIGN_OR:
                        case OPERATOR_ASSIGN_PLUS:
                        case OPERATOR_ASSIGN_RSHIFT:
                        case OPERATOR_ASSIGN_TIMES:
                        case OPERATOR_ASSIGN_XOR:
                        case OPERATOR_BIT_AND:
                        case OPERATOR_BIT_XOR:
                        case OPERATOR_DIVIDE:
                        case OPERATOR_DOT:
                        case OPERATOR_EQUAL_TO:
                        case OPERATOR_EXPR_IF:
                        case OPERATOR_GREATER_THAN:
                        case OPERATOR_GREATER_THAN_OR_EQUAL_TO:
                        case OPERATOR_IS:
                        case OPERATOR_LESS_THAN:
                        case OPERATOR_LESS_THAN_OR_EQUAL_TO:
                        case OPERATOR_LSHIFT:
                        case OPERATOR_MINUS:
                        case OPERATOR_MODULO:
                        case OPERATOR_NOT_EQUAL_TO:
                        case OPERATOR_PLUS:
                        case OPERATOR_REL_AND:
                        case OPERATOR_REL_OR:
                        case OPERATOR_RSHIFT:
                        case OPERATOR_TIMES:
                        case STRING:
                        case TRUE_LIT:
                        	{
                        		alt10=1;
                        	}
                            break;
                    }

                    switch (alt10)
                    {
                	case 1:
                	    // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:40:25: expression
                	    {
                	        FOLLOWPUSH(FOLLOW_expression_in_enumValue195);
                	        expression(ctx);

                	        FOLLOWPOP();
                	        if  (HASEXCEPTION())
                	        {
                	            goto ruleenumValueEx;
                	        }


                	    }
                	    break;

                    }
                }

                MATCHT(ANTLR3_TOKEN_UP, NULL);
                if  (HASEXCEPTION())
                {
                    goto ruleenumValueEx;
                }

            }


        }

    }

    // This is where rules clean up and exit
    //
    goto ruleenumValueEx; /* Prevent compiler warnings */
    ruleenumValueEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end enumValue */

/**
 * $ANTLR start functionDeclaration
 * D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:42:1: functionDeclaration : ^( 'function' IDENTIFIER formalParameters block ) ;
 */
static void
functionDeclaration(pGeoGenScriptDecls ctx)
{
    pANTLR3_BASE_TREE    IDENTIFIER1;

    /* Initialize rule variables
     */

    IDENTIFIER1       = NULL;

    {
        // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:42:20: ( ^( 'function' IDENTIFIER formalParameters block ) )
        // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:42:22: ^( 'function' IDENTIFIER formalParameters block )
        {
             MATCHT(FUNCTION, &FOLLOW_FUNCTION_in_functionDeclaration205);
            if  (HASEXCEPTION())
            {
                goto rulefunctionDeclarationEx;
            }


            MATCHT(ANTLR3_TOKEN_DOWN, NULL);
            if  (HASEXCEPTION())
            {
                goto rulefunctionDeclarationEx;
            }

            IDENTIFIER1 = (pANTLR3_BASE_TREE) MATCHT(IDENTIFIER, &FOLLOW_IDENTIFIER_in_functionDeclaration207);
            if  (HASEXCEPTION())
            {
                goto rulefunctionDeclarationEx;
            }


            FOLLOWPUSH(FOLLOW_formalParameters_in_functionDeclaration209);
            formalParameters(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulefunctionDeclarationEx;
            }


            FOLLOWPUSH(FOLLOW_block_in_functionDeclaration211);
            block(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulefunctionDeclarationEx;
            }


            MATCHT(ANTLR3_TOKEN_UP, NULL);
            if  (HASEXCEPTION())
            {
                goto rulefunctionDeclarationEx;
            }



            {

                	FunctionDefinition* decl = new FunctionDefinition((char*)(IDENTIFIER1->getText(IDENTIFIER1))->chars);
                	
                	ctx->compiledScript->GetFunctionDefinitions()->AddItem(decl);
                	ctx->compiledScript->GetSymbolNameTable()->AddName(decl->GetName());

            }


        }

    }

    // This is where rules clean up and exit
    //
    goto rulefunctionDeclarationEx; /* Prevent compiler warnings */
    rulefunctionDeclarationEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end functionDeclaration */

/**
 * $ANTLR start formalParameters
 * D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:49:1: formalParameters : ^( PARAMETERS ( IDENTIFIER )* ) ;
 */
static void
formalParameters(pGeoGenScriptDecls ctx)
{
    /* Initialize rule variables
     */

    {
        // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:49:17: ( ^( PARAMETERS ( IDENTIFIER )* ) )
        // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:49:19: ^( PARAMETERS ( IDENTIFIER )* )
        {
             MATCHT(PARAMETERS, &FOLLOW_PARAMETERS_in_formalParameters222);
            if  (HASEXCEPTION())
            {
                goto ruleformalParametersEx;
            }


            if ( LA(1)==ANTLR3_TOKEN_DOWN ) {
                MATCHT(ANTLR3_TOKEN_DOWN, NULL);
                if  (HASEXCEPTION())
                {
                    goto ruleformalParametersEx;
                }

                // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:49:32: ( IDENTIFIER )*

                for (;;)
                {
                    int alt11=2;
                    switch ( LA(1) )
                    {
                    case IDENTIFIER:
                    	{
                    		alt11=1;
                    	}
                        break;

                    }

                    switch (alt11)
                    {
                	case 1:
                	    // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:49:32: IDENTIFIER
                	    {
                	         MATCHT(IDENTIFIER, &FOLLOW_IDENTIFIER_in_formalParameters224);
                	        if  (HASEXCEPTION())
                	        {
                	            goto ruleformalParametersEx;
                	        }


                	    }
                	    break;

                	default:
                	    goto loop11;	/* break out of the loop */
                	    break;
                    }
                }
                loop11: ; /* Jump out to here if this rule does not match */


                MATCHT(ANTLR3_TOKEN_UP, NULL);
                if  (HASEXCEPTION())
                {
                    goto ruleformalParametersEx;
                }

            }


        }

    }

    // This is where rules clean up and exit
    //
    goto ruleformalParametersEx; /* Prevent compiler warnings */
    ruleformalParametersEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end formalParameters */

/**
 * $ANTLR start block
 * D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:51:1: block : ^( BLOCK ( statement )* ) ;
 */
static void
block(pGeoGenScriptDecls ctx)
{
    /* Initialize rule variables
     */

    {
        // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:51:6: ( ^( BLOCK ( statement )* ) )
        // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:51:8: ^( BLOCK ( statement )* )
        {
             MATCHT(BLOCK, &FOLLOW_BLOCK_in_block234);
            if  (HASEXCEPTION())
            {
                goto ruleblockEx;
            }


            if ( LA(1)==ANTLR3_TOKEN_DOWN ) {
                MATCHT(ANTLR3_TOKEN_DOWN, NULL);
                if  (HASEXCEPTION())
                {
                    goto ruleblockEx;
                }

                // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:51:16: ( statement )*

                for (;;)
                {
                    int alt12=2;
                    switch ( LA(1) )
                    {
                    case BLOCK:
                    case BREAK:
                    case CONTINUE:
                    case COORDINATE:
                    case FALSE_LIT:
                    case FOR:
                    case IDENTIFIER:
                    case IF:
                    case LEFT_BRACKET:
                    case LEFT_SQUARE_BRACKET:
                    case NUMBER:
                    case OPERATOR_ASSIGN:
                    case OPERATOR_ASSIGN_AND:
                    case OPERATOR_ASSIGN_DIVIDE:
                    case OPERATOR_ASSIGN_LSHIFT:
                    case OPERATOR_ASSIGN_MINUS:
                    case OPERATOR_ASSIGN_MODULO:
                    case OPERATOR_ASSIGN_OR:
                    case OPERATOR_ASSIGN_PLUS:
                    case OPERATOR_ASSIGN_RSHIFT:
                    case OPERATOR_ASSIGN_TIMES:
                    case OPERATOR_ASSIGN_XOR:
                    case OPERATOR_BIT_AND:
                    case OPERATOR_BIT_XOR:
                    case OPERATOR_DIVIDE:
                    case OPERATOR_DOT:
                    case OPERATOR_EQUAL_TO:
                    case OPERATOR_EXPR_IF:
                    case OPERATOR_GREATER_THAN:
                    case OPERATOR_GREATER_THAN_OR_EQUAL_TO:
                    case OPERATOR_IS:
                    case OPERATOR_LESS_THAN:
                    case OPERATOR_LESS_THAN_OR_EQUAL_TO:
                    case OPERATOR_LSHIFT:
                    case OPERATOR_MINUS:
                    case OPERATOR_MODULO:
                    case OPERATOR_NOT_EQUAL_TO:
                    case OPERATOR_PLUS:
                    case OPERATOR_REL_AND:
                    case OPERATOR_REL_OR:
                    case OPERATOR_RSHIFT:
                    case OPERATOR_TIMES:
                    case RETURN:
                    case STRING:
                    case SWITCH:
                    case TRUE_LIT:
                    case VAR:
                    case WHILE:
                    case YIELD:
                    	{
                    		alt12=1;
                    	}
                        break;

                    }

                    switch (alt12)
                    {
                	case 1:
                	    // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:51:16: statement
                	    {
                	        FOLLOWPUSH(FOLLOW_statement_in_block236);
                	        statement(ctx);

                	        FOLLOWPOP();
                	        if  (HASEXCEPTION())
                	        {
                	            goto ruleblockEx;
                	        }


                	    }
                	    break;

                	default:
                	    goto loop12;	/* break out of the loop */
                	    break;
                    }
                }
                loop12: ; /* Jump out to here if this rule does not match */


                MATCHT(ANTLR3_TOKEN_UP, NULL);
                if  (HASEXCEPTION())
                {
                    goto ruleblockEx;
                }

            }


        }

    }

    // This is where rules clean up and exit
    //
    goto ruleblockEx; /* Prevent compiler warnings */
    ruleblockEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end block */

/**
 * $ANTLR start statement
 * D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:53:1: statement : ( BREAK | CONTINUE | variableDeclaration | expression | yieldStatement | returnStatement | whileStatement | forStatement | ifStatement | switchStatement | block );
 */
static void
statement(pGeoGenScriptDecls ctx)
{
    /* Initialize rule variables
     */

    {
        {
            //  D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:53:10: ( BREAK | CONTINUE | variableDeclaration | expression | yieldStatement | returnStatement | whileStatement | forStatement | ifStatement | switchStatement | block )

            ANTLR3_UINT32 alt13;

            alt13=11;

            switch ( LA(1) )
            {
            case BREAK:
            	{
            		alt13=1;
            	}
                break;
            case CONTINUE:
            	{
            		alt13=2;
            	}
                break;
            case VAR:
            	{
            		alt13=3;
            	}
                break;
            case COORDINATE:
            case FALSE_LIT:
            case IDENTIFIER:
            case LEFT_BRACKET:
            case LEFT_SQUARE_BRACKET:
            case NUMBER:
            case OPERATOR_ASSIGN:
            case OPERATOR_ASSIGN_AND:
            case OPERATOR_ASSIGN_DIVIDE:
            case OPERATOR_ASSIGN_LSHIFT:
            case OPERATOR_ASSIGN_MINUS:
            case OPERATOR_ASSIGN_MODULO:
            case OPERATOR_ASSIGN_OR:
            case OPERATOR_ASSIGN_PLUS:
            case OPERATOR_ASSIGN_RSHIFT:
            case OPERATOR_ASSIGN_TIMES:
            case OPERATOR_ASSIGN_XOR:
            case OPERATOR_BIT_AND:
            case OPERATOR_BIT_XOR:
            case OPERATOR_DIVIDE:
            case OPERATOR_DOT:
            case OPERATOR_EQUAL_TO:
            case OPERATOR_EXPR_IF:
            case OPERATOR_GREATER_THAN:
            case OPERATOR_GREATER_THAN_OR_EQUAL_TO:
            case OPERATOR_IS:
            case OPERATOR_LESS_THAN:
            case OPERATOR_LESS_THAN_OR_EQUAL_TO:
            case OPERATOR_LSHIFT:
            case OPERATOR_MINUS:
            case OPERATOR_MODULO:
            case OPERATOR_NOT_EQUAL_TO:
            case OPERATOR_PLUS:
            case OPERATOR_REL_AND:
            case OPERATOR_REL_OR:
            case OPERATOR_RSHIFT:
            case OPERATOR_TIMES:
            case STRING:
            case TRUE_LIT:
            	{
            		alt13=4;
            	}
                break;
            case YIELD:
            	{
            		alt13=5;
            	}
                break;
            case RETURN:
            	{
            		alt13=6;
            	}
                break;
            case WHILE:
            	{
            		alt13=7;
            	}
                break;
            case FOR:
            	{
            		alt13=8;
            	}
                break;
            case IF:
            	{
            		alt13=9;
            	}
                break;
            case SWITCH:
            	{
            		alt13=10;
            	}
                break;
            case BLOCK:
            	{
            		alt13=11;
            	}
                break;

            default:
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 13;
                EXCEPTION->state        = 0;


                goto rulestatementEx;

            }

            switch (alt13)
            {
        	case 1:
        	    // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:54:5: BREAK
        	    {
        	         MATCHT(BREAK, &FOLLOW_BREAK_in_statement254);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulestatementEx;
        	        }


        	    }
        	    break;
        	case 2:
        	    // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:55:7: CONTINUE
        	    {
        	         MATCHT(CONTINUE, &FOLLOW_CONTINUE_in_statement262);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulestatementEx;
        	        }


        	    }
        	    break;
        	case 3:
        	    // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:56:7: variableDeclaration
        	    {
        	        FOLLOWPUSH(FOLLOW_variableDeclaration_in_statement270);
        	        variableDeclaration(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulestatementEx;
        	        }


        	    }
        	    break;
        	case 4:
        	    // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:57:7: expression
        	    {
        	        FOLLOWPUSH(FOLLOW_expression_in_statement278);
        	        expression(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulestatementEx;
        	        }


        	    }
        	    break;
        	case 5:
        	    // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:58:7: yieldStatement
        	    {
        	        FOLLOWPUSH(FOLLOW_yieldStatement_in_statement286);
        	        yieldStatement(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulestatementEx;
        	        }


        	    }
        	    break;
        	case 6:
        	    // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:59:7: returnStatement
        	    {
        	        FOLLOWPUSH(FOLLOW_returnStatement_in_statement294);
        	        returnStatement(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulestatementEx;
        	        }


        	    }
        	    break;
        	case 7:
        	    // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:60:7: whileStatement
        	    {
        	        FOLLOWPUSH(FOLLOW_whileStatement_in_statement302);
        	        whileStatement(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulestatementEx;
        	        }


        	    }
        	    break;
        	case 8:
        	    // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:61:7: forStatement
        	    {
        	        FOLLOWPUSH(FOLLOW_forStatement_in_statement310);
        	        forStatement(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulestatementEx;
        	        }


        	    }
        	    break;
        	case 9:
        	    // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:62:7: ifStatement
        	    {
        	        FOLLOWPUSH(FOLLOW_ifStatement_in_statement318);
        	        ifStatement(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulestatementEx;
        	        }


        	    }
        	    break;
        	case 10:
        	    // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:63:7: switchStatement
        	    {
        	        FOLLOWPUSH(FOLLOW_switchStatement_in_statement326);
        	        switchStatement(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulestatementEx;
        	        }


        	    }
        	    break;
        	case 11:
        	    // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:64:7: block
        	    {
        	        FOLLOWPUSH(FOLLOW_block_in_statement334);
        	        block(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulestatementEx;
        	        }


        	    }
        	    break;

            }
        }
    }

    // This is where rules clean up and exit
    //
    goto rulestatementEx; /* Prevent compiler warnings */
    rulestatementEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end statement */

/**
 * $ANTLR start variableDeclaration
 * D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:66:1: variableDeclaration : ^( 'var' IDENTIFIER ( expression )? ) ;
 */
static void
variableDeclaration(pGeoGenScriptDecls ctx)
{
    /* Initialize rule variables
     */

    {
        // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:66:20: ( ^( 'var' IDENTIFIER ( expression )? ) )
        // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:66:22: ^( 'var' IDENTIFIER ( expression )? )
        {
             MATCHT(VAR, &FOLLOW_VAR_in_variableDeclaration346);
            if  (HASEXCEPTION())
            {
                goto rulevariableDeclarationEx;
            }


            MATCHT(ANTLR3_TOKEN_DOWN, NULL);
            if  (HASEXCEPTION())
            {
                goto rulevariableDeclarationEx;
            }

             MATCHT(IDENTIFIER, &FOLLOW_IDENTIFIER_in_variableDeclaration348);
            if  (HASEXCEPTION())
            {
                goto rulevariableDeclarationEx;
            }


            // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:66:41: ( expression )?
            {
                int alt14=2;
                switch ( LA(1) )
                {
                    case COORDINATE:
                    case FALSE_LIT:
                    case IDENTIFIER:
                    case LEFT_BRACKET:
                    case LEFT_SQUARE_BRACKET:
                    case NUMBER:
                    case OPERATOR_ASSIGN:
                    case OPERATOR_ASSIGN_AND:
                    case OPERATOR_ASSIGN_DIVIDE:
                    case OPERATOR_ASSIGN_LSHIFT:
                    case OPERATOR_ASSIGN_MINUS:
                    case OPERATOR_ASSIGN_MODULO:
                    case OPERATOR_ASSIGN_OR:
                    case OPERATOR_ASSIGN_PLUS:
                    case OPERATOR_ASSIGN_RSHIFT:
                    case OPERATOR_ASSIGN_TIMES:
                    case OPERATOR_ASSIGN_XOR:
                    case OPERATOR_BIT_AND:
                    case OPERATOR_BIT_XOR:
                    case OPERATOR_DIVIDE:
                    case OPERATOR_DOT:
                    case OPERATOR_EQUAL_TO:
                    case OPERATOR_EXPR_IF:
                    case OPERATOR_GREATER_THAN:
                    case OPERATOR_GREATER_THAN_OR_EQUAL_TO:
                    case OPERATOR_IS:
                    case OPERATOR_LESS_THAN:
                    case OPERATOR_LESS_THAN_OR_EQUAL_TO:
                    case OPERATOR_LSHIFT:
                    case OPERATOR_MINUS:
                    case OPERATOR_MODULO:
                    case OPERATOR_NOT_EQUAL_TO:
                    case OPERATOR_PLUS:
                    case OPERATOR_REL_AND:
                    case OPERATOR_REL_OR:
                    case OPERATOR_RSHIFT:
                    case OPERATOR_TIMES:
                    case STRING:
                    case TRUE_LIT:
                    	{
                    		alt14=1;
                    	}
                        break;
                }

                switch (alt14)
                {
            	case 1:
            	    // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:66:41: expression
            	    {
            	        FOLLOWPUSH(FOLLOW_expression_in_variableDeclaration350);
            	        expression(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulevariableDeclarationEx;
            	        }


            	    }
            	    break;

                }
            }

            MATCHT(ANTLR3_TOKEN_UP, NULL);
            if  (HASEXCEPTION())
            {
                goto rulevariableDeclarationEx;
            }



        }

    }

    // This is where rules clean up and exit
    //
    goto rulevariableDeclarationEx; /* Prevent compiler warnings */
    rulevariableDeclarationEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end variableDeclaration */

/**
 * $ANTLR start yieldStatement
 * D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:68:1: yieldStatement : ^( YIELD expression ( STRING )? ) ;
 */
static void
yieldStatement(pGeoGenScriptDecls ctx)
{
    /* Initialize rule variables
     */

    {
        // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:68:15: ( ^( YIELD expression ( STRING )? ) )
        // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:68:17: ^( YIELD expression ( STRING )? )
        {
             MATCHT(YIELD, &FOLLOW_YIELD_in_yieldStatement360);
            if  (HASEXCEPTION())
            {
                goto ruleyieldStatementEx;
            }


            MATCHT(ANTLR3_TOKEN_DOWN, NULL);
            if  (HASEXCEPTION())
            {
                goto ruleyieldStatementEx;
            }

            FOLLOWPUSH(FOLLOW_expression_in_yieldStatement362);
            expression(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleyieldStatementEx;
            }


            // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:68:36: ( STRING )?
            {
                int alt15=2;
                switch ( LA(1) )
                {
                    case STRING:
                    	{
                    		alt15=1;
                    	}
                        break;
                }

                switch (alt15)
                {
            	case 1:
            	    // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:68:36: STRING
            	    {
            	         MATCHT(STRING, &FOLLOW_STRING_in_yieldStatement364);
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleyieldStatementEx;
            	        }


            	    }
            	    break;

                }
            }

            MATCHT(ANTLR3_TOKEN_UP, NULL);
            if  (HASEXCEPTION())
            {
                goto ruleyieldStatementEx;
            }



        }

    }

    // This is where rules clean up and exit
    //
    goto ruleyieldStatementEx; /* Prevent compiler warnings */
    ruleyieldStatementEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end yieldStatement */

/**
 * $ANTLR start returnStatement
 * D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:71:1: returnStatement : ^( RETURN ( expression )? ) ;
 */
static void
returnStatement(pGeoGenScriptDecls ctx)
{
    /* Initialize rule variables
     */

    {
        // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:71:16: ( ^( RETURN ( expression )? ) )
        // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:71:18: ^( RETURN ( expression )? )
        {
             MATCHT(RETURN, &FOLLOW_RETURN_in_returnStatement375);
            if  (HASEXCEPTION())
            {
                goto rulereturnStatementEx;
            }


            if ( LA(1)==ANTLR3_TOKEN_DOWN ) {
                MATCHT(ANTLR3_TOKEN_DOWN, NULL);
                if  (HASEXCEPTION())
                {
                    goto rulereturnStatementEx;
                }

                // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:71:27: ( expression )?
                {
                    int alt16=2;
                    switch ( LA(1) )
                    {
                        case COORDINATE:
                        case FALSE_LIT:
                        case IDENTIFIER:
                        case LEFT_BRACKET:
                        case LEFT_SQUARE_BRACKET:
                        case NUMBER:
                        case OPERATOR_ASSIGN:
                        case OPERATOR_ASSIGN_AND:
                        case OPERATOR_ASSIGN_DIVIDE:
                        case OPERATOR_ASSIGN_LSHIFT:
                        case OPERATOR_ASSIGN_MINUS:
                        case OPERATOR_ASSIGN_MODULO:
                        case OPERATOR_ASSIGN_OR:
                        case OPERATOR_ASSIGN_PLUS:
                        case OPERATOR_ASSIGN_RSHIFT:
                        case OPERATOR_ASSIGN_TIMES:
                        case OPERATOR_ASSIGN_XOR:
                        case OPERATOR_BIT_AND:
                        case OPERATOR_BIT_XOR:
                        case OPERATOR_DIVIDE:
                        case OPERATOR_DOT:
                        case OPERATOR_EQUAL_TO:
                        case OPERATOR_EXPR_IF:
                        case OPERATOR_GREATER_THAN:
                        case OPERATOR_GREATER_THAN_OR_EQUAL_TO:
                        case OPERATOR_IS:
                        case OPERATOR_LESS_THAN:
                        case OPERATOR_LESS_THAN_OR_EQUAL_TO:
                        case OPERATOR_LSHIFT:
                        case OPERATOR_MINUS:
                        case OPERATOR_MODULO:
                        case OPERATOR_NOT_EQUAL_TO:
                        case OPERATOR_PLUS:
                        case OPERATOR_REL_AND:
                        case OPERATOR_REL_OR:
                        case OPERATOR_RSHIFT:
                        case OPERATOR_TIMES:
                        case STRING:
                        case TRUE_LIT:
                        	{
                        		alt16=1;
                        	}
                            break;
                    }

                    switch (alt16)
                    {
                	case 1:
                	    // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:71:27: expression
                	    {
                	        FOLLOWPUSH(FOLLOW_expression_in_returnStatement377);
                	        expression(ctx);

                	        FOLLOWPOP();
                	        if  (HASEXCEPTION())
                	        {
                	            goto rulereturnStatementEx;
                	        }


                	    }
                	    break;

                    }
                }

                MATCHT(ANTLR3_TOKEN_UP, NULL);
                if  (HASEXCEPTION())
                {
                    goto rulereturnStatementEx;
                }

            }


        }

    }

    // This is where rules clean up and exit
    //
    goto rulereturnStatementEx; /* Prevent compiler warnings */
    rulereturnStatementEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end returnStatement */

/**
 * $ANTLR start whileStatement
 * D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:73:1: whileStatement : ^( WHILE expression statement ) ;
 */
static void
whileStatement(pGeoGenScriptDecls ctx)
{
    /* Initialize rule variables
     */

    {
        // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:73:15: ( ^( WHILE expression statement ) )
        // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:73:17: ^( WHILE expression statement )
        {
             MATCHT(WHILE, &FOLLOW_WHILE_in_whileStatement387);
            if  (HASEXCEPTION())
            {
                goto rulewhileStatementEx;
            }


            MATCHT(ANTLR3_TOKEN_DOWN, NULL);
            if  (HASEXCEPTION())
            {
                goto rulewhileStatementEx;
            }

            FOLLOWPUSH(FOLLOW_expression_in_whileStatement389);
            expression(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulewhileStatementEx;
            }


            FOLLOWPUSH(FOLLOW_statement_in_whileStatement391);
            statement(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulewhileStatementEx;
            }


            MATCHT(ANTLR3_TOKEN_UP, NULL);
            if  (HASEXCEPTION())
            {
                goto rulewhileStatementEx;
            }



        }

    }

    // This is where rules clean up and exit
    //
    goto rulewhileStatementEx; /* Prevent compiler warnings */
    rulewhileStatementEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end whileStatement */

/**
 * $ANTLR start forStatement
 * D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:75:1: forStatement : ^( FOR ^( INITIALIZATION_EXPRESSION ( initExpression )? ) ^( CONDITION_EXPRESSION ( expression )? ) ^( INCREMENT_EXPRESSION ( expression )? ) statement ) ;
 */
static void
forStatement(pGeoGenScriptDecls ctx)
{
    /* Initialize rule variables
     */

    {
        // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:75:13: ( ^( FOR ^( INITIALIZATION_EXPRESSION ( initExpression )? ) ^( CONDITION_EXPRESSION ( expression )? ) ^( INCREMENT_EXPRESSION ( expression )? ) statement ) )
        // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:75:15: ^( FOR ^( INITIALIZATION_EXPRESSION ( initExpression )? ) ^( CONDITION_EXPRESSION ( expression )? ) ^( INCREMENT_EXPRESSION ( expression )? ) statement )
        {
             MATCHT(FOR, &FOLLOW_FOR_in_forStatement401);
            if  (HASEXCEPTION())
            {
                goto ruleforStatementEx;
            }


            MATCHT(ANTLR3_TOKEN_DOWN, NULL);
            if  (HASEXCEPTION())
            {
                goto ruleforStatementEx;
            }

             MATCHT(INITIALIZATION_EXPRESSION, &FOLLOW_INITIALIZATION_EXPRESSION_in_forStatement404);
            if  (HASEXCEPTION())
            {
                goto ruleforStatementEx;
            }


            if ( LA(1)==ANTLR3_TOKEN_DOWN ) {
                MATCHT(ANTLR3_TOKEN_DOWN, NULL);
                if  (HASEXCEPTION())
                {
                    goto ruleforStatementEx;
                }

                // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:75:49: ( initExpression )?
                {
                    int alt17=2;
                    switch ( LA(1) )
                    {
                        case COORDINATE:
                        case FALSE_LIT:
                        case IDENTIFIER:
                        case LEFT_BRACKET:
                        case LEFT_SQUARE_BRACKET:
                        case NUMBER:
                        case OPERATOR_ASSIGN:
                        case OPERATOR_ASSIGN_AND:
                        case OPERATOR_ASSIGN_DIVIDE:
                        case OPERATOR_ASSIGN_LSHIFT:
                        case OPERATOR_ASSIGN_MINUS:
                        case OPERATOR_ASSIGN_MODULO:
                        case OPERATOR_ASSIGN_OR:
                        case OPERATOR_ASSIGN_PLUS:
                        case OPERATOR_ASSIGN_RSHIFT:
                        case OPERATOR_ASSIGN_TIMES:
                        case OPERATOR_ASSIGN_XOR:
                        case OPERATOR_BIT_AND:
                        case OPERATOR_BIT_XOR:
                        case OPERATOR_DIVIDE:
                        case OPERATOR_DOT:
                        case OPERATOR_EQUAL_TO:
                        case OPERATOR_EXPR_IF:
                        case OPERATOR_GREATER_THAN:
                        case OPERATOR_GREATER_THAN_OR_EQUAL_TO:
                        case OPERATOR_IS:
                        case OPERATOR_LESS_THAN:
                        case OPERATOR_LESS_THAN_OR_EQUAL_TO:
                        case OPERATOR_LSHIFT:
                        case OPERATOR_MINUS:
                        case OPERATOR_MODULO:
                        case OPERATOR_NOT_EQUAL_TO:
                        case OPERATOR_PLUS:
                        case OPERATOR_REL_AND:
                        case OPERATOR_REL_OR:
                        case OPERATOR_RSHIFT:
                        case OPERATOR_TIMES:
                        case STRING:
                        case TRUE_LIT:
                        case VAR:
                        	{
                        		alt17=1;
                        	}
                            break;
                    }

                    switch (alt17)
                    {
                	case 1:
                	    // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:75:49: initExpression
                	    {
                	        FOLLOWPUSH(FOLLOW_initExpression_in_forStatement406);
                	        initExpression(ctx);

                	        FOLLOWPOP();
                	        if  (HASEXCEPTION())
                	        {
                	            goto ruleforStatementEx;
                	        }


                	    }
                	    break;

                    }
                }

                MATCHT(ANTLR3_TOKEN_UP, NULL);
                if  (HASEXCEPTION())
                {
                    goto ruleforStatementEx;
                }

            }


             MATCHT(CONDITION_EXPRESSION, &FOLLOW_CONDITION_EXPRESSION_in_forStatement411);
            if  (HASEXCEPTION())
            {
                goto ruleforStatementEx;
            }


            if ( LA(1)==ANTLR3_TOKEN_DOWN ) {
                MATCHT(ANTLR3_TOKEN_DOWN, NULL);
                if  (HASEXCEPTION())
                {
                    goto ruleforStatementEx;
                }

                // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:75:89: ( expression )?
                {
                    int alt18=2;
                    switch ( LA(1) )
                    {
                        case COORDINATE:
                        case FALSE_LIT:
                        case IDENTIFIER:
                        case LEFT_BRACKET:
                        case LEFT_SQUARE_BRACKET:
                        case NUMBER:
                        case OPERATOR_ASSIGN:
                        case OPERATOR_ASSIGN_AND:
                        case OPERATOR_ASSIGN_DIVIDE:
                        case OPERATOR_ASSIGN_LSHIFT:
                        case OPERATOR_ASSIGN_MINUS:
                        case OPERATOR_ASSIGN_MODULO:
                        case OPERATOR_ASSIGN_OR:
                        case OPERATOR_ASSIGN_PLUS:
                        case OPERATOR_ASSIGN_RSHIFT:
                        case OPERATOR_ASSIGN_TIMES:
                        case OPERATOR_ASSIGN_XOR:
                        case OPERATOR_BIT_AND:
                        case OPERATOR_BIT_XOR:
                        case OPERATOR_DIVIDE:
                        case OPERATOR_DOT:
                        case OPERATOR_EQUAL_TO:
                        case OPERATOR_EXPR_IF:
                        case OPERATOR_GREATER_THAN:
                        case OPERATOR_GREATER_THAN_OR_EQUAL_TO:
                        case OPERATOR_IS:
                        case OPERATOR_LESS_THAN:
                        case OPERATOR_LESS_THAN_OR_EQUAL_TO:
                        case OPERATOR_LSHIFT:
                        case OPERATOR_MINUS:
                        case OPERATOR_MODULO:
                        case OPERATOR_NOT_EQUAL_TO:
                        case OPERATOR_PLUS:
                        case OPERATOR_REL_AND:
                        case OPERATOR_REL_OR:
                        case OPERATOR_RSHIFT:
                        case OPERATOR_TIMES:
                        case STRING:
                        case TRUE_LIT:
                        	{
                        		alt18=1;
                        	}
                            break;
                    }

                    switch (alt18)
                    {
                	case 1:
                	    // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:75:89: expression
                	    {
                	        FOLLOWPUSH(FOLLOW_expression_in_forStatement413);
                	        expression(ctx);

                	        FOLLOWPOP();
                	        if  (HASEXCEPTION())
                	        {
                	            goto ruleforStatementEx;
                	        }


                	    }
                	    break;

                    }
                }

                MATCHT(ANTLR3_TOKEN_UP, NULL);
                if  (HASEXCEPTION())
                {
                    goto ruleforStatementEx;
                }

            }


             MATCHT(INCREMENT_EXPRESSION, &FOLLOW_INCREMENT_EXPRESSION_in_forStatement418);
            if  (HASEXCEPTION())
            {
                goto ruleforStatementEx;
            }


            if ( LA(1)==ANTLR3_TOKEN_DOWN ) {
                MATCHT(ANTLR3_TOKEN_DOWN, NULL);
                if  (HASEXCEPTION())
                {
                    goto ruleforStatementEx;
                }

                // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:75:125: ( expression )?
                {
                    int alt19=2;
                    switch ( LA(1) )
                    {
                        case COORDINATE:
                        case FALSE_LIT:
                        case IDENTIFIER:
                        case LEFT_BRACKET:
                        case LEFT_SQUARE_BRACKET:
                        case NUMBER:
                        case OPERATOR_ASSIGN:
                        case OPERATOR_ASSIGN_AND:
                        case OPERATOR_ASSIGN_DIVIDE:
                        case OPERATOR_ASSIGN_LSHIFT:
                        case OPERATOR_ASSIGN_MINUS:
                        case OPERATOR_ASSIGN_MODULO:
                        case OPERATOR_ASSIGN_OR:
                        case OPERATOR_ASSIGN_PLUS:
                        case OPERATOR_ASSIGN_RSHIFT:
                        case OPERATOR_ASSIGN_TIMES:
                        case OPERATOR_ASSIGN_XOR:
                        case OPERATOR_BIT_AND:
                        case OPERATOR_BIT_XOR:
                        case OPERATOR_DIVIDE:
                        case OPERATOR_DOT:
                        case OPERATOR_EQUAL_TO:
                        case OPERATOR_EXPR_IF:
                        case OPERATOR_GREATER_THAN:
                        case OPERATOR_GREATER_THAN_OR_EQUAL_TO:
                        case OPERATOR_IS:
                        case OPERATOR_LESS_THAN:
                        case OPERATOR_LESS_THAN_OR_EQUAL_TO:
                        case OPERATOR_LSHIFT:
                        case OPERATOR_MINUS:
                        case OPERATOR_MODULO:
                        case OPERATOR_NOT_EQUAL_TO:
                        case OPERATOR_PLUS:
                        case OPERATOR_REL_AND:
                        case OPERATOR_REL_OR:
                        case OPERATOR_RSHIFT:
                        case OPERATOR_TIMES:
                        case STRING:
                        case TRUE_LIT:
                        	{
                        		alt19=1;
                        	}
                            break;
                    }

                    switch (alt19)
                    {
                	case 1:
                	    // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:75:125: expression
                	    {
                	        FOLLOWPUSH(FOLLOW_expression_in_forStatement420);
                	        expression(ctx);

                	        FOLLOWPOP();
                	        if  (HASEXCEPTION())
                	        {
                	            goto ruleforStatementEx;
                	        }


                	    }
                	    break;

                    }
                }

                MATCHT(ANTLR3_TOKEN_UP, NULL);
                if  (HASEXCEPTION())
                {
                    goto ruleforStatementEx;
                }

            }


            FOLLOWPUSH(FOLLOW_statement_in_forStatement424);
            statement(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleforStatementEx;
            }


            MATCHT(ANTLR3_TOKEN_UP, NULL);
            if  (HASEXCEPTION())
            {
                goto ruleforStatementEx;
            }



        }

    }

    // This is where rules clean up and exit
    //
    goto ruleforStatementEx; /* Prevent compiler warnings */
    ruleforStatementEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end forStatement */

/**
 * $ANTLR start initExpression
 * D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:77:1: initExpression : ( ^( 'var' IDENTIFIER expression ) | expression );
 */
static void
initExpression(pGeoGenScriptDecls ctx)
{
    /* Initialize rule variables
     */

    {
        {
            //  D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:77:15: ( ^( 'var' IDENTIFIER expression ) | expression )

            ANTLR3_UINT32 alt20;

            alt20=2;

            switch ( LA(1) )
            {
            case VAR:
            	{
            		alt20=1;
            	}
                break;
            case COORDINATE:
            case FALSE_LIT:
            case IDENTIFIER:
            case LEFT_BRACKET:
            case LEFT_SQUARE_BRACKET:
            case NUMBER:
            case OPERATOR_ASSIGN:
            case OPERATOR_ASSIGN_AND:
            case OPERATOR_ASSIGN_DIVIDE:
            case OPERATOR_ASSIGN_LSHIFT:
            case OPERATOR_ASSIGN_MINUS:
            case OPERATOR_ASSIGN_MODULO:
            case OPERATOR_ASSIGN_OR:
            case OPERATOR_ASSIGN_PLUS:
            case OPERATOR_ASSIGN_RSHIFT:
            case OPERATOR_ASSIGN_TIMES:
            case OPERATOR_ASSIGN_XOR:
            case OPERATOR_BIT_AND:
            case OPERATOR_BIT_XOR:
            case OPERATOR_DIVIDE:
            case OPERATOR_DOT:
            case OPERATOR_EQUAL_TO:
            case OPERATOR_EXPR_IF:
            case OPERATOR_GREATER_THAN:
            case OPERATOR_GREATER_THAN_OR_EQUAL_TO:
            case OPERATOR_IS:
            case OPERATOR_LESS_THAN:
            case OPERATOR_LESS_THAN_OR_EQUAL_TO:
            case OPERATOR_LSHIFT:
            case OPERATOR_MINUS:
            case OPERATOR_MODULO:
            case OPERATOR_NOT_EQUAL_TO:
            case OPERATOR_PLUS:
            case OPERATOR_REL_AND:
            case OPERATOR_REL_OR:
            case OPERATOR_RSHIFT:
            case OPERATOR_TIMES:
            case STRING:
            case TRUE_LIT:
            	{
            		alt20=2;
            	}
                break;

            default:
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 20;
                EXCEPTION->state        = 0;


                goto ruleinitExpressionEx;

            }

            switch (alt20)
            {
        	case 1:
        	    // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:78:5: ^( 'var' IDENTIFIER expression )
        	    {
        	         MATCHT(VAR, &FOLLOW_VAR_in_initExpression438);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleinitExpressionEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_DOWN, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleinitExpressionEx;
        	        }

        	         MATCHT(IDENTIFIER, &FOLLOW_IDENTIFIER_in_initExpression440);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleinitExpressionEx;
        	        }


        	        FOLLOWPUSH(FOLLOW_expression_in_initExpression442);
        	        expression(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleinitExpressionEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_UP, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleinitExpressionEx;
        	        }



        	    }
        	    break;
        	case 2:
        	    // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:79:7: expression
        	    {
        	        FOLLOWPUSH(FOLLOW_expression_in_initExpression451);
        	        expression(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleinitExpressionEx;
        	        }


        	    }
        	    break;

            }
        }
    }

    // This is where rules clean up and exit
    //
    goto ruleinitExpressionEx; /* Prevent compiler warnings */
    ruleinitExpressionEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end initExpression */

/**
 * $ANTLR start ifStatement
 * D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:81:1: ifStatement : ^( IF expression statement ( statement )? ) ;
 */
static void
ifStatement(pGeoGenScriptDecls ctx)
{
    /* Initialize rule variables
     */

    {
        // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:81:12: ( ^( IF expression statement ( statement )? ) )
        // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:81:14: ^( IF expression statement ( statement )? )
        {
             MATCHT(IF, &FOLLOW_IF_in_ifStatement459);
            if  (HASEXCEPTION())
            {
                goto ruleifStatementEx;
            }


            MATCHT(ANTLR3_TOKEN_DOWN, NULL);
            if  (HASEXCEPTION())
            {
                goto ruleifStatementEx;
            }

            FOLLOWPUSH(FOLLOW_expression_in_ifStatement461);
            expression(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleifStatementEx;
            }


            FOLLOWPUSH(FOLLOW_statement_in_ifStatement463);
            statement(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleifStatementEx;
            }


            // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:81:40: ( statement )?
            {
                int alt21=2;
                switch ( LA(1) )
                {
                    case BLOCK:
                    case BREAK:
                    case CONTINUE:
                    case COORDINATE:
                    case FALSE_LIT:
                    case FOR:
                    case IDENTIFIER:
                    case IF:
                    case LEFT_BRACKET:
                    case LEFT_SQUARE_BRACKET:
                    case NUMBER:
                    case OPERATOR_ASSIGN:
                    case OPERATOR_ASSIGN_AND:
                    case OPERATOR_ASSIGN_DIVIDE:
                    case OPERATOR_ASSIGN_LSHIFT:
                    case OPERATOR_ASSIGN_MINUS:
                    case OPERATOR_ASSIGN_MODULO:
                    case OPERATOR_ASSIGN_OR:
                    case OPERATOR_ASSIGN_PLUS:
                    case OPERATOR_ASSIGN_RSHIFT:
                    case OPERATOR_ASSIGN_TIMES:
                    case OPERATOR_ASSIGN_XOR:
                    case OPERATOR_BIT_AND:
                    case OPERATOR_BIT_XOR:
                    case OPERATOR_DIVIDE:
                    case OPERATOR_DOT:
                    case OPERATOR_EQUAL_TO:
                    case OPERATOR_EXPR_IF:
                    case OPERATOR_GREATER_THAN:
                    case OPERATOR_GREATER_THAN_OR_EQUAL_TO:
                    case OPERATOR_IS:
                    case OPERATOR_LESS_THAN:
                    case OPERATOR_LESS_THAN_OR_EQUAL_TO:
                    case OPERATOR_LSHIFT:
                    case OPERATOR_MINUS:
                    case OPERATOR_MODULO:
                    case OPERATOR_NOT_EQUAL_TO:
                    case OPERATOR_PLUS:
                    case OPERATOR_REL_AND:
                    case OPERATOR_REL_OR:
                    case OPERATOR_RSHIFT:
                    case OPERATOR_TIMES:
                    case RETURN:
                    case STRING:
                    case SWITCH:
                    case TRUE_LIT:
                    case VAR:
                    case WHILE:
                    case YIELD:
                    	{
                    		alt21=1;
                    	}
                        break;
                }

                switch (alt21)
                {
            	case 1:
            	    // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:81:40: statement
            	    {
            	        FOLLOWPUSH(FOLLOW_statement_in_ifStatement465);
            	        statement(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleifStatementEx;
            	        }


            	    }
            	    break;

                }
            }

            MATCHT(ANTLR3_TOKEN_UP, NULL);
            if  (HASEXCEPTION())
            {
                goto ruleifStatementEx;
            }



        }

    }

    // This is where rules clean up and exit
    //
    goto ruleifStatementEx; /* Prevent compiler warnings */
    ruleifStatementEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end ifStatement */

/**
 * $ANTLR start switchStatement
 * D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:83:1: switchStatement : ^( SWITCH expression ( normalCase )* ( defaultCase )? ) ;
 */
static void
switchStatement(pGeoGenScriptDecls ctx)
{
    /* Initialize rule variables
     */

    {
        // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:83:16: ( ^( SWITCH expression ( normalCase )* ( defaultCase )? ) )
        // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:83:18: ^( SWITCH expression ( normalCase )* ( defaultCase )? )
        {
             MATCHT(SWITCH, &FOLLOW_SWITCH_in_switchStatement475);
            if  (HASEXCEPTION())
            {
                goto ruleswitchStatementEx;
            }


            MATCHT(ANTLR3_TOKEN_DOWN, NULL);
            if  (HASEXCEPTION())
            {
                goto ruleswitchStatementEx;
            }

            FOLLOWPUSH(FOLLOW_expression_in_switchStatement477);
            expression(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleswitchStatementEx;
            }


            // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:83:38: ( normalCase )*

            for (;;)
            {
                int alt22=2;
                switch ( LA(1) )
                {
                case CASE:
                	{
                		alt22=1;
                	}
                    break;

                }

                switch (alt22)
                {
            	case 1:
            	    // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:83:38: normalCase
            	    {
            	        FOLLOWPUSH(FOLLOW_normalCase_in_switchStatement479);
            	        normalCase(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleswitchStatementEx;
            	        }


            	    }
            	    break;

            	default:
            	    goto loop22;	/* break out of the loop */
            	    break;
                }
            }
            loop22: ; /* Jump out to here if this rule does not match */


            // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:83:50: ( defaultCase )?
            {
                int alt23=2;
                switch ( LA(1) )
                {
                    case DEFAULT:
                    	{
                    		alt23=1;
                    	}
                        break;
                }

                switch (alt23)
                {
            	case 1:
            	    // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:83:50: defaultCase
            	    {
            	        FOLLOWPUSH(FOLLOW_defaultCase_in_switchStatement482);
            	        defaultCase(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleswitchStatementEx;
            	        }


            	    }
            	    break;

                }
            }

            MATCHT(ANTLR3_TOKEN_UP, NULL);
            if  (HASEXCEPTION())
            {
                goto ruleswitchStatementEx;
            }



        }

    }

    // This is where rules clean up and exit
    //
    goto ruleswitchStatementEx; /* Prevent compiler warnings */
    ruleswitchStatementEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end switchStatement */

/**
 * $ANTLR start normalCase
 * D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:85:1: normalCase : ^( CASE label ^( BLOCK ( statement )* ) ) ;
 */
static void
normalCase(pGeoGenScriptDecls ctx)
{
    /* Initialize rule variables
     */

    {
        // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:85:11: ( ^( CASE label ^( BLOCK ( statement )* ) ) )
        // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:85:13: ^( CASE label ^( BLOCK ( statement )* ) )
        {
             MATCHT(CASE, &FOLLOW_CASE_in_normalCase492);
            if  (HASEXCEPTION())
            {
                goto rulenormalCaseEx;
            }


            MATCHT(ANTLR3_TOKEN_DOWN, NULL);
            if  (HASEXCEPTION())
            {
                goto rulenormalCaseEx;
            }

            FOLLOWPUSH(FOLLOW_label_in_normalCase494);
            label(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulenormalCaseEx;
            }


             MATCHT(BLOCK, &FOLLOW_BLOCK_in_normalCase497);
            if  (HASEXCEPTION())
            {
                goto rulenormalCaseEx;
            }


            if ( LA(1)==ANTLR3_TOKEN_DOWN ) {
                MATCHT(ANTLR3_TOKEN_DOWN, NULL);
                if  (HASEXCEPTION())
                {
                    goto rulenormalCaseEx;
                }

                // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:85:34: ( statement )*

                for (;;)
                {
                    int alt24=2;
                    switch ( LA(1) )
                    {
                    case BLOCK:
                    case BREAK:
                    case CONTINUE:
                    case COORDINATE:
                    case FALSE_LIT:
                    case FOR:
                    case IDENTIFIER:
                    case IF:
                    case LEFT_BRACKET:
                    case LEFT_SQUARE_BRACKET:
                    case NUMBER:
                    case OPERATOR_ASSIGN:
                    case OPERATOR_ASSIGN_AND:
                    case OPERATOR_ASSIGN_DIVIDE:
                    case OPERATOR_ASSIGN_LSHIFT:
                    case OPERATOR_ASSIGN_MINUS:
                    case OPERATOR_ASSIGN_MODULO:
                    case OPERATOR_ASSIGN_OR:
                    case OPERATOR_ASSIGN_PLUS:
                    case OPERATOR_ASSIGN_RSHIFT:
                    case OPERATOR_ASSIGN_TIMES:
                    case OPERATOR_ASSIGN_XOR:
                    case OPERATOR_BIT_AND:
                    case OPERATOR_BIT_XOR:
                    case OPERATOR_DIVIDE:
                    case OPERATOR_DOT:
                    case OPERATOR_EQUAL_TO:
                    case OPERATOR_EXPR_IF:
                    case OPERATOR_GREATER_THAN:
                    case OPERATOR_GREATER_THAN_OR_EQUAL_TO:
                    case OPERATOR_IS:
                    case OPERATOR_LESS_THAN:
                    case OPERATOR_LESS_THAN_OR_EQUAL_TO:
                    case OPERATOR_LSHIFT:
                    case OPERATOR_MINUS:
                    case OPERATOR_MODULO:
                    case OPERATOR_NOT_EQUAL_TO:
                    case OPERATOR_PLUS:
                    case OPERATOR_REL_AND:
                    case OPERATOR_REL_OR:
                    case OPERATOR_RSHIFT:
                    case OPERATOR_TIMES:
                    case RETURN:
                    case STRING:
                    case SWITCH:
                    case TRUE_LIT:
                    case VAR:
                    case WHILE:
                    case YIELD:
                    	{
                    		alt24=1;
                    	}
                        break;

                    }

                    switch (alt24)
                    {
                	case 1:
                	    // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:85:34: statement
                	    {
                	        FOLLOWPUSH(FOLLOW_statement_in_normalCase499);
                	        statement(ctx);

                	        FOLLOWPOP();
                	        if  (HASEXCEPTION())
                	        {
                	            goto rulenormalCaseEx;
                	        }


                	    }
                	    break;

                	default:
                	    goto loop24;	/* break out of the loop */
                	    break;
                    }
                }
                loop24: ; /* Jump out to here if this rule does not match */


                MATCHT(ANTLR3_TOKEN_UP, NULL);
                if  (HASEXCEPTION())
                {
                    goto rulenormalCaseEx;
                }

            }


            MATCHT(ANTLR3_TOKEN_UP, NULL);
            if  (HASEXCEPTION())
            {
                goto rulenormalCaseEx;
            }



        }

    }

    // This is where rules clean up and exit
    //
    goto rulenormalCaseEx; /* Prevent compiler warnings */
    rulenormalCaseEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end normalCase */

/**
 * $ANTLR start defaultCase
 * D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:86:1: defaultCase : ^( DEFAULT ^( BLOCK ( statement )* ) ) ;
 */
static void
defaultCase(pGeoGenScriptDecls ctx)
{
    /* Initialize rule variables
     */

    {
        // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:86:12: ( ^( DEFAULT ^( BLOCK ( statement )* ) ) )
        // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:86:14: ^( DEFAULT ^( BLOCK ( statement )* ) )
        {
             MATCHT(DEFAULT, &FOLLOW_DEFAULT_in_defaultCase509);
            if  (HASEXCEPTION())
            {
                goto ruledefaultCaseEx;
            }


            MATCHT(ANTLR3_TOKEN_DOWN, NULL);
            if  (HASEXCEPTION())
            {
                goto ruledefaultCaseEx;
            }

             MATCHT(BLOCK, &FOLLOW_BLOCK_in_defaultCase512);
            if  (HASEXCEPTION())
            {
                goto ruledefaultCaseEx;
            }


            if ( LA(1)==ANTLR3_TOKEN_DOWN ) {
                MATCHT(ANTLR3_TOKEN_DOWN, NULL);
                if  (HASEXCEPTION())
                {
                    goto ruledefaultCaseEx;
                }

                // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:86:32: ( statement )*

                for (;;)
                {
                    int alt25=2;
                    switch ( LA(1) )
                    {
                    case BLOCK:
                    case BREAK:
                    case CONTINUE:
                    case COORDINATE:
                    case FALSE_LIT:
                    case FOR:
                    case IDENTIFIER:
                    case IF:
                    case LEFT_BRACKET:
                    case LEFT_SQUARE_BRACKET:
                    case NUMBER:
                    case OPERATOR_ASSIGN:
                    case OPERATOR_ASSIGN_AND:
                    case OPERATOR_ASSIGN_DIVIDE:
                    case OPERATOR_ASSIGN_LSHIFT:
                    case OPERATOR_ASSIGN_MINUS:
                    case OPERATOR_ASSIGN_MODULO:
                    case OPERATOR_ASSIGN_OR:
                    case OPERATOR_ASSIGN_PLUS:
                    case OPERATOR_ASSIGN_RSHIFT:
                    case OPERATOR_ASSIGN_TIMES:
                    case OPERATOR_ASSIGN_XOR:
                    case OPERATOR_BIT_AND:
                    case OPERATOR_BIT_XOR:
                    case OPERATOR_DIVIDE:
                    case OPERATOR_DOT:
                    case OPERATOR_EQUAL_TO:
                    case OPERATOR_EXPR_IF:
                    case OPERATOR_GREATER_THAN:
                    case OPERATOR_GREATER_THAN_OR_EQUAL_TO:
                    case OPERATOR_IS:
                    case OPERATOR_LESS_THAN:
                    case OPERATOR_LESS_THAN_OR_EQUAL_TO:
                    case OPERATOR_LSHIFT:
                    case OPERATOR_MINUS:
                    case OPERATOR_MODULO:
                    case OPERATOR_NOT_EQUAL_TO:
                    case OPERATOR_PLUS:
                    case OPERATOR_REL_AND:
                    case OPERATOR_REL_OR:
                    case OPERATOR_RSHIFT:
                    case OPERATOR_TIMES:
                    case RETURN:
                    case STRING:
                    case SWITCH:
                    case TRUE_LIT:
                    case VAR:
                    case WHILE:
                    case YIELD:
                    	{
                    		alt25=1;
                    	}
                        break;

                    }

                    switch (alt25)
                    {
                	case 1:
                	    // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:86:32: statement
                	    {
                	        FOLLOWPUSH(FOLLOW_statement_in_defaultCase514);
                	        statement(ctx);

                	        FOLLOWPOP();
                	        if  (HASEXCEPTION())
                	        {
                	            goto ruledefaultCaseEx;
                	        }


                	    }
                	    break;

                	default:
                	    goto loop25;	/* break out of the loop */
                	    break;
                    }
                }
                loop25: ; /* Jump out to here if this rule does not match */


                MATCHT(ANTLR3_TOKEN_UP, NULL);
                if  (HASEXCEPTION())
                {
                    goto ruledefaultCaseEx;
                }

            }


            MATCHT(ANTLR3_TOKEN_UP, NULL);
            if  (HASEXCEPTION())
            {
                goto ruledefaultCaseEx;
            }



        }

    }

    // This is where rules clean up and exit
    //
    goto ruledefaultCaseEx; /* Prevent compiler warnings */
    ruledefaultCaseEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end defaultCase */

/**
 * $ANTLR start expression
 * D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:88:1: expression : ( ^( ( '=' | '+=' | '-=' | '*=' | '/=' | '%=' | '<<=' | '>>=' | '&=' | '|=' | '^=' | 'is' ) expression expression ) | ^( '?' expression expression expression ) | ^( '||' expression expression ) | ^( '&&' expression expression ) | ^( '^' expression expression ) | ^( '&' expression expression ) | ^( ( '==' | '!=' ) expression expression ) | ^( ( '<' | '<=' | '>' | '>=' ) expression expression ) | ^( ( '<<' | '>>' ) expression expression ) | ^( ( '+' | '-' ) expression expression ) | ^( ( '*' | '/' | '%' ) expression expression ) | ^( '.' expression expression ) | ^( '(' expression ( expression )* ) | ^( '[' expression ( expression )* ) | IDENTIFIER | coordinateLiteral | 'true' | 'false' | NUMBER | STRING );
 */
static void
expression(pGeoGenScriptDecls ctx)
{
    /* Initialize rule variables
     */

    {
        {
            //  D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:88:11: ( ^( ( '=' | '+=' | '-=' | '*=' | '/=' | '%=' | '<<=' | '>>=' | '&=' | '|=' | '^=' | 'is' ) expression expression ) | ^( '?' expression expression expression ) | ^( '||' expression expression ) | ^( '&&' expression expression ) | ^( '^' expression expression ) | ^( '&' expression expression ) | ^( ( '==' | '!=' ) expression expression ) | ^( ( '<' | '<=' | '>' | '>=' ) expression expression ) | ^( ( '<<' | '>>' ) expression expression ) | ^( ( '+' | '-' ) expression expression ) | ^( ( '*' | '/' | '%' ) expression expression ) | ^( '.' expression expression ) | ^( '(' expression ( expression )* ) | ^( '[' expression ( expression )* ) | IDENTIFIER | coordinateLiteral | 'true' | 'false' | NUMBER | STRING )

            ANTLR3_UINT32 alt28;

            alt28=20;

            switch ( LA(1) )
            {
            case OPERATOR_ASSIGN:
            case OPERATOR_ASSIGN_AND:
            case OPERATOR_ASSIGN_DIVIDE:
            case OPERATOR_ASSIGN_LSHIFT:
            case OPERATOR_ASSIGN_MINUS:
            case OPERATOR_ASSIGN_MODULO:
            case OPERATOR_ASSIGN_OR:
            case OPERATOR_ASSIGN_PLUS:
            case OPERATOR_ASSIGN_RSHIFT:
            case OPERATOR_ASSIGN_TIMES:
            case OPERATOR_ASSIGN_XOR:
            case OPERATOR_IS:
            	{
            		alt28=1;
            	}
                break;
            case OPERATOR_EXPR_IF:
            	{
            		alt28=2;
            	}
                break;
            case OPERATOR_REL_OR:
            	{
            		alt28=3;
            	}
                break;
            case OPERATOR_REL_AND:
            	{
            		alt28=4;
            	}
                break;
            case OPERATOR_BIT_XOR:
            	{
            		alt28=5;
            	}
                break;
            case OPERATOR_BIT_AND:
            	{
            		alt28=6;
            	}
                break;
            case OPERATOR_EQUAL_TO:
            case OPERATOR_NOT_EQUAL_TO:
            	{
            		alt28=7;
            	}
                break;
            case OPERATOR_GREATER_THAN:
            case OPERATOR_GREATER_THAN_OR_EQUAL_TO:
            case OPERATOR_LESS_THAN:
            case OPERATOR_LESS_THAN_OR_EQUAL_TO:
            	{
            		alt28=8;
            	}
                break;
            case OPERATOR_LSHIFT:
            case OPERATOR_RSHIFT:
            	{
            		alt28=9;
            	}
                break;
            case OPERATOR_MINUS:
            case OPERATOR_PLUS:
            	{
            		alt28=10;
            	}
                break;
            case OPERATOR_DIVIDE:
            case OPERATOR_MODULO:
            case OPERATOR_TIMES:
            	{
            		alt28=11;
            	}
                break;
            case OPERATOR_DOT:
            	{
            		alt28=12;
            	}
                break;
            case LEFT_BRACKET:
            	{
            		alt28=13;
            	}
                break;
            case LEFT_SQUARE_BRACKET:
            	{
            		alt28=14;
            	}
                break;
            case IDENTIFIER:
            	{
            		alt28=15;
            	}
                break;
            case COORDINATE:
            	{
            		alt28=16;
            	}
                break;
            case TRUE_LIT:
            	{
            		alt28=17;
            	}
                break;
            case FALSE_LIT:
            	{
            		alt28=18;
            	}
                break;
            case NUMBER:
            	{
            		alt28=19;
            	}
                break;
            case STRING:
            	{
            		alt28=20;
            	}
                break;

            default:
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 28;
                EXCEPTION->state        = 0;


                goto ruleexpressionEx;

            }

            switch (alt28)
            {
        	case 1:
        	    // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:89:2: ^( ( '=' | '+=' | '-=' | '*=' | '/=' | '%=' | '<<=' | '>>=' | '&=' | '|=' | '^=' | 'is' ) expression expression )
        	    {
        	        if ( ((LA(1) >= OPERATOR_ASSIGN) && (LA(1) <= OPERATOR_ASSIGN_XOR)) || LA(1) == OPERATOR_IS )
        	        {
        	            CONSUME();
        	            PERRORRECOVERY=ANTLR3_FALSE;
        	        }
        	        else
        	        {
        	            CONSTRUCTEX();
        	            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
        	            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

        	            RECOVERFROMMISMATCHEDSET(&FOLLOW_set_in_expression526);
        	            goto ruleexpressionEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_DOWN, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }

        	        FOLLOWPUSH(FOLLOW_expression_in_expression574);
        	        expression(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }


        	        FOLLOWPUSH(FOLLOW_expression_in_expression576);
        	        expression(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_UP, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }



        	    }
        	    break;
        	case 2:
        	    // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:90:4: ^( '?' expression expression expression )
        	    {
        	         MATCHT(OPERATOR_EXPR_IF, &FOLLOW_OPERATOR_EXPR_IF_in_expression583);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_DOWN, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }

        	        FOLLOWPUSH(FOLLOW_expression_in_expression585);
        	        expression(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }


        	        FOLLOWPUSH(FOLLOW_expression_in_expression588);
        	        expression(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }


        	        FOLLOWPUSH(FOLLOW_expression_in_expression590);
        	        expression(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_UP, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }



        	    }
        	    break;
        	case 3:
        	    // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:91:4: ^( '||' expression expression )
        	    {
        	         MATCHT(OPERATOR_REL_OR, &FOLLOW_OPERATOR_REL_OR_in_expression597);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_DOWN, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }

        	        FOLLOWPUSH(FOLLOW_expression_in_expression599);
        	        expression(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }


        	        FOLLOWPUSH(FOLLOW_expression_in_expression601);
        	        expression(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_UP, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }



        	    }
        	    break;
        	case 4:
        	    // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:92:4: ^( '&&' expression expression )
        	    {
        	         MATCHT(OPERATOR_REL_AND, &FOLLOW_OPERATOR_REL_AND_in_expression608);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_DOWN, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }

        	        FOLLOWPUSH(FOLLOW_expression_in_expression610);
        	        expression(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }


        	        FOLLOWPUSH(FOLLOW_expression_in_expression612);
        	        expression(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_UP, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }



        	    }
        	    break;
        	case 5:
        	    // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:93:4: ^( '^' expression expression )
        	    {
        	         MATCHT(OPERATOR_BIT_XOR, &FOLLOW_OPERATOR_BIT_XOR_in_expression619);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_DOWN, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }

        	        FOLLOWPUSH(FOLLOW_expression_in_expression621);
        	        expression(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }


        	        FOLLOWPUSH(FOLLOW_expression_in_expression623);
        	        expression(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_UP, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }



        	    }
        	    break;
        	case 6:
        	    // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:94:4: ^( '&' expression expression )
        	    {
        	         MATCHT(OPERATOR_BIT_AND, &FOLLOW_OPERATOR_BIT_AND_in_expression630);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_DOWN, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }

        	        FOLLOWPUSH(FOLLOW_expression_in_expression632);
        	        expression(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }


        	        FOLLOWPUSH(FOLLOW_expression_in_expression634);
        	        expression(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_UP, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }



        	    }
        	    break;
        	case 7:
        	    // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:95:4: ^( ( '==' | '!=' ) expression expression )
        	    {
        	        if ( LA(1) == OPERATOR_EQUAL_TO || LA(1) == OPERATOR_NOT_EQUAL_TO )
        	        {
        	            CONSUME();
        	            PERRORRECOVERY=ANTLR3_FALSE;
        	        }
        	        else
        	        {
        	            CONSTRUCTEX();
        	            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
        	            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

        	            RECOVERFROMMISMATCHEDSET(&FOLLOW_set_in_expression641);
        	            goto ruleexpressionEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_DOWN, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }

        	        FOLLOWPUSH(FOLLOW_expression_in_expression649);
        	        expression(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }


        	        FOLLOWPUSH(FOLLOW_expression_in_expression651);
        	        expression(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_UP, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }



        	    }
        	    break;
        	case 8:
        	    // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:96:4: ^( ( '<' | '<=' | '>' | '>=' ) expression expression )
        	    {
        	        if ( ((LA(1) >= OPERATOR_GREATER_THAN) && (LA(1) <= OPERATOR_GREATER_THAN_OR_EQUAL_TO)) || ((LA(1) >= OPERATOR_LESS_THAN) && (LA(1) <= OPERATOR_LESS_THAN_OR_EQUAL_TO)) )
        	        {
        	            CONSUME();
        	            PERRORRECOVERY=ANTLR3_FALSE;
        	        }
        	        else
        	        {
        	            CONSTRUCTEX();
        	            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
        	            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

        	            RECOVERFROMMISMATCHEDSET(&FOLLOW_set_in_expression658);
        	            goto ruleexpressionEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_DOWN, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }

        	        FOLLOWPUSH(FOLLOW_expression_in_expression674);
        	        expression(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }


        	        FOLLOWPUSH(FOLLOW_expression_in_expression676);
        	        expression(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_UP, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }



        	    }
        	    break;
        	case 9:
        	    // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:97:4: ^( ( '<<' | '>>' ) expression expression )
        	    {
        	        if ( LA(1) == OPERATOR_LSHIFT || LA(1) == OPERATOR_RSHIFT )
        	        {
        	            CONSUME();
        	            PERRORRECOVERY=ANTLR3_FALSE;
        	        }
        	        else
        	        {
        	            CONSTRUCTEX();
        	            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
        	            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

        	            RECOVERFROMMISMATCHEDSET(&FOLLOW_set_in_expression683);
        	            goto ruleexpressionEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_DOWN, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }

        	        FOLLOWPUSH(FOLLOW_expression_in_expression691);
        	        expression(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }


        	        FOLLOWPUSH(FOLLOW_expression_in_expression693);
        	        expression(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_UP, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }



        	    }
        	    break;
        	case 10:
        	    // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:98:4: ^( ( '+' | '-' ) expression expression )
        	    {
        	        if ( LA(1) == OPERATOR_MINUS || LA(1) == OPERATOR_PLUS )
        	        {
        	            CONSUME();
        	            PERRORRECOVERY=ANTLR3_FALSE;
        	        }
        	        else
        	        {
        	            CONSTRUCTEX();
        	            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
        	            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

        	            RECOVERFROMMISMATCHEDSET(&FOLLOW_set_in_expression700);
        	            goto ruleexpressionEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_DOWN, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }

        	        FOLLOWPUSH(FOLLOW_expression_in_expression708);
        	        expression(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }


        	        FOLLOWPUSH(FOLLOW_expression_in_expression710);
        	        expression(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_UP, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }



        	    }
        	    break;
        	case 11:
        	    // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:99:4: ^( ( '*' | '/' | '%' ) expression expression )
        	    {
        	        if ( LA(1) == OPERATOR_DIVIDE || LA(1) == OPERATOR_MODULO || LA(1) == OPERATOR_TIMES )
        	        {
        	            CONSUME();
        	            PERRORRECOVERY=ANTLR3_FALSE;
        	        }
        	        else
        	        {
        	            CONSTRUCTEX();
        	            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
        	            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

        	            RECOVERFROMMISMATCHEDSET(&FOLLOW_set_in_expression717);
        	            goto ruleexpressionEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_DOWN, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }

        	        FOLLOWPUSH(FOLLOW_expression_in_expression729);
        	        expression(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }


        	        FOLLOWPUSH(FOLLOW_expression_in_expression731);
        	        expression(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_UP, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }



        	    }
        	    break;
        	case 12:
        	    // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:100:4: ^( '.' expression expression )
        	    {
        	         MATCHT(OPERATOR_DOT, &FOLLOW_OPERATOR_DOT_in_expression739);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_DOWN, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }

        	        FOLLOWPUSH(FOLLOW_expression_in_expression741);
        	        expression(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }


        	        FOLLOWPUSH(FOLLOW_expression_in_expression743);
        	        expression(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_UP, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }



        	    }
        	    break;
        	case 13:
        	    // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:101:4: ^( '(' expression ( expression )* )
        	    {
        	         MATCHT(LEFT_BRACKET, &FOLLOW_LEFT_BRACKET_in_expression750);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_DOWN, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }

        	        FOLLOWPUSH(FOLLOW_expression_in_expression752);
        	        expression(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }


        	        // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:101:21: ( expression )*

        	        for (;;)
        	        {
        	            int alt26=2;
        	            switch ( LA(1) )
        	            {
        	            case COORDINATE:
        	            case FALSE_LIT:
        	            case IDENTIFIER:
        	            case LEFT_BRACKET:
        	            case LEFT_SQUARE_BRACKET:
        	            case NUMBER:
        	            case OPERATOR_ASSIGN:
        	            case OPERATOR_ASSIGN_AND:
        	            case OPERATOR_ASSIGN_DIVIDE:
        	            case OPERATOR_ASSIGN_LSHIFT:
        	            case OPERATOR_ASSIGN_MINUS:
        	            case OPERATOR_ASSIGN_MODULO:
        	            case OPERATOR_ASSIGN_OR:
        	            case OPERATOR_ASSIGN_PLUS:
        	            case OPERATOR_ASSIGN_RSHIFT:
        	            case OPERATOR_ASSIGN_TIMES:
        	            case OPERATOR_ASSIGN_XOR:
        	            case OPERATOR_BIT_AND:
        	            case OPERATOR_BIT_XOR:
        	            case OPERATOR_DIVIDE:
        	            case OPERATOR_DOT:
        	            case OPERATOR_EQUAL_TO:
        	            case OPERATOR_EXPR_IF:
        	            case OPERATOR_GREATER_THAN:
        	            case OPERATOR_GREATER_THAN_OR_EQUAL_TO:
        	            case OPERATOR_IS:
        	            case OPERATOR_LESS_THAN:
        	            case OPERATOR_LESS_THAN_OR_EQUAL_TO:
        	            case OPERATOR_LSHIFT:
        	            case OPERATOR_MINUS:
        	            case OPERATOR_MODULO:
        	            case OPERATOR_NOT_EQUAL_TO:
        	            case OPERATOR_PLUS:
        	            case OPERATOR_REL_AND:
        	            case OPERATOR_REL_OR:
        	            case OPERATOR_RSHIFT:
        	            case OPERATOR_TIMES:
        	            case STRING:
        	            case TRUE_LIT:
        	            	{
        	            		alt26=1;
        	            	}
        	                break;

        	            }

        	            switch (alt26)
        	            {
        	        	case 1:
        	        	    // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:101:21: expression
        	        	    {
        	        	        FOLLOWPUSH(FOLLOW_expression_in_expression754);
        	        	        expression(ctx);

        	        	        FOLLOWPOP();
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto ruleexpressionEx;
        	        	        }


        	        	    }
        	        	    break;

        	        	default:
        	        	    goto loop26;	/* break out of the loop */
        	        	    break;
        	            }
        	        }
        	        loop26: ; /* Jump out to here if this rule does not match */


        	        MATCHT(ANTLR3_TOKEN_UP, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }



        	    }
        	    break;
        	case 14:
        	    // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:102:4: ^( '[' expression ( expression )* )
        	    {
        	         MATCHT(LEFT_SQUARE_BRACKET, &FOLLOW_LEFT_SQUARE_BRACKET_in_expression762);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_DOWN, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }

        	        FOLLOWPUSH(FOLLOW_expression_in_expression764);
        	        expression(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }


        	        // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:102:21: ( expression )*

        	        for (;;)
        	        {
        	            int alt27=2;
        	            switch ( LA(1) )
        	            {
        	            case COORDINATE:
        	            case FALSE_LIT:
        	            case IDENTIFIER:
        	            case LEFT_BRACKET:
        	            case LEFT_SQUARE_BRACKET:
        	            case NUMBER:
        	            case OPERATOR_ASSIGN:
        	            case OPERATOR_ASSIGN_AND:
        	            case OPERATOR_ASSIGN_DIVIDE:
        	            case OPERATOR_ASSIGN_LSHIFT:
        	            case OPERATOR_ASSIGN_MINUS:
        	            case OPERATOR_ASSIGN_MODULO:
        	            case OPERATOR_ASSIGN_OR:
        	            case OPERATOR_ASSIGN_PLUS:
        	            case OPERATOR_ASSIGN_RSHIFT:
        	            case OPERATOR_ASSIGN_TIMES:
        	            case OPERATOR_ASSIGN_XOR:
        	            case OPERATOR_BIT_AND:
        	            case OPERATOR_BIT_XOR:
        	            case OPERATOR_DIVIDE:
        	            case OPERATOR_DOT:
        	            case OPERATOR_EQUAL_TO:
        	            case OPERATOR_EXPR_IF:
        	            case OPERATOR_GREATER_THAN:
        	            case OPERATOR_GREATER_THAN_OR_EQUAL_TO:
        	            case OPERATOR_IS:
        	            case OPERATOR_LESS_THAN:
        	            case OPERATOR_LESS_THAN_OR_EQUAL_TO:
        	            case OPERATOR_LSHIFT:
        	            case OPERATOR_MINUS:
        	            case OPERATOR_MODULO:
        	            case OPERATOR_NOT_EQUAL_TO:
        	            case OPERATOR_PLUS:
        	            case OPERATOR_REL_AND:
        	            case OPERATOR_REL_OR:
        	            case OPERATOR_RSHIFT:
        	            case OPERATOR_TIMES:
        	            case STRING:
        	            case TRUE_LIT:
        	            	{
        	            		alt27=1;
        	            	}
        	                break;

        	            }

        	            switch (alt27)
        	            {
        	        	case 1:
        	        	    // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:102:21: expression
        	        	    {
        	        	        FOLLOWPUSH(FOLLOW_expression_in_expression766);
        	        	        expression(ctx);

        	        	        FOLLOWPOP();
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto ruleexpressionEx;
        	        	        }


        	        	    }
        	        	    break;

        	        	default:
        	        	    goto loop27;	/* break out of the loop */
        	        	    break;
        	            }
        	        }
        	        loop27: ; /* Jump out to here if this rule does not match */


        	        MATCHT(ANTLR3_TOKEN_UP, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }



        	    }
        	    break;
        	case 15:
        	    // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:103:4: IDENTIFIER
        	    {
        	         MATCHT(IDENTIFIER, &FOLLOW_IDENTIFIER_in_expression773);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }


        	    }
        	    break;
        	case 16:
        	    // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:105:4: coordinateLiteral
        	    {
        	        FOLLOWPUSH(FOLLOW_coordinateLiteral_in_expression780);
        	        coordinateLiteral(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }


        	    }
        	    break;
        	case 17:
        	    // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:106:4: 'true'
        	    {
        	         MATCHT(TRUE_LIT, &FOLLOW_TRUE_LIT_in_expression785);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }


        	    }
        	    break;
        	case 18:
        	    // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:107:4: 'false'
        	    {
        	         MATCHT(FALSE_LIT, &FOLLOW_FALSE_LIT_in_expression790);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }


        	    }
        	    break;
        	case 19:
        	    // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:108:4: NUMBER
        	    {
        	         MATCHT(NUMBER, &FOLLOW_NUMBER_in_expression795);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }


        	    }
        	    break;
        	case 20:
        	    // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:109:4: STRING
        	    {
        	         MATCHT(STRING, &FOLLOW_STRING_in_expression800);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }


        	    }
        	    break;

            }
        }
    }

    // This is where rules clean up and exit
    //
    goto ruleexpressionEx; /* Prevent compiler warnings */
    ruleexpressionEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end expression */

/**
 * $ANTLR start unkeyedCollectionLiteral
 * D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:180:1: unkeyedCollectionLiteral : '{' ( expression ( ',' expression )* ) '}' ;
 */
static void
unkeyedCollectionLiteral(pGeoGenScriptDecls ctx)
{
    /* Initialize rule variables
     */

    {
        // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:180:25: ( '{' ( expression ( ',' expression )* ) '}' )
        // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:181:5: '{' ( expression ( ',' expression )* ) '}'
        {
             MATCHT(LEFT_CURLY_BRACKET, &FOLLOW_LEFT_CURLY_BRACKET_in_unkeyedCollectionLiteral852);
            if  (HASEXCEPTION())
            {
                goto ruleunkeyedCollectionLiteralEx;
            }


            // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:181:9: ( expression ( ',' expression )* )
            // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:181:10: expression ( ',' expression )*
            {
                FOLLOWPUSH(FOLLOW_expression_in_unkeyedCollectionLiteral855);
                expression(ctx);

                FOLLOWPOP();
                if  (HASEXCEPTION())
                {
                    goto ruleunkeyedCollectionLiteralEx;
                }


                // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:181:21: ( ',' expression )*

                for (;;)
                {
                    int alt29=2;
                    switch ( LA(1) )
                    {
                    case COMMA:
                    	{
                    		alt29=1;
                    	}
                        break;

                    }

                    switch (alt29)
                    {
                	case 1:
                	    // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:181:22: ',' expression
                	    {
                	         MATCHT(COMMA, &FOLLOW_COMMA_in_unkeyedCollectionLiteral858);
                	        if  (HASEXCEPTION())
                	        {
                	            goto ruleunkeyedCollectionLiteralEx;
                	        }


                	        FOLLOWPUSH(FOLLOW_expression_in_unkeyedCollectionLiteral860);
                	        expression(ctx);

                	        FOLLOWPOP();
                	        if  (HASEXCEPTION())
                	        {
                	            goto ruleunkeyedCollectionLiteralEx;
                	        }


                	    }
                	    break;

                	default:
                	    goto loop29;	/* break out of the loop */
                	    break;
                    }
                }
                loop29: ; /* Jump out to here if this rule does not match */


            }


             MATCHT(RIGTH_CURLY_BRACKET, &FOLLOW_RIGTH_CURLY_BRACKET_in_unkeyedCollectionLiteral865);
            if  (HASEXCEPTION())
            {
                goto ruleunkeyedCollectionLiteralEx;
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto ruleunkeyedCollectionLiteralEx; /* Prevent compiler warnings */
    ruleunkeyedCollectionLiteralEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end unkeyedCollectionLiteral */

/**
 * $ANTLR start coordinateLiteral
 * D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:183:1: coordinateLiteral : ^( COORDINATE ( expression )+ ) ;
 */
static void
coordinateLiteral(pGeoGenScriptDecls ctx)
{
    /* Initialize rule variables
     */

    {
        // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:183:18: ( ^( COORDINATE ( expression )+ ) )
        // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:183:20: ^( COORDINATE ( expression )+ )
        {
             MATCHT(COORDINATE, &FOLLOW_COORDINATE_in_coordinateLiteral873);
            if  (HASEXCEPTION())
            {
                goto rulecoordinateLiteralEx;
            }


            MATCHT(ANTLR3_TOKEN_DOWN, NULL);
            if  (HASEXCEPTION())
            {
                goto rulecoordinateLiteralEx;
            }

            // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:183:33: ( expression )+
            {
                int cnt30=0;

                for (;;)
                {
                    int alt30=2;
            	switch ( LA(1) )
            	{
            	case COORDINATE:
            	case FALSE_LIT:
            	case IDENTIFIER:
            	case LEFT_BRACKET:
            	case LEFT_SQUARE_BRACKET:
            	case NUMBER:
            	case OPERATOR_ASSIGN:
            	case OPERATOR_ASSIGN_AND:
            	case OPERATOR_ASSIGN_DIVIDE:
            	case OPERATOR_ASSIGN_LSHIFT:
            	case OPERATOR_ASSIGN_MINUS:
            	case OPERATOR_ASSIGN_MODULO:
            	case OPERATOR_ASSIGN_OR:
            	case OPERATOR_ASSIGN_PLUS:
            	case OPERATOR_ASSIGN_RSHIFT:
            	case OPERATOR_ASSIGN_TIMES:
            	case OPERATOR_ASSIGN_XOR:
            	case OPERATOR_BIT_AND:
            	case OPERATOR_BIT_XOR:
            	case OPERATOR_DIVIDE:
            	case OPERATOR_DOT:
            	case OPERATOR_EQUAL_TO:
            	case OPERATOR_EXPR_IF:
            	case OPERATOR_GREATER_THAN:
            	case OPERATOR_GREATER_THAN_OR_EQUAL_TO:
            	case OPERATOR_IS:
            	case OPERATOR_LESS_THAN:
            	case OPERATOR_LESS_THAN_OR_EQUAL_TO:
            	case OPERATOR_LSHIFT:
            	case OPERATOR_MINUS:
            	case OPERATOR_MODULO:
            	case OPERATOR_NOT_EQUAL_TO:
            	case OPERATOR_PLUS:
            	case OPERATOR_REL_AND:
            	case OPERATOR_REL_OR:
            	case OPERATOR_RSHIFT:
            	case OPERATOR_TIMES:
            	case STRING:
            	case TRUE_LIT:
            		{
            			alt30=1;
            		}
            	    break;

            	}

            	switch (alt30)
            	{
            	    case 1:
            	        // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:183:33: expression
            	        {
            	            FOLLOWPUSH(FOLLOW_expression_in_coordinateLiteral875);
            	            expression(ctx);

            	            FOLLOWPOP();
            	            if  (HASEXCEPTION())
            	            {
            	                goto rulecoordinateLiteralEx;
            	            }


            	        }
            	        break;

            	    default:

            		if ( cnt30 >= 1 )
            		{
            		    goto loop30;
            		}
            		/* mismatchedSetEx()
            		 */
            		CONSTRUCTEX();
            		EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;
            		EXCEPTION->name = (void *)ANTLR3_EARLY_EXIT_NAME;


            		goto rulecoordinateLiteralEx;
            	}
            	cnt30++;
                }
                loop30: ;	/* Jump to here if this rule does not match */
            }

            MATCHT(ANTLR3_TOKEN_UP, NULL);
            if  (HASEXCEPTION())
            {
                goto rulecoordinateLiteralEx;
            }



        }

    }

    // This is where rules clean up and exit
    //
    goto rulecoordinateLiteralEx; /* Prevent compiler warnings */
    rulecoordinateLiteralEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end coordinateLiteral */

/**
 * $ANTLR start label
 * D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:185:1: label : ( ^( IDENTCHAIN ( IDENTIFIER )+ ) | 'true' | 'false' | NUMBER | STRING );
 */
static void
label(pGeoGenScriptDecls ctx)
{
    /* Initialize rule variables
     */

    {
        {
            //  D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:185:6: ( ^( IDENTCHAIN ( IDENTIFIER )+ ) | 'true' | 'false' | NUMBER | STRING )

            ANTLR3_UINT32 alt32;

            alt32=5;

            switch ( LA(1) )
            {
            case IDENTCHAIN:
            	{
            		alt32=1;
            	}
                break;
            case TRUE_LIT:
            	{
            		alt32=2;
            	}
                break;
            case FALSE_LIT:
            	{
            		alt32=3;
            	}
                break;
            case NUMBER:
            	{
            		alt32=4;
            	}
                break;
            case STRING:
            	{
            		alt32=5;
            	}
                break;

            default:
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 32;
                EXCEPTION->state        = 0;


                goto rulelabelEx;

            }

            switch (alt32)
            {
        	case 1:
        	    // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:186:2: ^( IDENTCHAIN ( IDENTIFIER )+ )
        	    {
        	         MATCHT(IDENTCHAIN, &FOLLOW_IDENTCHAIN_in_label894);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulelabelEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_DOWN, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulelabelEx;
        	        }

        	        // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:186:15: ( IDENTIFIER )+
        	        {
        	            int cnt31=0;

        	            for (;;)
        	            {
        	                int alt31=2;
        	        	switch ( LA(1) )
        	        	{
        	        	case IDENTIFIER:
        	        		{
        	        			alt31=1;
        	        		}
        	        	    break;

        	        	}

        	        	switch (alt31)
        	        	{
        	        	    case 1:
        	        	        // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:186:15: IDENTIFIER
        	        	        {
        	        	             MATCHT(IDENTIFIER, &FOLLOW_IDENTIFIER_in_label896);
        	        	            if  (HASEXCEPTION())
        	        	            {
        	        	                goto rulelabelEx;
        	        	            }


        	        	        }
        	        	        break;

        	        	    default:

        	        		if ( cnt31 >= 1 )
        	        		{
        	        		    goto loop31;
        	        		}
        	        		/* mismatchedSetEx()
        	        		 */
        	        		CONSTRUCTEX();
        	        		EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;
        	        		EXCEPTION->name = (void *)ANTLR3_EARLY_EXIT_NAME;


        	        		goto rulelabelEx;
        	        	}
        	        	cnt31++;
        	            }
        	            loop31: ;	/* Jump to here if this rule does not match */
        	        }

        	        MATCHT(ANTLR3_TOKEN_UP, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulelabelEx;
        	        }



        	    }
        	    break;
        	case 2:
        	    // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:187:4: 'true'
        	    {
        	         MATCHT(TRUE_LIT, &FOLLOW_TRUE_LIT_in_label903);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulelabelEx;
        	        }


        	    }
        	    break;
        	case 3:
        	    // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:188:11: 'false'
        	    {
        	         MATCHT(FALSE_LIT, &FOLLOW_FALSE_LIT_in_label915);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulelabelEx;
        	        }


        	    }
        	    break;
        	case 4:
        	    // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:189:4: NUMBER
        	    {
        	         MATCHT(NUMBER, &FOLLOW_NUMBER_in_label920);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulelabelEx;
        	        }


        	    }
        	    break;
        	case 5:
        	    // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:190:4: STRING
        	    {
        	         MATCHT(STRING, &FOLLOW_STRING_in_label925);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulelabelEx;
        	        }


        	    }
        	    break;

            }
        }
    }

    // This is where rules clean up and exit
    //
    goto rulelabelEx; /* Prevent compiler warnings */
    rulelabelEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end label */
/* End of parsing rules
 * ==============================================
 */

/* ==============================================
 * Syntactic predicates
 */
/* End of syntactic predicates
 * ==============================================
 */






/* End of code
 * =============================================================================
 */
