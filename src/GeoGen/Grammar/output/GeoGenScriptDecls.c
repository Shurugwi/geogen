/** \file
 *  This C source file was generated by $ANTLR version null
 *
 *     -  From the grammar source file : D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g
 *     -                            On : 2013-12-08 22:33:52
 *     -           for the tree parser : GeoGenScriptDeclsTreeParser
 *
 * Editing it, at least manually, is not wise.
 *
 * C language generator and runtime by Jim Idle, jimi|hereisanat|idle|dotgoeshere|ws.
 *
 *
*/
// [The "BSD license"]
// Copyright (c) 2005-2009 Jim Idle, Temporal Wave LLC
// http://www.temporal-wave.com
// http://www.linkedin.com/in/jimidle
//
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. The name of the author may not be used to endorse or promote products
//    derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

/* -----------------------------------------
 * Include the ANTLR3 generated header file.
 */
#include    "GeoGenScriptDecls.h"
/* ----------------------------------------- */





/* MACROS that hide the C interface implementations from the
 * generated code, which makes it a little more understandable to the human eye.
 * I am very much against using C pre-processor macros for function calls and bits
 * of code as you cannot see what is happening when single stepping in debuggers
 * and so on. The exception (in my book at least) is for generated code, where you are
 * not maintaining it, but may wish to read and understand it. If you single step it, you know that input()
 * hides some indirect calls, but is always referring to the input stream. This is
 * probably more readable than ctx->input->istream->input(snarfle0->blarg) and allows me to rejig
 * the runtime interfaces without changing the generated code too often, without
 * confusing the reader of the generated output, who may not wish to know the gory
 * details of the interface inheritance.
 */

#define		CTX	ctx

/* Aids in accessing scopes for grammar programmers
 */
#undef	SCOPE_TYPE
#undef	SCOPE_STACK
#undef	SCOPE_TOP
#define	SCOPE_TYPE(scope)   pGeoGenScriptDecls_##scope##_SCOPE
#define SCOPE_STACK(scope)  pGeoGenScriptDecls_##scope##Stack
#define	SCOPE_TOP(scope)    ctx->pGeoGenScriptDecls_##scope##Top
#define	SCOPE_SIZE(scope)		ctx->pGeoGenScriptDecls_##scope##Stack_limit
#define SCOPE_INSTANCE(scope, i)	(ctx->SCOPE_STACK(scope)->get(ctx->SCOPE_STACK(scope),i))

/* Macros for accessing things in the parser
 */

#undef	    PARSER
#undef	    RECOGNIZER
#undef	    HAVEPARSEDRULE
#undef	    INPUT
#undef	    STRSTREAM
#undef	    HASEXCEPTION
#undef	    EXCEPTION
#undef	    MATCHT
#undef	    MATCHANYT
#undef	    FOLLOWSTACK
#undef	    FOLLOWPUSH
#undef	    FOLLOWPOP
#undef	    PRECOVER
#undef	    PREPORTERROR
#undef	    LA
#undef	    LT
#undef	    CONSTRUCTEX
#undef	    CONSUME
#undef	    MARK
#undef	    REWIND
#undef	    REWINDLAST
#undef	    PERRORRECOVERY
#undef	    HASFAILED
#undef	    FAILEDFLAG
#undef	    RECOVERFROMMISMATCHEDSET
#undef	    RECOVERFROMMISMATCHEDELEMENT
#undef	    BACKTRACKING
#undef      ADAPTOR
#undef	    RULEMEMO
#undef		SEEK
#undef		INDEX
#undef		DBG

#define	    PARSER							ctx->pTreeParser
#define	    RECOGNIZER						PARSER->rec
#define		PSRSTATE						RECOGNIZER->state
#define	    HAVEPARSEDRULE(r)				RECOGNIZER->alreadyParsedRule(RECOGNIZER, r)
#define	    INPUT							PARSER->ctnstream
#define		ISTREAM							INPUT->tnstream->istream
#define	    STRSTREAM						INPUT->tnstream
#define	    HASEXCEPTION()					(PSRSTATE->error == ANTLR3_TRUE)
#define	    EXCEPTION						PSRSTATE->exception
#define	    MATCHT(t, fs)					RECOGNIZER->match(RECOGNIZER, t, fs)
#define	    MATCHANYT()						RECOGNIZER->matchAny(RECOGNIZER)
#define	    FOLLOWSTACK					    PSRSTATE->following
#define	    FOLLOWPUSH(x)					FOLLOWSTACK->push(FOLLOWSTACK, ((void *)(&(x))), NULL)
#define	    FOLLOWPOP()						FOLLOWSTACK->pop(FOLLOWSTACK)
#define	    PRECOVER()						RECOGNIZER->recover(RECOGNIZER)
#define	    PREPORTERROR()					RECOGNIZER->reportError(RECOGNIZER)
#define	    LA(n)							ISTREAM->_LA(ISTREAM, n)
#define	    LT(n)							INPUT->tnstream->_LT(INPUT->tnstream, n)
#define	    CONSTRUCTEX()					RECOGNIZER->exConstruct(RECOGNIZER)
#define	    CONSUME()						ISTREAM->consume(ISTREAM)
#define	    MARK()							ISTREAM->mark(ISTREAM)
#define	    REWIND(m)						ISTREAM->rewind(ISTREAM, m)
#define	    REWINDLAST()					ISTREAM->rewindLast(ISTREAM)
#define	    PERRORRECOVERY					PSRSTATE->errorRecovery
#define	    FAILEDFLAG						PSRSTATE->failed
#define	    HASFAILED()						(FAILEDFLAG == ANTLR3_TRUE)
#define	    BACKTRACKING					PSRSTATE->backtracking
#define	    RECOVERFROMMISMATCHEDSET(s)		RECOGNIZER->recoverFromMismatchedSet(RECOGNIZER, s)
#define	    RECOVERFROMMISMATCHEDELEMENT(e)	RECOGNIZER->recoverFromMismatchedElement(RECOGNIZER, s)
#define     ADAPTOR                         INPUT->adaptor
#define		RULEMEMO						PSRSTATE->ruleMemo
#define		SEEK(n)							ISTREAM->seek(ISTREAM, n)
#define		INDEX()							ISTREAM->index(ISTREAM)
#define		DBG								RECOGNIZER->debugger



#define		TOKTEXT(tok, txt)				tok, (pANTLR3_UINT8)txt

/* The 4 tokens defined below may well clash with your own #defines or token types. If so
 * then for the present you must use different names for your defines as these are hard coded
 * in the code generator. It would be better not to use such names internally, and maybe
 * we can change this in a forthcoming release. I deliberately do not #undef these
 * here as this will at least give you a redefined error somewhere if they clash.
 */
#define	    UP	    ANTLR3_TOKEN_UP
#define	    DOWN    ANTLR3_TOKEN_DOWN
#define	    EOR	    ANTLR3_TOKEN_EOR
#define	    INVALID ANTLR3_TOKEN_INVALID


/* =============================================================================
 * Functions to create and destroy scopes. First come the rule scopes, followed
 * by the global declared scopes.
 */

/* ruleAttributeScopeFuncDecl(scope)
 */
/* -----------------------------------------------------------------------------
 * Function declarations for creating a GeoGenScriptDecls_block scope set
 */
static pGeoGenScriptDecls_block_SCOPE   pGeoGenScriptDecls_blockPush(pGeoGenScriptDecls ctx);
static void ANTLR3_CDECL blockFree(pGeoGenScriptDecls_block_SCOPE scope);
/* ----------------------------------------------------------------------------- */


/* ruleAttributeScopeFuncs(scope)
 */
/* attributeFuncs(scope)
 */

static void ANTLR3_CDECL blockFree(pGeoGenScriptDecls_block_SCOPE scope)
{
    ANTLR3_FREE(scope);
}

/** \brief Allocate initial memory for a GeoGenScriptDecls block scope variable stack entry and
 *         add it to the top of the stack.
 *
 * \remark
 * By default the structure is freed with ANTLR_FREE(), but you can use the
 * the \@init action to install a pointer to a custom free() routine by
 * adding the code:
 * \code
 *   ctx->pGeoGenScriptDecls_blockTop->free = myroutine;
 * \endcode
 *
 * With lots of comments of course! The routine should be declared in
 * \@members { } as:
 * \code
 *   void ANTLR3_CDECL myfunc( pGeoGenScriptDecls_block_SCOPE ptr).
 * \endcode
 *
 * It should perform any custom freeing stuff that you need (call ANTLR_FREE3, not free()
 * NB: It should not free the pointer it is given, which is the scope stack entry itself
 * and will be freed by the function that calls your custom free routine.
 *
 */
static pGeoGenScriptDecls_block_SCOPE
pGeoGenScriptDecls_blockPush(pGeoGenScriptDecls ctx)
{
    /* Pointer used to create a new set of attributes
     */
    pGeoGenScriptDecls_block_SCOPE      newAttributes;

    /* Allocate the memory for a new structure if we need one.
     */
    if (ctx->pGeoGenScriptDecls_blockStack->size(ctx->pGeoGenScriptDecls_blockStack) > ctx->pGeoGenScriptDecls_blockStack_limit)
    {
        // The current limit value was less than the number of scopes available on the stack so
        // we can just reuse one. Our limit tracks the stack count, so the index of the entry we want
        // is one less than that, or conveniently, the current value of limit.
        //
        newAttributes = (pGeoGenScriptDecls_block_SCOPE)ctx->pGeoGenScriptDecls_blockStack->get(ctx->pGeoGenScriptDecls_blockStack, ctx->pGeoGenScriptDecls_blockStack_limit);
    }
    else
    {
        // Need a new allocation
        //
        newAttributes = (pGeoGenScriptDecls_block_SCOPE) ANTLR3_MALLOC(sizeof(GeoGenScriptDecls_block_SCOPE));
        if  (newAttributes != NULL)
        {
            /* Standard ANTLR3 library implementation
             */
            ctx->pGeoGenScriptDecls_blockStack->push(ctx->pGeoGenScriptDecls_blockStack, newAttributes, (void (*)(void *))blockFree);
        }
    }

    // Blank out any previous free pointer, the user might or might install a new one.
    //
    newAttributes->free = NULL;

    // Indicate the position in the available stack that the current level is at
    //
    ctx->pGeoGenScriptDecls_blockStack_limit++;

	/* Return value is the pointer to the new entry, which may be used locally
	 * without de-referencing via the context.
     */
    return  newAttributes;
}







/* ============================================================================= */

/* =============================================================================
 * Start of recognizer
 */


/** \brief Table of all token names in symbolic order, mainly used for
 *         error reporting.
 */
pANTLR3_UINT8   GeoGenScriptDeclsTokenNames[83+4]
     = {
        (pANTLR3_UINT8) "<invalid>",       /* String to print to indicate an invalid token */
        (pANTLR3_UINT8) "<EOR>",
        (pANTLR3_UINT8) "<DOWN>",
        (pANTLR3_UINT8) "<UP>",
        (pANTLR3_UINT8) "AS",
        (pANTLR3_UINT8) "AT",
        (pANTLR3_UINT8) "BLOCK",
        (pANTLR3_UINT8) "BREAK",
        (pANTLR3_UINT8) "CASE",
        (pANTLR3_UINT8) "COLLECTION",
        (pANTLR3_UINT8) "COLON",
        (pANTLR3_UINT8) "COMMA",
        (pANTLR3_UINT8) "COMMENT",
        (pANTLR3_UINT8) "CONDITION_EXPRESSION",
        (pANTLR3_UINT8) "CONTINUE",
        (pANTLR3_UINT8) "COORDINATE",
        (pANTLR3_UINT8) "DECLARATIONS",
        (pANTLR3_UINT8) "DEFAULT",
        (pANTLR3_UINT8) "ELSE",
        (pANTLR3_UINT8) "ENUM",
        (pANTLR3_UINT8) "ESC_SEQ",
        (pANTLR3_UINT8) "FALSE_LIT",
        (pANTLR3_UINT8) "FOR",
        (pANTLR3_UINT8) "FUNCTION",
        (pANTLR3_UINT8) "HEX_DIGIT",
        (pANTLR3_UINT8) "IDENTCHAIN",
        (pANTLR3_UINT8) "IDENTIFIER",
        (pANTLR3_UINT8) "IF",
        (pANTLR3_UINT8) "INCREMENT_EXPRESSION",
        (pANTLR3_UINT8) "INITIALIZATION_EXPRESSION",
        (pANTLR3_UINT8) "INTEGER",
        (pANTLR3_UINT8) "LEFT_BRACKET",
        (pANTLR3_UINT8) "LEFT_CURLY_BRACKET",
        (pANTLR3_UINT8) "LEFT_SQUARE_BRACKET",
        (pANTLR3_UINT8) "METADATA",
        (pANTLR3_UINT8) "NUMBER",
        (pANTLR3_UINT8) "OPERATOR_ASSIGN",
        (pANTLR3_UINT8) "OPERATOR_ASSIGN_AND",
        (pANTLR3_UINT8) "OPERATOR_ASSIGN_DIVIDE",
        (pANTLR3_UINT8) "OPERATOR_ASSIGN_LSHIFT",
        (pANTLR3_UINT8) "OPERATOR_ASSIGN_MINUS",
        (pANTLR3_UINT8) "OPERATOR_ASSIGN_MODULO",
        (pANTLR3_UINT8) "OPERATOR_ASSIGN_OR",
        (pANTLR3_UINT8) "OPERATOR_ASSIGN_PLUS",
        (pANTLR3_UINT8) "OPERATOR_ASSIGN_RSHIFT",
        (pANTLR3_UINT8) "OPERATOR_ASSIGN_TIMES",
        (pANTLR3_UINT8) "OPERATOR_ASSIGN_XOR",
        (pANTLR3_UINT8) "OPERATOR_BIT_AND",
        (pANTLR3_UINT8) "OPERATOR_BIT_OR",
        (pANTLR3_UINT8) "OPERATOR_BIT_XOR",
        (pANTLR3_UINT8) "OPERATOR_CALL",
        (pANTLR3_UINT8) "OPERATOR_DECREMENT",
        (pANTLR3_UINT8) "OPERATOR_DIVIDE",
        (pANTLR3_UINT8) "OPERATOR_DOT",
        (pANTLR3_UINT8) "OPERATOR_EQUAL_TO",
        (pANTLR3_UINT8) "OPERATOR_EXPR_IF",
        (pANTLR3_UINT8) "OPERATOR_GREATER_THAN",
        (pANTLR3_UINT8) "OPERATOR_GREATER_THAN_OR_EQUAL_TO",
        (pANTLR3_UINT8) "OPERATOR_INCREMENT",
        (pANTLR3_UINT8) "OPERATOR_IS",
        (pANTLR3_UINT8) "OPERATOR_LESS_THAN",
        (pANTLR3_UINT8) "OPERATOR_LESS_THAN_OR_EQUAL_TO",
        (pANTLR3_UINT8) "OPERATOR_LSHIFT",
        (pANTLR3_UINT8) "OPERATOR_MINUS",
        (pANTLR3_UINT8) "OPERATOR_MODULO",
        (pANTLR3_UINT8) "OPERATOR_NOT",
        (pANTLR3_UINT8) "OPERATOR_NOT_EQUAL_TO",
        (pANTLR3_UINT8) "OPERATOR_PLUS",
        (pANTLR3_UINT8) "OPERATOR_REL_AND",
        (pANTLR3_UINT8) "OPERATOR_REL_OR",
        (pANTLR3_UINT8) "OPERATOR_RSHIFT",
        (pANTLR3_UINT8) "OPERATOR_SUBSCRIPT",
        (pANTLR3_UINT8) "OPERATOR_TIMES",
        (pANTLR3_UINT8) "PARAMETERS",
        (pANTLR3_UINT8) "RETURN",
        (pANTLR3_UINT8) "RIGHT_BRACKET",
        (pANTLR3_UINT8) "RIGHT_SQUARE_BRACKET",
        (pANTLR3_UINT8) "RIGTH_CURLY_BRACKET",
        (pANTLR3_UINT8) "SCRIPT",
        (pANTLR3_UINT8) "SEMICOLON",
        (pANTLR3_UINT8) "STRING",
        (pANTLR3_UINT8) "SWITCH",
        (pANTLR3_UINT8) "TRUE_LIT",
        (pANTLR3_UINT8) "VAR",
        (pANTLR3_UINT8) "WHILE",
        (pANTLR3_UINT8) "WHITESPACE",
        (pANTLR3_UINT8) "YIELD"
       };


/* ruleAttributeScopeFuncMacro(scope)
 */
/** Function for popping the top value from a pGeoGenScriptDecls_blockStack
 */
void
pGeoGenScriptDecls_blockPop(pGeoGenScriptDecls ctx)
{
    // First see if the user defined a function they want to be called when a
    // scope is popped/freed.
    //
	// If the user supplied the scope entries with a free function,then call it first
	//
    if	(SCOPE_TOP(block)->free != NULL)
	{
        SCOPE_TOP(block)->free(SCOPE_TOP(block));
	}

    // Now we decrement the scope's upper limit bound. We do not actually pop the scope as
    // we want to reuse scope entries if we do continuous push and pops. Most scopes don't
    // next too far so we don't want to keep freeing and allocating them
    //
    ctx->pGeoGenScriptDecls_blockStack_limit--;
    SCOPE_TOP(block) = (pGeoGenScriptDecls_block_SCOPE)(ctx->pGeoGenScriptDecls_blockStack->get(ctx->pGeoGenScriptDecls_blockStack, ctx->pGeoGenScriptDecls_blockStack_limit - 1));
}



// Forward declare the locally static matching functions we have generated.
//
static 
 void
	script    (pGeoGenScriptDecls ctx);
static 
 void
	metadata    (pGeoGenScriptDecls ctx);
static 
 MetadataValue*
	metadataKeyValueCollection    (pGeoGenScriptDecls ctx);
static 
 GeoGenScriptDecls_metadataKeyValuePair_return
	metadataKeyValuePair    (pGeoGenScriptDecls ctx);
static 
 MetadataValue*
	metadataKeyValueValue    (pGeoGenScriptDecls ctx);
static 
 void
	keyValueCollection    (pGeoGenScriptDecls ctx);
static 
 void
	keyValuePair    (pGeoGenScriptDecls ctx);
static 
 void
	keyValueValue    (pGeoGenScriptDecls ctx);
static 
 void
	declaration    (pGeoGenScriptDecls ctx);
static 
 void
	enumDeclaration    (pGeoGenScriptDecls ctx);
static 
 void
	enumValues    (pGeoGenScriptDecls ctx);
static 
 void
	enumValue    (pGeoGenScriptDecls ctx);
static 
 void
	functionDeclaration    (pGeoGenScriptDecls ctx);
static 
 CodeBlock*
	block    (pGeoGenScriptDecls ctx);
static 
 void
	statement    (pGeoGenScriptDecls ctx);
static 
 void
	variableDeclaration    (pGeoGenScriptDecls ctx);
static 
 void
	yieldStatement    (pGeoGenScriptDecls ctx);
static 
 void
	returnStatement    (pGeoGenScriptDecls ctx);
static 
 void
	whileStatement    (pGeoGenScriptDecls ctx);
static 
 void
	forStatement    (pGeoGenScriptDecls ctx);
static 
 void
	initExpression    (pGeoGenScriptDecls ctx);
static 
 void
	ifStatement    (pGeoGenScriptDecls ctx);
static 
 void
	switchStatement    (pGeoGenScriptDecls ctx);
static 
 void
	normalCase    (pGeoGenScriptDecls ctx);
static 
 void
	defaultCase    (pGeoGenScriptDecls ctx);
static 
 void
	expression    (pGeoGenScriptDecls ctx);
static 
 void
	unkeyedCollectionLiteral    (pGeoGenScriptDecls ctx);
static 
 void
	coordinateLiteral    (pGeoGenScriptDecls ctx);
static 
 void
	label    (pGeoGenScriptDecls ctx);
static void	GeoGenScriptDeclsFree(pGeoGenScriptDecls ctx);
static void     GeoGenScriptDeclsReset (pGeoGenScriptDecls ctx);

/* For use in tree output where we are accumulating rule labels via label += ruleRef
 * we need a function that knows how to free a return scope when the list is destroyed.
 * We cannot just use ANTLR3_FREE because in debug tracking mode, this is a macro.
 */
static	void ANTLR3_CDECL freeScope(void * scope)
{
    ANTLR3_FREE(scope);
}

/** \brief Name of the grammar file that generated this code
 */
static const char fileName[] = "D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g";

/** \brief Return the name of the grammar file that generated this code.
 */
static const char * getGrammarFileName()
{
	return fileName;
}
/** \brief Create a new GeoGenScriptDecls parser and return a context for it.
 *
 * \param[in] instream Pointer to an input stream interface.
 *
 * \return Pointer to new parser context upon success.
 */
ANTLR3_API pGeoGenScriptDecls
GeoGenScriptDeclsNew   (pANTLR3_COMMON_TREE_NODE_STREAM instream)
{
	// See if we can create a new parser with the standard constructor
	//
	return GeoGenScriptDeclsNewSSD(instream, NULL);
}

/** \brief Create a new GeoGenScriptDecls parser and return a context for it.
 *
 * \param[in] instream Pointer to an input stream interface.
 *
 * \return Pointer to new parser context upon success.
 */
ANTLR3_API pGeoGenScriptDecls
GeoGenScriptDeclsNewSSD   (pANTLR3_COMMON_TREE_NODE_STREAM instream, pANTLR3_RECOGNIZER_SHARED_STATE state)
{
    pGeoGenScriptDecls ctx;	    /* Context structure we will build and return   */

    ctx	= (pGeoGenScriptDecls) ANTLR3_CALLOC(1, sizeof(GeoGenScriptDecls));

    if	(ctx == NULL)
    {
		// Failed to allocate memory for parser context
		//
        return  NULL;
    }

    /* -------------------------------------------------------------------
     * Memory for basic structure is allocated, now to fill in
     * the base ANTLR3 structures. We initialize the function pointers
     * for the standard ANTLR3 parser function set, but upon return
     * from here, the programmer may set the pointers to provide custom
     * implementations of each function.
     *
     * We don't use the macros defined in GeoGenScriptDecls.h here, in order that you can get a sense
     * of what goes where.
     */

    /* Create a base Tree parser/recognizer, using the supplied tree node stream
     */
    ctx->pTreeParser		= antlr3TreeParserNewStream(ANTLR3_SIZE_HINT, instream, state);

    /* Install the implementation of our GeoGenScriptDecls interface
     */
    ctx->script	= script;
    ctx->metadata	= metadata;
    ctx->metadataKeyValueCollection	= metadataKeyValueCollection;
    ctx->metadataKeyValuePair	= metadataKeyValuePair;
    ctx->metadataKeyValueValue	= metadataKeyValueValue;
    ctx->keyValueCollection	= keyValueCollection;
    ctx->keyValuePair	= keyValuePair;
    ctx->keyValueValue	= keyValueValue;
    ctx->declaration	= declaration;
    ctx->enumDeclaration	= enumDeclaration;
    ctx->enumValues	= enumValues;
    ctx->enumValue	= enumValue;
    ctx->functionDeclaration	= functionDeclaration;
    ctx->block	= block;
    ctx->statement	= statement;
    ctx->variableDeclaration	= variableDeclaration;
    ctx->yieldStatement	= yieldStatement;
    ctx->returnStatement	= returnStatement;
    ctx->whileStatement	= whileStatement;
    ctx->forStatement	= forStatement;
    ctx->initExpression	= initExpression;
    ctx->ifStatement	= ifStatement;
    ctx->switchStatement	= switchStatement;
    ctx->normalCase	= normalCase;
    ctx->defaultCase	= defaultCase;
    ctx->expression	= expression;
    ctx->unkeyedCollectionLiteral	= unkeyedCollectionLiteral;
    ctx->coordinateLiteral	= coordinateLiteral;
    ctx->label	= label;
    ctx->free			= GeoGenScriptDeclsFree;
    ctx->reset			= GeoGenScriptDeclsReset;
    ctx->getGrammarFileName	= getGrammarFileName;

    /* Install the scope pushing methods.
     */
    /* ruleAttributeScope(scope)
     */
    ctx->pGeoGenScriptDecls_blockPush     = pGeoGenScriptDecls_blockPush;
    ctx->pGeoGenScriptDecls_blockStack    = antlr3StackNew(0);
    ctx->pGeoGenScriptDecls_blockStack_limit    = 0;
    ctx->pGeoGenScriptDecls_blockTop      = NULL;




    /* Install the token table
     */
    PSRSTATE->tokenNames   = GeoGenScriptDeclsTokenNames;


    /* Return the newly built parser to the caller
     */
    return  ctx;
}

static void
GeoGenScriptDeclsReset (pGeoGenScriptDecls ctx)
{
    RECOGNIZER->reset(RECOGNIZER);
}

/** Free the parser resources
 */
 static void
 GeoGenScriptDeclsFree(pGeoGenScriptDecls ctx)
 {
    /* Free any scope memory
     */
    /* ruleAttributeScope(scope)
     */
    ctx->pGeoGenScriptDecls_blockStack->free(ctx->pGeoGenScriptDecls_blockStack);



	// Free this parser
	//
    ctx->pTreeParser->free(ctx->pTreeParser);

    ANTLR3_FREE(ctx);

    /* Everything is released, so we can return
     */
    return;
 }

/** Return token names used by this 
tree parser

 *
 * The returned pointer is used as an index into the token names table (using the token
 * number as the index).
 *
 * \return Pointer to first char * in the table.
 */
static pANTLR3_UINT8    *getTokenNames()
{
        return GeoGenScriptDeclsTokenNames;
}


/* Declare the bitsets
 */
/** Bitset defining follow set for error recovery in rule state: FOLLOW_SCRIPT_in_script72  */
static	ANTLR3_BITWORD FOLLOW_SCRIPT_in_script72_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_SCRIPT_in_script72	= { FOLLOW_SCRIPT_in_script72_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_metadata_in_script74  */
static	ANTLR3_BITWORD FOLLOW_metadata_in_script74_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000010000) };
static  ANTLR3_BITSET_LIST FOLLOW_metadata_in_script74	= { FOLLOW_metadata_in_script74_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_DECLARATIONS_in_script78  */
static	ANTLR3_BITWORD FOLLOW_DECLARATIONS_in_script78_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_DECLARATIONS_in_script78	= { FOLLOW_DECLARATIONS_in_script78_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_declaration_in_script80  */
static	ANTLR3_BITWORD FOLLOW_declaration_in_script80_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000880008) };
static  ANTLR3_BITSET_LIST FOLLOW_declaration_in_script80	= { FOLLOW_declaration_in_script80_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_block_in_script84  */
static	ANTLR3_BITWORD FOLLOW_block_in_script84_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_block_in_script84	= { FOLLOW_block_in_script84_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_METADATA_in_metadata103  */
static	ANTLR3_BITWORD FOLLOW_METADATA_in_metadata103_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_METADATA_in_metadata103	= { FOLLOW_METADATA_in_metadata103_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_metadataKeyValueCollection_in_metadata105  */
static	ANTLR3_BITWORD FOLLOW_metadataKeyValueCollection_in_metadata105_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_metadataKeyValueCollection_in_metadata105	= { FOLLOW_metadataKeyValueCollection_in_metadata105_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_COLLECTION_in_metadataKeyValueCollection126  */
static	ANTLR3_BITWORD FOLLOW_COLLECTION_in_metadataKeyValueCollection126_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_COLLECTION_in_metadataKeyValueCollection126	= { FOLLOW_COLLECTION_in_metadataKeyValueCollection126_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_metadataKeyValuePair_in_metadataKeyValueCollection129  */
static	ANTLR3_BITWORD FOLLOW_metadataKeyValuePair_in_metadataKeyValueCollection129_bits[]	= { ANTLR3_UINT64_LIT(0x0000000804000008) };
static  ANTLR3_BITSET_LIST FOLLOW_metadataKeyValuePair_in_metadataKeyValueCollection129	= { FOLLOW_metadataKeyValuePair_in_metadataKeyValueCollection129_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_IDENTIFIER_in_metadataKeyValuePair153  */
static	ANTLR3_BITWORD FOLLOW_IDENTIFIER_in_metadataKeyValuePair153_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_IDENTIFIER_in_metadataKeyValuePair153	= { FOLLOW_IDENTIFIER_in_metadataKeyValuePair153_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_metadataKeyValueValue_in_metadataKeyValuePair155  */
static	ANTLR3_BITWORD FOLLOW_metadataKeyValueValue_in_metadataKeyValuePair155_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_metadataKeyValueValue_in_metadataKeyValuePair155	= { FOLLOW_metadataKeyValueValue_in_metadataKeyValuePair155_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_NUMBER_in_metadataKeyValuePair164  */
static	ANTLR3_BITWORD FOLLOW_NUMBER_in_metadataKeyValuePair164_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_NUMBER_in_metadataKeyValuePair164	= { FOLLOW_NUMBER_in_metadataKeyValuePair164_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_metadataKeyValueValue_in_metadataKeyValuePair166  */
static	ANTLR3_BITWORD FOLLOW_metadataKeyValueValue_in_metadataKeyValuePair166_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000028) };
static  ANTLR3_BITSET_LIST FOLLOW_metadataKeyValueValue_in_metadataKeyValuePair166	= { FOLLOW_metadataKeyValueValue_in_metadataKeyValuePair166_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_AT_in_metadataKeyValuePair168  */
static	ANTLR3_BITWORD FOLLOW_AT_in_metadataKeyValuePair168_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_AT_in_metadataKeyValuePair168	= { FOLLOW_AT_in_metadataKeyValuePair168_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_STRING_in_metadataKeyValueValue190  */
static	ANTLR3_BITWORD FOLLOW_STRING_in_metadataKeyValueValue190_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_STRING_in_metadataKeyValueValue190	= { FOLLOW_STRING_in_metadataKeyValueValue190_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_NUMBER_in_metadataKeyValueValue198  */
static	ANTLR3_BITWORD FOLLOW_NUMBER_in_metadataKeyValueValue198_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_NUMBER_in_metadataKeyValueValue198	= { FOLLOW_NUMBER_in_metadataKeyValueValue198_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_IDENTIFIER_in_metadataKeyValueValue205  */
static	ANTLR3_BITWORD FOLLOW_IDENTIFIER_in_metadataKeyValueValue205_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_IDENTIFIER_in_metadataKeyValueValue205	= { FOLLOW_IDENTIFIER_in_metadataKeyValueValue205_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_metadataKeyValueCollection_in_metadataKeyValueValue212  */
static	ANTLR3_BITWORD FOLLOW_metadataKeyValueCollection_in_metadataKeyValueValue212_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_metadataKeyValueCollection_in_metadataKeyValueValue212	= { FOLLOW_metadataKeyValueCollection_in_metadataKeyValueValue212_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_COLLECTION_in_keyValueCollection222  */
static	ANTLR3_BITWORD FOLLOW_COLLECTION_in_keyValueCollection222_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_COLLECTION_in_keyValueCollection222	= { FOLLOW_COLLECTION_in_keyValueCollection222_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_keyValuePair_in_keyValueCollection224  */
static	ANTLR3_BITWORD FOLLOW_keyValuePair_in_keyValueCollection224_bits[]	= { ANTLR3_UINT64_LIT(0x0000000804000008) };
static  ANTLR3_BITSET_LIST FOLLOW_keyValuePair_in_keyValueCollection224	= { FOLLOW_keyValuePair_in_keyValueCollection224_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_IDENTIFIER_in_keyValuePair236  */
static	ANTLR3_BITWORD FOLLOW_IDENTIFIER_in_keyValuePair236_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_IDENTIFIER_in_keyValuePair236	= { FOLLOW_IDENTIFIER_in_keyValuePair236_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_keyValueValue_in_keyValuePair238  */
static	ANTLR3_BITWORD FOLLOW_keyValueValue_in_keyValuePair238_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_keyValueValue_in_keyValuePair238	= { FOLLOW_keyValueValue_in_keyValuePair238_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_NUMBER_in_keyValuePair245  */
static	ANTLR3_BITWORD FOLLOW_NUMBER_in_keyValuePair245_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_NUMBER_in_keyValuePair245	= { FOLLOW_NUMBER_in_keyValuePair245_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_keyValueValue_in_keyValuePair247  */
static	ANTLR3_BITWORD FOLLOW_keyValueValue_in_keyValuePair247_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000028) };
static  ANTLR3_BITSET_LIST FOLLOW_keyValueValue_in_keyValuePair247	= { FOLLOW_keyValueValue_in_keyValuePair247_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_AT_in_keyValuePair249  */
static	ANTLR3_BITWORD FOLLOW_AT_in_keyValuePair249_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_AT_in_keyValuePair249	= { FOLLOW_AT_in_keyValuePair249_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_keyValueValue258  */
static	ANTLR3_BITWORD FOLLOW_expression_in_keyValueValue258_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_keyValueValue258	= { FOLLOW_expression_in_keyValueValue258_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_keyValueCollection_in_keyValueValue262  */
static	ANTLR3_BITWORD FOLLOW_keyValueCollection_in_keyValueValue262_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_keyValueCollection_in_keyValueValue262	= { FOLLOW_keyValueCollection_in_keyValueValue262_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_enumDeclaration_in_declaration269  */
static	ANTLR3_BITWORD FOLLOW_enumDeclaration_in_declaration269_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_enumDeclaration_in_declaration269	= { FOLLOW_enumDeclaration_in_declaration269_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_functionDeclaration_in_declaration273  */
static	ANTLR3_BITWORD FOLLOW_functionDeclaration_in_declaration273_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_functionDeclaration_in_declaration273	= { FOLLOW_functionDeclaration_in_declaration273_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ENUM_in_enumDeclaration281  */
static	ANTLR3_BITWORD FOLLOW_ENUM_in_enumDeclaration281_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_ENUM_in_enumDeclaration281	= { FOLLOW_ENUM_in_enumDeclaration281_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_IDENTIFIER_in_enumDeclaration283  */
static	ANTLR3_BITWORD FOLLOW_IDENTIFIER_in_enumDeclaration283_bits[]	= { ANTLR3_UINT64_LIT(0x0000000004000008) };
static  ANTLR3_BITSET_LIST FOLLOW_IDENTIFIER_in_enumDeclaration283	= { FOLLOW_IDENTIFIER_in_enumDeclaration283_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_enumValues_in_enumDeclaration285  */
static	ANTLR3_BITWORD FOLLOW_enumValues_in_enumDeclaration285_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_enumValues_in_enumDeclaration285	= { FOLLOW_enumValues_in_enumDeclaration285_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_enumValue_in_enumValues294  */
static	ANTLR3_BITWORD FOLLOW_enumValue_in_enumValues294_bits[]	= { ANTLR3_UINT64_LIT(0x0000000004000002) };
static  ANTLR3_BITSET_LIST FOLLOW_enumValue_in_enumValues294	= { FOLLOW_enumValue_in_enumValues294_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_IDENTIFIER_in_enumValue303  */
static	ANTLR3_BITWORD FOLLOW_IDENTIFIER_in_enumValue303_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_IDENTIFIER_in_enumValue303	= { FOLLOW_IDENTIFIER_in_enumValue303_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_enumValue305  */
static	ANTLR3_BITWORD FOLLOW_expression_in_enumValue305_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_enumValue305	= { FOLLOW_expression_in_enumValue305_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_FUNCTION_in_functionDeclaration315  */
static	ANTLR3_BITWORD FOLLOW_FUNCTION_in_functionDeclaration315_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_FUNCTION_in_functionDeclaration315	= { FOLLOW_FUNCTION_in_functionDeclaration315_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_IDENTIFIER_in_functionDeclaration319  */
static	ANTLR3_BITWORD FOLLOW_IDENTIFIER_in_functionDeclaration319_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000200) };
static  ANTLR3_BITSET_LIST FOLLOW_IDENTIFIER_in_functionDeclaration319	= { FOLLOW_IDENTIFIER_in_functionDeclaration319_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_PARAMETERS_in_functionDeclaration322  */
static	ANTLR3_BITWORD FOLLOW_PARAMETERS_in_functionDeclaration322_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_PARAMETERS_in_functionDeclaration322	= { FOLLOW_PARAMETERS_in_functionDeclaration322_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_IDENTIFIER_in_functionDeclaration326  */
static	ANTLR3_BITWORD FOLLOW_IDENTIFIER_in_functionDeclaration326_bits[]	= { ANTLR3_UINT64_LIT(0x0000000004000008) };
static  ANTLR3_BITSET_LIST FOLLOW_IDENTIFIER_in_functionDeclaration326	= { FOLLOW_IDENTIFIER_in_functionDeclaration326_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_block_in_functionDeclaration330  */
static	ANTLR3_BITWORD FOLLOW_block_in_functionDeclaration330_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_block_in_functionDeclaration330	= { FOLLOW_block_in_functionDeclaration330_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_BLOCK_in_block356  */
static	ANTLR3_BITWORD FOLLOW_BLOCK_in_block356_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_BLOCK_in_block356	= { FOLLOW_BLOCK_in_block356_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_statement_in_block358  */
static	ANTLR3_BITWORD FOLLOW_statement_in_block358_bits[]	= { ANTLR3_UINT64_LIT(0xFBF2FFFA8C60C0C8), ANTLR3_UINT64_LIT(0x00000000005F057D) };
static  ANTLR3_BITSET_LIST FOLLOW_statement_in_block358	= { FOLLOW_statement_in_block358_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_BREAK_in_statement376  */
static	ANTLR3_BITWORD FOLLOW_BREAK_in_statement376_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_BREAK_in_statement376	= { FOLLOW_BREAK_in_statement376_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_CONTINUE_in_statement384  */
static	ANTLR3_BITWORD FOLLOW_CONTINUE_in_statement384_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_CONTINUE_in_statement384	= { FOLLOW_CONTINUE_in_statement384_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_variableDeclaration_in_statement392  */
static	ANTLR3_BITWORD FOLLOW_variableDeclaration_in_statement392_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_variableDeclaration_in_statement392	= { FOLLOW_variableDeclaration_in_statement392_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_statement400  */
static	ANTLR3_BITWORD FOLLOW_expression_in_statement400_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_statement400	= { FOLLOW_expression_in_statement400_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_yieldStatement_in_statement408  */
static	ANTLR3_BITWORD FOLLOW_yieldStatement_in_statement408_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_yieldStatement_in_statement408	= { FOLLOW_yieldStatement_in_statement408_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_returnStatement_in_statement416  */
static	ANTLR3_BITWORD FOLLOW_returnStatement_in_statement416_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_returnStatement_in_statement416	= { FOLLOW_returnStatement_in_statement416_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_whileStatement_in_statement424  */
static	ANTLR3_BITWORD FOLLOW_whileStatement_in_statement424_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_whileStatement_in_statement424	= { FOLLOW_whileStatement_in_statement424_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_forStatement_in_statement432  */
static	ANTLR3_BITWORD FOLLOW_forStatement_in_statement432_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_forStatement_in_statement432	= { FOLLOW_forStatement_in_statement432_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ifStatement_in_statement440  */
static	ANTLR3_BITWORD FOLLOW_ifStatement_in_statement440_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_ifStatement_in_statement440	= { FOLLOW_ifStatement_in_statement440_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_switchStatement_in_statement448  */
static	ANTLR3_BITWORD FOLLOW_switchStatement_in_statement448_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_switchStatement_in_statement448	= { FOLLOW_switchStatement_in_statement448_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_block_in_statement456  */
static	ANTLR3_BITWORD FOLLOW_block_in_statement456_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_block_in_statement456	= { FOLLOW_block_in_statement456_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_VAR_in_variableDeclaration468  */
static	ANTLR3_BITWORD FOLLOW_VAR_in_variableDeclaration468_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_VAR_in_variableDeclaration468	= { FOLLOW_VAR_in_variableDeclaration468_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_IDENTIFIER_in_variableDeclaration470  */
static	ANTLR3_BITWORD FOLLOW_IDENTIFIER_in_variableDeclaration470_bits[]	= { ANTLR3_UINT64_LIT(0xFBF2FFFA84208008), ANTLR3_UINT64_LIT(0x000000000005017D) };
static  ANTLR3_BITSET_LIST FOLLOW_IDENTIFIER_in_variableDeclaration470	= { FOLLOW_IDENTIFIER_in_variableDeclaration470_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_variableDeclaration472  */
static	ANTLR3_BITWORD FOLLOW_expression_in_variableDeclaration472_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_variableDeclaration472	= { FOLLOW_expression_in_variableDeclaration472_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_YIELD_in_yieldStatement482  */
static	ANTLR3_BITWORD FOLLOW_YIELD_in_yieldStatement482_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_YIELD_in_yieldStatement482	= { FOLLOW_YIELD_in_yieldStatement482_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_yieldStatement484  */
static	ANTLR3_BITWORD FOLLOW_expression_in_yieldStatement484_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008), ANTLR3_UINT64_LIT(0x0000000000010000) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_yieldStatement484	= { FOLLOW_expression_in_yieldStatement484_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_STRING_in_yieldStatement486  */
static	ANTLR3_BITWORD FOLLOW_STRING_in_yieldStatement486_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_STRING_in_yieldStatement486	= { FOLLOW_STRING_in_yieldStatement486_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_RETURN_in_returnStatement497  */
static	ANTLR3_BITWORD FOLLOW_RETURN_in_returnStatement497_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_RETURN_in_returnStatement497	= { FOLLOW_RETURN_in_returnStatement497_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_returnStatement499  */
static	ANTLR3_BITWORD FOLLOW_expression_in_returnStatement499_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_returnStatement499	= { FOLLOW_expression_in_returnStatement499_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_WHILE_in_whileStatement509  */
static	ANTLR3_BITWORD FOLLOW_WHILE_in_whileStatement509_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_WHILE_in_whileStatement509	= { FOLLOW_WHILE_in_whileStatement509_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_whileStatement511  */
static	ANTLR3_BITWORD FOLLOW_expression_in_whileStatement511_bits[]	= { ANTLR3_UINT64_LIT(0xFBF2FFFA8C60C0C0), ANTLR3_UINT64_LIT(0x00000000005F057D) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_whileStatement511	= { FOLLOW_expression_in_whileStatement511_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_statement_in_whileStatement513  */
static	ANTLR3_BITWORD FOLLOW_statement_in_whileStatement513_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_statement_in_whileStatement513	= { FOLLOW_statement_in_whileStatement513_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_FOR_in_forStatement523  */
static	ANTLR3_BITWORD FOLLOW_FOR_in_forStatement523_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_FOR_in_forStatement523	= { FOLLOW_FOR_in_forStatement523_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_INITIALIZATION_EXPRESSION_in_forStatement526  */
static	ANTLR3_BITWORD FOLLOW_INITIALIZATION_EXPRESSION_in_forStatement526_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_INITIALIZATION_EXPRESSION_in_forStatement526	= { FOLLOW_INITIALIZATION_EXPRESSION_in_forStatement526_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_initExpression_in_forStatement528  */
static	ANTLR3_BITWORD FOLLOW_initExpression_in_forStatement528_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_initExpression_in_forStatement528	= { FOLLOW_initExpression_in_forStatement528_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_CONDITION_EXPRESSION_in_forStatement533  */
static	ANTLR3_BITWORD FOLLOW_CONDITION_EXPRESSION_in_forStatement533_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_CONDITION_EXPRESSION_in_forStatement533	= { FOLLOW_CONDITION_EXPRESSION_in_forStatement533_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_forStatement535  */
static	ANTLR3_BITWORD FOLLOW_expression_in_forStatement535_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_forStatement535	= { FOLLOW_expression_in_forStatement535_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_INCREMENT_EXPRESSION_in_forStatement540  */
static	ANTLR3_BITWORD FOLLOW_INCREMENT_EXPRESSION_in_forStatement540_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_INCREMENT_EXPRESSION_in_forStatement540	= { FOLLOW_INCREMENT_EXPRESSION_in_forStatement540_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_forStatement542  */
static	ANTLR3_BITWORD FOLLOW_expression_in_forStatement542_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_forStatement542	= { FOLLOW_expression_in_forStatement542_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_statement_in_forStatement546  */
static	ANTLR3_BITWORD FOLLOW_statement_in_forStatement546_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_statement_in_forStatement546	= { FOLLOW_statement_in_forStatement546_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_VAR_in_initExpression560  */
static	ANTLR3_BITWORD FOLLOW_VAR_in_initExpression560_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_VAR_in_initExpression560	= { FOLLOW_VAR_in_initExpression560_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_IDENTIFIER_in_initExpression562  */
static	ANTLR3_BITWORD FOLLOW_IDENTIFIER_in_initExpression562_bits[]	= { ANTLR3_UINT64_LIT(0xFBF2FFFA84208000), ANTLR3_UINT64_LIT(0x000000000005017D) };
static  ANTLR3_BITSET_LIST FOLLOW_IDENTIFIER_in_initExpression562	= { FOLLOW_IDENTIFIER_in_initExpression562_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_initExpression564  */
static	ANTLR3_BITWORD FOLLOW_expression_in_initExpression564_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_initExpression564	= { FOLLOW_expression_in_initExpression564_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_initExpression573  */
static	ANTLR3_BITWORD FOLLOW_expression_in_initExpression573_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_initExpression573	= { FOLLOW_expression_in_initExpression573_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_IF_in_ifStatement581  */
static	ANTLR3_BITWORD FOLLOW_IF_in_ifStatement581_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_IF_in_ifStatement581	= { FOLLOW_IF_in_ifStatement581_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_ifStatement583  */
static	ANTLR3_BITWORD FOLLOW_expression_in_ifStatement583_bits[]	= { ANTLR3_UINT64_LIT(0xFBF2FFFA8C60C0C0), ANTLR3_UINT64_LIT(0x00000000005F057D) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_ifStatement583	= { FOLLOW_expression_in_ifStatement583_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_statement_in_ifStatement585  */
static	ANTLR3_BITWORD FOLLOW_statement_in_ifStatement585_bits[]	= { ANTLR3_UINT64_LIT(0xFBF2FFFA8C60C0C8), ANTLR3_UINT64_LIT(0x00000000005F057D) };
static  ANTLR3_BITSET_LIST FOLLOW_statement_in_ifStatement585	= { FOLLOW_statement_in_ifStatement585_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_statement_in_ifStatement587  */
static	ANTLR3_BITWORD FOLLOW_statement_in_ifStatement587_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_statement_in_ifStatement587	= { FOLLOW_statement_in_ifStatement587_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_SWITCH_in_switchStatement597  */
static	ANTLR3_BITWORD FOLLOW_SWITCH_in_switchStatement597_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_SWITCH_in_switchStatement597	= { FOLLOW_SWITCH_in_switchStatement597_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_switchStatement599  */
static	ANTLR3_BITWORD FOLLOW_expression_in_switchStatement599_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000020108) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_switchStatement599	= { FOLLOW_expression_in_switchStatement599_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_normalCase_in_switchStatement601  */
static	ANTLR3_BITWORD FOLLOW_normalCase_in_switchStatement601_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000020108) };
static  ANTLR3_BITSET_LIST FOLLOW_normalCase_in_switchStatement601	= { FOLLOW_normalCase_in_switchStatement601_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_defaultCase_in_switchStatement604  */
static	ANTLR3_BITWORD FOLLOW_defaultCase_in_switchStatement604_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_defaultCase_in_switchStatement604	= { FOLLOW_defaultCase_in_switchStatement604_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_CASE_in_normalCase614  */
static	ANTLR3_BITWORD FOLLOW_CASE_in_normalCase614_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_CASE_in_normalCase614	= { FOLLOW_CASE_in_normalCase614_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_label_in_normalCase616  */
static	ANTLR3_BITWORD FOLLOW_label_in_normalCase616_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000040) };
static  ANTLR3_BITSET_LIST FOLLOW_label_in_normalCase616	= { FOLLOW_label_in_normalCase616_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_BLOCK_in_normalCase619  */
static	ANTLR3_BITWORD FOLLOW_BLOCK_in_normalCase619_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_BLOCK_in_normalCase619	= { FOLLOW_BLOCK_in_normalCase619_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_statement_in_normalCase621  */
static	ANTLR3_BITWORD FOLLOW_statement_in_normalCase621_bits[]	= { ANTLR3_UINT64_LIT(0xFBF2FFFA8C60C0C8), ANTLR3_UINT64_LIT(0x00000000005F057D) };
static  ANTLR3_BITSET_LIST FOLLOW_statement_in_normalCase621	= { FOLLOW_statement_in_normalCase621_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_DEFAULT_in_defaultCase631  */
static	ANTLR3_BITWORD FOLLOW_DEFAULT_in_defaultCase631_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_DEFAULT_in_defaultCase631	= { FOLLOW_DEFAULT_in_defaultCase631_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_BLOCK_in_defaultCase634  */
static	ANTLR3_BITWORD FOLLOW_BLOCK_in_defaultCase634_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_BLOCK_in_defaultCase634	= { FOLLOW_BLOCK_in_defaultCase634_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_statement_in_defaultCase636  */
static	ANTLR3_BITWORD FOLLOW_statement_in_defaultCase636_bits[]	= { ANTLR3_UINT64_LIT(0xFBF2FFFA8C60C0C8), ANTLR3_UINT64_LIT(0x00000000005F057D) };
static  ANTLR3_BITSET_LIST FOLLOW_statement_in_defaultCase636	= { FOLLOW_statement_in_defaultCase636_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_set_in_expression648  */
static	ANTLR3_BITWORD FOLLOW_set_in_expression648_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_set_in_expression648	= { FOLLOW_set_in_expression648_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_expression696  */
static	ANTLR3_BITWORD FOLLOW_expression_in_expression696_bits[]	= { ANTLR3_UINT64_LIT(0xFBF2FFFA84208000), ANTLR3_UINT64_LIT(0x000000000005017D) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_expression696	= { FOLLOW_expression_in_expression696_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_expression698  */
static	ANTLR3_BITWORD FOLLOW_expression_in_expression698_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_expression698	= { FOLLOW_expression_in_expression698_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_OPERATOR_EXPR_IF_in_expression705  */
static	ANTLR3_BITWORD FOLLOW_OPERATOR_EXPR_IF_in_expression705_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_OPERATOR_EXPR_IF_in_expression705	= { FOLLOW_OPERATOR_EXPR_IF_in_expression705_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_expression707  */
static	ANTLR3_BITWORD FOLLOW_expression_in_expression707_bits[]	= { ANTLR3_UINT64_LIT(0xFBF2FFFA84208000), ANTLR3_UINT64_LIT(0x000000000005017D) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_expression707	= { FOLLOW_expression_in_expression707_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_expression710  */
static	ANTLR3_BITWORD FOLLOW_expression_in_expression710_bits[]	= { ANTLR3_UINT64_LIT(0xFBF2FFFA84208000), ANTLR3_UINT64_LIT(0x000000000005017D) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_expression710	= { FOLLOW_expression_in_expression710_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_expression712  */
static	ANTLR3_BITWORD FOLLOW_expression_in_expression712_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_expression712	= { FOLLOW_expression_in_expression712_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_OPERATOR_REL_OR_in_expression719  */
static	ANTLR3_BITWORD FOLLOW_OPERATOR_REL_OR_in_expression719_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_OPERATOR_REL_OR_in_expression719	= { FOLLOW_OPERATOR_REL_OR_in_expression719_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_expression721  */
static	ANTLR3_BITWORD FOLLOW_expression_in_expression721_bits[]	= { ANTLR3_UINT64_LIT(0xFBF2FFFA84208000), ANTLR3_UINT64_LIT(0x000000000005017D) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_expression721	= { FOLLOW_expression_in_expression721_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_expression723  */
static	ANTLR3_BITWORD FOLLOW_expression_in_expression723_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_expression723	= { FOLLOW_expression_in_expression723_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_OPERATOR_REL_AND_in_expression730  */
static	ANTLR3_BITWORD FOLLOW_OPERATOR_REL_AND_in_expression730_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_OPERATOR_REL_AND_in_expression730	= { FOLLOW_OPERATOR_REL_AND_in_expression730_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_expression732  */
static	ANTLR3_BITWORD FOLLOW_expression_in_expression732_bits[]	= { ANTLR3_UINT64_LIT(0xFBF2FFFA84208000), ANTLR3_UINT64_LIT(0x000000000005017D) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_expression732	= { FOLLOW_expression_in_expression732_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_expression734  */
static	ANTLR3_BITWORD FOLLOW_expression_in_expression734_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_expression734	= { FOLLOW_expression_in_expression734_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_OPERATOR_BIT_XOR_in_expression741  */
static	ANTLR3_BITWORD FOLLOW_OPERATOR_BIT_XOR_in_expression741_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_OPERATOR_BIT_XOR_in_expression741	= { FOLLOW_OPERATOR_BIT_XOR_in_expression741_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_expression743  */
static	ANTLR3_BITWORD FOLLOW_expression_in_expression743_bits[]	= { ANTLR3_UINT64_LIT(0xFBF2FFFA84208000), ANTLR3_UINT64_LIT(0x000000000005017D) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_expression743	= { FOLLOW_expression_in_expression743_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_expression745  */
static	ANTLR3_BITWORD FOLLOW_expression_in_expression745_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_expression745	= { FOLLOW_expression_in_expression745_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_OPERATOR_BIT_AND_in_expression752  */
static	ANTLR3_BITWORD FOLLOW_OPERATOR_BIT_AND_in_expression752_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_OPERATOR_BIT_AND_in_expression752	= { FOLLOW_OPERATOR_BIT_AND_in_expression752_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_expression754  */
static	ANTLR3_BITWORD FOLLOW_expression_in_expression754_bits[]	= { ANTLR3_UINT64_LIT(0xFBF2FFFA84208000), ANTLR3_UINT64_LIT(0x000000000005017D) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_expression754	= { FOLLOW_expression_in_expression754_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_expression756  */
static	ANTLR3_BITWORD FOLLOW_expression_in_expression756_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_expression756	= { FOLLOW_expression_in_expression756_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_set_in_expression763  */
static	ANTLR3_BITWORD FOLLOW_set_in_expression763_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_set_in_expression763	= { FOLLOW_set_in_expression763_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_expression771  */
static	ANTLR3_BITWORD FOLLOW_expression_in_expression771_bits[]	= { ANTLR3_UINT64_LIT(0xFBF2FFFA84208000), ANTLR3_UINT64_LIT(0x000000000005017D) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_expression771	= { FOLLOW_expression_in_expression771_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_expression773  */
static	ANTLR3_BITWORD FOLLOW_expression_in_expression773_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_expression773	= { FOLLOW_expression_in_expression773_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_set_in_expression780  */
static	ANTLR3_BITWORD FOLLOW_set_in_expression780_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_set_in_expression780	= { FOLLOW_set_in_expression780_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_expression796  */
static	ANTLR3_BITWORD FOLLOW_expression_in_expression796_bits[]	= { ANTLR3_UINT64_LIT(0xFBF2FFFA84208000), ANTLR3_UINT64_LIT(0x000000000005017D) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_expression796	= { FOLLOW_expression_in_expression796_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_expression798  */
static	ANTLR3_BITWORD FOLLOW_expression_in_expression798_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_expression798	= { FOLLOW_expression_in_expression798_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_set_in_expression805  */
static	ANTLR3_BITWORD FOLLOW_set_in_expression805_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_set_in_expression805	= { FOLLOW_set_in_expression805_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_expression813  */
static	ANTLR3_BITWORD FOLLOW_expression_in_expression813_bits[]	= { ANTLR3_UINT64_LIT(0xFBF2FFFA84208000), ANTLR3_UINT64_LIT(0x000000000005017D) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_expression813	= { FOLLOW_expression_in_expression813_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_expression815  */
static	ANTLR3_BITWORD FOLLOW_expression_in_expression815_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_expression815	= { FOLLOW_expression_in_expression815_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_set_in_expression822  */
static	ANTLR3_BITWORD FOLLOW_set_in_expression822_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_set_in_expression822	= { FOLLOW_set_in_expression822_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_expression830  */
static	ANTLR3_BITWORD FOLLOW_expression_in_expression830_bits[]	= { ANTLR3_UINT64_LIT(0xFBF2FFFA84208000), ANTLR3_UINT64_LIT(0x000000000005017D) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_expression830	= { FOLLOW_expression_in_expression830_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_expression832  */
static	ANTLR3_BITWORD FOLLOW_expression_in_expression832_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_expression832	= { FOLLOW_expression_in_expression832_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_set_in_expression839  */
static	ANTLR3_BITWORD FOLLOW_set_in_expression839_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_set_in_expression839	= { FOLLOW_set_in_expression839_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_expression851  */
static	ANTLR3_BITWORD FOLLOW_expression_in_expression851_bits[]	= { ANTLR3_UINT64_LIT(0xFBF2FFFA84208000), ANTLR3_UINT64_LIT(0x000000000005017D) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_expression851	= { FOLLOW_expression_in_expression851_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_expression853  */
static	ANTLR3_BITWORD FOLLOW_expression_in_expression853_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_expression853	= { FOLLOW_expression_in_expression853_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_OPERATOR_DOT_in_expression861  */
static	ANTLR3_BITWORD FOLLOW_OPERATOR_DOT_in_expression861_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_OPERATOR_DOT_in_expression861	= { FOLLOW_OPERATOR_DOT_in_expression861_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_expression863  */
static	ANTLR3_BITWORD FOLLOW_expression_in_expression863_bits[]	= { ANTLR3_UINT64_LIT(0xFBF2FFFA84208000), ANTLR3_UINT64_LIT(0x000000000005017D) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_expression863	= { FOLLOW_expression_in_expression863_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_expression865  */
static	ANTLR3_BITWORD FOLLOW_expression_in_expression865_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_expression865	= { FOLLOW_expression_in_expression865_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LEFT_BRACKET_in_expression872  */
static	ANTLR3_BITWORD FOLLOW_LEFT_BRACKET_in_expression872_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_LEFT_BRACKET_in_expression872	= { FOLLOW_LEFT_BRACKET_in_expression872_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_expression874  */
static	ANTLR3_BITWORD FOLLOW_expression_in_expression874_bits[]	= { ANTLR3_UINT64_LIT(0xFBF2FFFA84208008), ANTLR3_UINT64_LIT(0x000000000005017D) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_expression874	= { FOLLOW_expression_in_expression874_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_expression876  */
static	ANTLR3_BITWORD FOLLOW_expression_in_expression876_bits[]	= { ANTLR3_UINT64_LIT(0xFBF2FFFA84208008), ANTLR3_UINT64_LIT(0x000000000005017D) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_expression876	= { FOLLOW_expression_in_expression876_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LEFT_SQUARE_BRACKET_in_expression884  */
static	ANTLR3_BITWORD FOLLOW_LEFT_SQUARE_BRACKET_in_expression884_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_LEFT_SQUARE_BRACKET_in_expression884	= { FOLLOW_LEFT_SQUARE_BRACKET_in_expression884_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_expression886  */
static	ANTLR3_BITWORD FOLLOW_expression_in_expression886_bits[]	= { ANTLR3_UINT64_LIT(0xFBF2FFFA84208008), ANTLR3_UINT64_LIT(0x000000000005017D) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_expression886	= { FOLLOW_expression_in_expression886_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_expression888  */
static	ANTLR3_BITWORD FOLLOW_expression_in_expression888_bits[]	= { ANTLR3_UINT64_LIT(0xFBF2FFFA84208008), ANTLR3_UINT64_LIT(0x000000000005017D) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_expression888	= { FOLLOW_expression_in_expression888_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_IDENTIFIER_in_expression895  */
static	ANTLR3_BITWORD FOLLOW_IDENTIFIER_in_expression895_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_IDENTIFIER_in_expression895	= { FOLLOW_IDENTIFIER_in_expression895_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_coordinateLiteral_in_expression902  */
static	ANTLR3_BITWORD FOLLOW_coordinateLiteral_in_expression902_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_coordinateLiteral_in_expression902	= { FOLLOW_coordinateLiteral_in_expression902_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_TRUE_LIT_in_expression907  */
static	ANTLR3_BITWORD FOLLOW_TRUE_LIT_in_expression907_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_TRUE_LIT_in_expression907	= { FOLLOW_TRUE_LIT_in_expression907_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_FALSE_LIT_in_expression914  */
static	ANTLR3_BITWORD FOLLOW_FALSE_LIT_in_expression914_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_FALSE_LIT_in_expression914	= { FOLLOW_FALSE_LIT_in_expression914_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_NUMBER_in_expression921  */
static	ANTLR3_BITWORD FOLLOW_NUMBER_in_expression921_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_NUMBER_in_expression921	= { FOLLOW_NUMBER_in_expression921_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_STRING_in_expression928  */
static	ANTLR3_BITWORD FOLLOW_STRING_in_expression928_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_STRING_in_expression928	= { FOLLOW_STRING_in_expression928_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LEFT_CURLY_BRACKET_in_unkeyedCollectionLiteral982  */
static	ANTLR3_BITWORD FOLLOW_LEFT_CURLY_BRACKET_in_unkeyedCollectionLiteral982_bits[]	= { ANTLR3_UINT64_LIT(0xFBF2FFFA84208000), ANTLR3_UINT64_LIT(0x000000000005017D) };
static  ANTLR3_BITSET_LIST FOLLOW_LEFT_CURLY_BRACKET_in_unkeyedCollectionLiteral982	= { FOLLOW_LEFT_CURLY_BRACKET_in_unkeyedCollectionLiteral982_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_unkeyedCollectionLiteral985  */
static	ANTLR3_BITWORD FOLLOW_expression_in_unkeyedCollectionLiteral985_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000800), ANTLR3_UINT64_LIT(0x0000000000002000) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_unkeyedCollectionLiteral985	= { FOLLOW_expression_in_unkeyedCollectionLiteral985_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_COMMA_in_unkeyedCollectionLiteral988  */
static	ANTLR3_BITWORD FOLLOW_COMMA_in_unkeyedCollectionLiteral988_bits[]	= { ANTLR3_UINT64_LIT(0xFBF2FFFA84208000), ANTLR3_UINT64_LIT(0x000000000005017D) };
static  ANTLR3_BITSET_LIST FOLLOW_COMMA_in_unkeyedCollectionLiteral988	= { FOLLOW_COMMA_in_unkeyedCollectionLiteral988_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_unkeyedCollectionLiteral990  */
static	ANTLR3_BITWORD FOLLOW_expression_in_unkeyedCollectionLiteral990_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000800), ANTLR3_UINT64_LIT(0x0000000000002000) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_unkeyedCollectionLiteral990	= { FOLLOW_expression_in_unkeyedCollectionLiteral990_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_RIGTH_CURLY_BRACKET_in_unkeyedCollectionLiteral995  */
static	ANTLR3_BITWORD FOLLOW_RIGTH_CURLY_BRACKET_in_unkeyedCollectionLiteral995_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_RIGTH_CURLY_BRACKET_in_unkeyedCollectionLiteral995	= { FOLLOW_RIGTH_CURLY_BRACKET_in_unkeyedCollectionLiteral995_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_COORDINATE_in_coordinateLiteral1003  */
static	ANTLR3_BITWORD FOLLOW_COORDINATE_in_coordinateLiteral1003_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_COORDINATE_in_coordinateLiteral1003	= { FOLLOW_COORDINATE_in_coordinateLiteral1003_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_coordinateLiteral1005  */
static	ANTLR3_BITWORD FOLLOW_expression_in_coordinateLiteral1005_bits[]	= { ANTLR3_UINT64_LIT(0xFBF2FFFA84208008), ANTLR3_UINT64_LIT(0x000000000005017D) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_coordinateLiteral1005	= { FOLLOW_expression_in_coordinateLiteral1005_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_IDENTCHAIN_in_label1024  */
static	ANTLR3_BITWORD FOLLOW_IDENTCHAIN_in_label1024_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_IDENTCHAIN_in_label1024	= { FOLLOW_IDENTCHAIN_in_label1024_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_IDENTIFIER_in_label1026  */
static	ANTLR3_BITWORD FOLLOW_IDENTIFIER_in_label1026_bits[]	= { ANTLR3_UINT64_LIT(0x0000000004000008) };
static  ANTLR3_BITSET_LIST FOLLOW_IDENTIFIER_in_label1026	= { FOLLOW_IDENTIFIER_in_label1026_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_TRUE_LIT_in_label1033  */
static	ANTLR3_BITWORD FOLLOW_TRUE_LIT_in_label1033_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_TRUE_LIT_in_label1033	= { FOLLOW_TRUE_LIT_in_label1033_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_FALSE_LIT_in_label1045  */
static	ANTLR3_BITWORD FOLLOW_FALSE_LIT_in_label1045_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_FALSE_LIT_in_label1045	= { FOLLOW_FALSE_LIT_in_label1045_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_NUMBER_in_label1050  */
static	ANTLR3_BITWORD FOLLOW_NUMBER_in_label1050_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_NUMBER_in_label1050	= { FOLLOW_NUMBER_in_label1050_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_STRING_in_label1055  */
static	ANTLR3_BITWORD FOLLOW_STRING_in_label1055_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_STRING_in_label1055	= { FOLLOW_STRING_in_label1055_bits, 1	};


/* ==============================================
 * Parsing rules
 */
/**
 * $ANTLR start script
 * D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:25:1: script : ^( SCRIPT ( metadata )? ^( DECLARATIONS ( declaration )* ) block ) ;
 */
static void
script(pGeoGenScriptDecls ctx)
{
    CodeBlock* block1;
    #undef	RETURN_TYPE_block1
    #define	RETURN_TYPE_block1 CodeBlock*

    /* Initialize rule variables
     */

    {
        // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:25:7: ( ^( SCRIPT ( metadata )? ^( DECLARATIONS ( declaration )* ) block ) )
        // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:25:9: ^( SCRIPT ( metadata )? ^( DECLARATIONS ( declaration )* ) block )
        {
             MATCHT(SCRIPT, &FOLLOW_SCRIPT_in_script72);
            if  (HASEXCEPTION())
            {
                goto rulescriptEx;
            }


            MATCHT(ANTLR3_TOKEN_DOWN, NULL);
            if  (HASEXCEPTION())
            {
                goto rulescriptEx;
            }

            // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:25:18: ( metadata )?
            {
                int alt1=2;
                switch ( LA(1) )
                {
                    case METADATA:
                    	{
                    		alt1=1;
                    	}
                        break;
                }

                switch (alt1)
                {
            	case 1:
            	    // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:25:18: metadata
            	    {
            	        FOLLOWPUSH(FOLLOW_metadata_in_script74);
            	        metadata(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulescriptEx;
            	        }


            	    }
            	    break;

                }
            }

             MATCHT(DECLARATIONS, &FOLLOW_DECLARATIONS_in_script78);
            if  (HASEXCEPTION())
            {
                goto rulescriptEx;
            }


            if ( LA(1)==ANTLR3_TOKEN_DOWN ) {
                MATCHT(ANTLR3_TOKEN_DOWN, NULL);
                if  (HASEXCEPTION())
                {
                    goto rulescriptEx;
                }

                // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:25:43: ( declaration )*

                for (;;)
                {
                    int alt2=2;
                    switch ( LA(1) )
                    {
                    case ENUM:
                    case FUNCTION:
                    	{
                    		alt2=1;
                    	}
                        break;

                    }

                    switch (alt2)
                    {
                	case 1:
                	    // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:25:43: declaration
                	    {
                	        FOLLOWPUSH(FOLLOW_declaration_in_script80);
                	        declaration(ctx);

                	        FOLLOWPOP();
                	        if  (HASEXCEPTION())
                	        {
                	            goto rulescriptEx;
                	        }


                	    }
                	    break;

                	default:
                	    goto loop2;	/* break out of the loop */
                	    break;
                    }
                }
                loop2: ; /* Jump out to here if this rule does not match */


                MATCHT(ANTLR3_TOKEN_UP, NULL);
                if  (HASEXCEPTION())
                {
                    goto rulescriptEx;
                }

            }


            FOLLOWPUSH(FOLLOW_block_in_script84);
            block1=block(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulescriptEx;
            }


            MATCHT(ANTLR3_TOKEN_UP, NULL);
            if  (HASEXCEPTION())
            {
                goto rulescriptEx;
            }



            {
                 ctx->compiledScript->GetRootCodeBlock().MoveInstructionsFrom(*block1
                ); 
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto rulescriptEx; /* Prevent compiler warnings */
    rulescriptEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end script */

/**
 * $ANTLR start metadata
 * D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:27:1: metadata : ^( 'metadata' metadataKeyValueCollection ) ;
 */
static void
metadata(pGeoGenScriptDecls ctx)
{
    MetadataValue* metadataKeyValueCollection2;
    #undef	RETURN_TYPE_metadataKeyValueCollection2
    #define	RETURN_TYPE_metadataKeyValueCollection2 MetadataValue*

    /* Initialize rule variables
     */

    {
        // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:27:9: ( ^( 'metadata' metadataKeyValueCollection ) )
        // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:27:11: ^( 'metadata' metadataKeyValueCollection )
        {
             MATCHT(METADATA, &FOLLOW_METADATA_in_metadata103);
            if  (HASEXCEPTION())
            {
                goto rulemetadataEx;
            }


            MATCHT(ANTLR3_TOKEN_DOWN, NULL);
            if  (HASEXCEPTION())
            {
                goto rulemetadataEx;
            }

            FOLLOWPUSH(FOLLOW_metadataKeyValueCollection_in_metadata105);
            metadataKeyValueCollection2=metadataKeyValueCollection(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulemetadataEx;
            }


            MATCHT(ANTLR3_TOKEN_UP, NULL);
            if  (HASEXCEPTION())
            {
                goto rulemetadataEx;
            }



            {
                 ctx->compiledScript->SetMetadata(dynamic_cast<MetadataKeyValueCollection*>(metadataKeyValueCollection2
                )); 
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto rulemetadataEx; /* Prevent compiler warnings */
    rulemetadataEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end metadata */

/**
 * $ANTLR start metadataKeyValueCollection
 * D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:29:1: metadataKeyValueCollection returns [MetadataValue* value] : ^( COLLECTION ( metadataKeyValuePair )* ) ;
 */
static MetadataValue*
metadataKeyValueCollection(pGeoGenScriptDecls ctx)
{
    MetadataValue* value;


    GeoGenScriptDecls_metadataKeyValuePair_return metadataKeyValuePair3;
    #undef	RETURN_TYPE_metadataKeyValuePair3
    #define	RETURN_TYPE_metadataKeyValuePair3 GeoGenScriptDecls_metadataKeyValuePair_return

    /* Initialize rule variables
     */


    	MetadataKeyValueCollection* ret = new MetadataKeyValueCollection();
    	value= ret;
    	

    {
        // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:33:3: ( ^( COLLECTION ( metadataKeyValuePair )* ) )
        // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:33:5: ^( COLLECTION ( metadataKeyValuePair )* )
        {
             MATCHT(COLLECTION, &FOLLOW_COLLECTION_in_metadataKeyValueCollection126);
            if  (HASEXCEPTION())
            {
                goto rulemetadataKeyValueCollectionEx;
            }


            if ( LA(1)==ANTLR3_TOKEN_DOWN ) {
                MATCHT(ANTLR3_TOKEN_DOWN, NULL);
                if  (HASEXCEPTION())
                {
                    goto rulemetadataKeyValueCollectionEx;
                }

                // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:33:18: ( metadataKeyValuePair )*

                for (;;)
                {
                    int alt3=2;
                    switch ( LA(1) )
                    {
                    case IDENTIFIER:
                    case NUMBER:
                    	{
                    		alt3=1;
                    	}
                        break;

                    }

                    switch (alt3)
                    {
                	case 1:
                	    // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:33:19: metadataKeyValuePair
                	    {
                	        FOLLOWPUSH(FOLLOW_metadataKeyValuePair_in_metadataKeyValueCollection129);
                	        metadataKeyValuePair3=metadataKeyValuePair(ctx);

                	        FOLLOWPOP();
                	        if  (HASEXCEPTION())
                	        {
                	            goto rulemetadataKeyValueCollectionEx;
                	        }


                	        {
                	             ret->AddItem(metadataKeyValuePair3.name
                	            , metadataKeyValuePair3.value
                	            ); 
                	        }


                	    }
                	    break;

                	default:
                	    goto loop3;	/* break out of the loop */
                	    break;
                    }
                }
                loop3: ; /* Jump out to here if this rule does not match */


                MATCHT(ANTLR3_TOKEN_UP, NULL);
                if  (HASEXCEPTION())
                {
                    goto rulemetadataKeyValueCollectionEx;
                }

            }


        }

    }

    // This is where rules clean up and exit
    //
    goto rulemetadataKeyValueCollectionEx; /* Prevent compiler warnings */
    rulemetadataKeyValueCollectionEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return value;
}
/* $ANTLR end metadataKeyValueCollection */

/**
 * $ANTLR start metadataKeyValuePair
 * D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:35:1: metadataKeyValuePair returns [std::string name, MetadataValue* value] : ( ^( IDENTIFIER metadataKeyValueValue ) | ^( NUMBER metadataKeyValueValue ( '@' )? ) );
 */
static GeoGenScriptDecls_metadataKeyValuePair_return
metadataKeyValuePair(pGeoGenScriptDecls ctx)
{
    GeoGenScriptDecls_metadataKeyValuePair_return retval;


    pANTLR3_BASE_TREE    IDENTIFIER4;
    pANTLR3_BASE_TREE    NUMBER6;
    MetadataValue* metadataKeyValueValue5;
    #undef	RETURN_TYPE_metadataKeyValueValue5
    #define	RETURN_TYPE_metadataKeyValueValue5 MetadataValue*

    MetadataValue* metadataKeyValueValue7;
    #undef	RETURN_TYPE_metadataKeyValueValue7
    #define	RETURN_TYPE_metadataKeyValueValue7 MetadataValue*

    /* Initialize rule variables
     */

     retval.value= NULL;
     
    IDENTIFIER4       = NULL;
    NUMBER6       = NULL;
    retval.start = LT(1); retval.stop = retval.start;


    {
        {
            //  D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:35:94: ( ^( IDENTIFIER metadataKeyValueValue ) | ^( NUMBER metadataKeyValueValue ( '@' )? ) )

            ANTLR3_UINT32 alt5;

            alt5=2;

            switch ( LA(1) )
            {
            case IDENTIFIER:
            	{
            		alt5=1;
            	}
                break;
            case NUMBER:
            	{
            		alt5=2;
            	}
                break;

            default:
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 5;
                EXCEPTION->state        = 0;


                goto rulemetadataKeyValuePairEx;

            }

            switch (alt5)
            {
        	case 1:
        	    // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:36:2: ^( IDENTIFIER metadataKeyValueValue )
        	    {
        	        IDENTIFIER4 = (pANTLR3_BASE_TREE) MATCHT(IDENTIFIER, &FOLLOW_IDENTIFIER_in_metadataKeyValuePair153);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulemetadataKeyValuePairEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_DOWN, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulemetadataKeyValuePairEx;
        	        }

        	        FOLLOWPUSH(FOLLOW_metadataKeyValueValue_in_metadataKeyValuePair155);
        	        metadataKeyValueValue5=metadataKeyValueValue(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulemetadataKeyValuePairEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_UP, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulemetadataKeyValuePairEx;
        	        }



        	        {
        	             retval.name= (char*)(IDENTIFIER4->getText(IDENTIFIER4))->chars;
        	             retval.value= 
        	            metadataKeyValueValue5
        	            ;
        	             
        	        }


        	    }
        	    break;
        	case 2:
        	    // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:37:4: ^( NUMBER metadataKeyValueValue ( '@' )? )
        	    {
        	        NUMBER6 = (pANTLR3_BASE_TREE) MATCHT(NUMBER, &FOLLOW_NUMBER_in_metadataKeyValuePair164);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulemetadataKeyValuePairEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_DOWN, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulemetadataKeyValuePairEx;
        	        }

        	        FOLLOWPUSH(FOLLOW_metadataKeyValueValue_in_metadataKeyValuePair166);
        	        metadataKeyValueValue7=metadataKeyValueValue(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulemetadataKeyValuePairEx;
        	        }


        	        // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:37:35: ( '@' )?
        	        {
        	            int alt4=2;
        	            switch ( LA(1) )
        	            {
        	                case AT:
        	                	{
        	                		alt4=1;
        	                	}
        	                    break;
        	            }

        	            switch (alt4)
        	            {
        	        	case 1:
        	        	    // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:37:35: '@'
        	        	    {
        	        	         MATCHT(AT, &FOLLOW_AT_in_metadataKeyValuePair168);
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto rulemetadataKeyValuePairEx;
        	        	        }


        	        	    }
        	        	    break;

        	            }
        	        }

        	        MATCHT(ANTLR3_TOKEN_UP, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulemetadataKeyValuePairEx;
        	        }



        	        {
        	             retval.name= (char*)(NUMBER6->getText(NUMBER6))->chars;
        	             retval.value= 
        	            metadataKeyValueValue7
        	            ;
        	             
        	        }


        	    }
        	    break;

            }
        }
    }

    // This is where rules clean up and exit
    //
    goto rulemetadataKeyValuePairEx; /* Prevent compiler warnings */
    rulemetadataKeyValuePairEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return retval;
}
/* $ANTLR end metadataKeyValuePair */

/**
 * $ANTLR start metadataKeyValueValue
 * D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:39:1: metadataKeyValueValue returns [MetadataValue* value] : ( STRING | NUMBER | IDENTIFIER | metadataKeyValueCollection );
 */
static MetadataValue*
metadataKeyValueValue(pGeoGenScriptDecls ctx)
{
    MetadataValue* value;


    pANTLR3_BASE_TREE    STRING8;
    pANTLR3_BASE_TREE    IDENTIFIER9;
    MetadataValue* metadataKeyValueCollection10;
    #undef	RETURN_TYPE_metadataKeyValueCollection10
    #define	RETURN_TYPE_metadataKeyValueCollection10 MetadataValue*

    /* Initialize rule variables
     */

     value= NULL;
     
    STRING8       = NULL;
    IDENTIFIER9       = NULL;

    {
        {
            //  D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:39:77: ( STRING | NUMBER | IDENTIFIER | metadataKeyValueCollection )

            ANTLR3_UINT32 alt6;

            alt6=4;

            switch ( LA(1) )
            {
            case STRING:
            	{
            		alt6=1;
            	}
                break;
            case NUMBER:
            	{
            		alt6=2;
            	}
                break;
            case IDENTIFIER:
            	{
            		alt6=3;
            	}
                break;
            case COLLECTION:
            	{
            		alt6=4;
            	}
                break;

            default:
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 6;
                EXCEPTION->state        = 0;


                goto rulemetadataKeyValueValueEx;

            }

            switch (alt6)
            {
        	case 1:
        	    // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:40:2: STRING
        	    {
        	        STRING8 = (pANTLR3_BASE_TREE) MATCHT(STRING, &FOLLOW_STRING_in_metadataKeyValueValue190);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulemetadataKeyValueValueEx;
        	        }


        	        {
        	             value= new MetadataString((char*)(STRING8->getText(STRING8))->chars);
        	             
        	        }


        	    }
        	    break;
        	case 2:
        	    // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:41:4: NUMBER
        	    {
        	         MATCHT(NUMBER, &FOLLOW_NUMBER_in_metadataKeyValueValue198);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulemetadataKeyValueValueEx;
        	        }


        	        {
        	             value= new MetadataNumber(0);
        	             
        	        }


        	    }
        	    break;
        	case 3:
        	    // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:42:4: IDENTIFIER
        	    {
        	        IDENTIFIER9 = (pANTLR3_BASE_TREE) MATCHT(IDENTIFIER, &FOLLOW_IDENTIFIER_in_metadataKeyValueValue205);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulemetadataKeyValueValueEx;
        	        }


        	        {
        	             value= new MetadataIdentifier((char*)(IDENTIFIER9->getText(IDENTIFIER9))->chars);
        	             
        	        }


        	    }
        	    break;
        	case 4:
        	    // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:43:4: metadataKeyValueCollection
        	    {
        	        FOLLOWPUSH(FOLLOW_metadataKeyValueCollection_in_metadataKeyValueValue212);
        	        metadataKeyValueCollection10=metadataKeyValueCollection(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulemetadataKeyValueValueEx;
        	        }


        	        {
        	             value= 
        	            metadataKeyValueCollection10
        	            ;
        	             
        	        }


        	    }
        	    break;

            }
        }
    }

    // This is where rules clean up and exit
    //
    goto rulemetadataKeyValueValueEx; /* Prevent compiler warnings */
    rulemetadataKeyValueValueEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return value;
}
/* $ANTLR end metadataKeyValueValue */

/**
 * $ANTLR start keyValueCollection
 * D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:45:1: keyValueCollection : ^( COLLECTION ( keyValuePair )* ) ;
 */
static void
keyValueCollection(pGeoGenScriptDecls ctx)
{
    /* Initialize rule variables
     */

    {
        // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:45:19: ( ^( COLLECTION ( keyValuePair )* ) )
        // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:45:21: ^( COLLECTION ( keyValuePair )* )
        {
             MATCHT(COLLECTION, &FOLLOW_COLLECTION_in_keyValueCollection222);
            if  (HASEXCEPTION())
            {
                goto rulekeyValueCollectionEx;
            }


            if ( LA(1)==ANTLR3_TOKEN_DOWN ) {
                MATCHT(ANTLR3_TOKEN_DOWN, NULL);
                if  (HASEXCEPTION())
                {
                    goto rulekeyValueCollectionEx;
                }

                // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:45:34: ( keyValuePair )*

                for (;;)
                {
                    int alt7=2;
                    switch ( LA(1) )
                    {
                    case IDENTIFIER:
                    case NUMBER:
                    	{
                    		alt7=1;
                    	}
                        break;

                    }

                    switch (alt7)
                    {
                	case 1:
                	    // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:45:34: keyValuePair
                	    {
                	        FOLLOWPUSH(FOLLOW_keyValuePair_in_keyValueCollection224);
                	        keyValuePair(ctx);

                	        FOLLOWPOP();
                	        if  (HASEXCEPTION())
                	        {
                	            goto rulekeyValueCollectionEx;
                	        }


                	    }
                	    break;

                	default:
                	    goto loop7;	/* break out of the loop */
                	    break;
                    }
                }
                loop7: ; /* Jump out to here if this rule does not match */


                MATCHT(ANTLR3_TOKEN_UP, NULL);
                if  (HASEXCEPTION())
                {
                    goto rulekeyValueCollectionEx;
                }

            }


        }

    }

    // This is where rules clean up and exit
    //
    goto rulekeyValueCollectionEx; /* Prevent compiler warnings */
    rulekeyValueCollectionEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end keyValueCollection */

/**
 * $ANTLR start keyValuePair
 * D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:47:1: keyValuePair : ( ^( IDENTIFIER keyValueValue ) | ^( NUMBER keyValueValue ( '@' )? ) );
 */
static void
keyValuePair(pGeoGenScriptDecls ctx)
{
    /* Initialize rule variables
     */

    {
        {
            //  D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:47:13: ( ^( IDENTIFIER keyValueValue ) | ^( NUMBER keyValueValue ( '@' )? ) )

            ANTLR3_UINT32 alt9;

            alt9=2;

            switch ( LA(1) )
            {
            case IDENTIFIER:
            	{
            		alt9=1;
            	}
                break;
            case NUMBER:
            	{
            		alt9=2;
            	}
                break;

            default:
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 9;
                EXCEPTION->state        = 0;


                goto rulekeyValuePairEx;

            }

            switch (alt9)
            {
        	case 1:
        	    // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:48:2: ^( IDENTIFIER keyValueValue )
        	    {
        	         MATCHT(IDENTIFIER, &FOLLOW_IDENTIFIER_in_keyValuePair236);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulekeyValuePairEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_DOWN, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulekeyValuePairEx;
        	        }

        	        FOLLOWPUSH(FOLLOW_keyValueValue_in_keyValuePair238);
        	        keyValueValue(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulekeyValuePairEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_UP, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulekeyValuePairEx;
        	        }



        	    }
        	    break;
        	case 2:
        	    // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:49:4: ^( NUMBER keyValueValue ( '@' )? )
        	    {
        	         MATCHT(NUMBER, &FOLLOW_NUMBER_in_keyValuePair245);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulekeyValuePairEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_DOWN, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulekeyValuePairEx;
        	        }

        	        FOLLOWPUSH(FOLLOW_keyValueValue_in_keyValuePair247);
        	        keyValueValue(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulekeyValuePairEx;
        	        }


        	        // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:49:27: ( '@' )?
        	        {
        	            int alt8=2;
        	            switch ( LA(1) )
        	            {
        	                case AT:
        	                	{
        	                		alt8=1;
        	                	}
        	                    break;
        	            }

        	            switch (alt8)
        	            {
        	        	case 1:
        	        	    // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:49:27: '@'
        	        	    {
        	        	         MATCHT(AT, &FOLLOW_AT_in_keyValuePair249);
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto rulekeyValuePairEx;
        	        	        }


        	        	    }
        	        	    break;

        	            }
        	        }

        	        MATCHT(ANTLR3_TOKEN_UP, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulekeyValuePairEx;
        	        }



        	    }
        	    break;

            }
        }
    }

    // This is where rules clean up and exit
    //
    goto rulekeyValuePairEx; /* Prevent compiler warnings */
    rulekeyValuePairEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end keyValuePair */

/**
 * $ANTLR start keyValueValue
 * D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:51:1: keyValueValue : ( expression | keyValueCollection );
 */
static void
keyValueValue(pGeoGenScriptDecls ctx)
{
    /* Initialize rule variables
     */

    {
        {
            //  D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:51:14: ( expression | keyValueCollection )

            ANTLR3_UINT32 alt10;

            alt10=2;

            switch ( LA(1) )
            {
            case COORDINATE:
            case FALSE_LIT:
            case IDENTIFIER:
            case LEFT_BRACKET:
            case LEFT_SQUARE_BRACKET:
            case NUMBER:
            case OPERATOR_ASSIGN:
            case OPERATOR_ASSIGN_AND:
            case OPERATOR_ASSIGN_DIVIDE:
            case OPERATOR_ASSIGN_LSHIFT:
            case OPERATOR_ASSIGN_MINUS:
            case OPERATOR_ASSIGN_MODULO:
            case OPERATOR_ASSIGN_OR:
            case OPERATOR_ASSIGN_PLUS:
            case OPERATOR_ASSIGN_RSHIFT:
            case OPERATOR_ASSIGN_TIMES:
            case OPERATOR_ASSIGN_XOR:
            case OPERATOR_BIT_AND:
            case OPERATOR_BIT_XOR:
            case OPERATOR_DIVIDE:
            case OPERATOR_DOT:
            case OPERATOR_EQUAL_TO:
            case OPERATOR_EXPR_IF:
            case OPERATOR_GREATER_THAN:
            case OPERATOR_GREATER_THAN_OR_EQUAL_TO:
            case OPERATOR_IS:
            case OPERATOR_LESS_THAN:
            case OPERATOR_LESS_THAN_OR_EQUAL_TO:
            case OPERATOR_LSHIFT:
            case OPERATOR_MINUS:
            case OPERATOR_MODULO:
            case OPERATOR_NOT_EQUAL_TO:
            case OPERATOR_PLUS:
            case OPERATOR_REL_AND:
            case OPERATOR_REL_OR:
            case OPERATOR_RSHIFT:
            case OPERATOR_TIMES:
            case STRING:
            case TRUE_LIT:
            	{
            		alt10=1;
            	}
                break;
            case COLLECTION:
            	{
            		alt10=2;
            	}
                break;

            default:
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 10;
                EXCEPTION->state        = 0;


                goto rulekeyValueValueEx;

            }

            switch (alt10)
            {
        	case 1:
        	    // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:51:16: expression
        	    {
        	        FOLLOWPUSH(FOLLOW_expression_in_keyValueValue258);
        	        expression(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulekeyValueValueEx;
        	        }


        	    }
        	    break;
        	case 2:
        	    // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:51:29: keyValueCollection
        	    {
        	        FOLLOWPUSH(FOLLOW_keyValueCollection_in_keyValueValue262);
        	        keyValueCollection(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulekeyValueValueEx;
        	        }


        	    }
        	    break;

            }
        }
    }

    // This is where rules clean up and exit
    //
    goto rulekeyValueValueEx; /* Prevent compiler warnings */
    rulekeyValueValueEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end keyValueValue */

/**
 * $ANTLR start declaration
 * D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:53:1: declaration : ( enumDeclaration | functionDeclaration );
 */
static void
declaration(pGeoGenScriptDecls ctx)
{
    /* Initialize rule variables
     */

    {
        {
            //  D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:53:12: ( enumDeclaration | functionDeclaration )

            ANTLR3_UINT32 alt11;

            alt11=2;

            switch ( LA(1) )
            {
            case ENUM:
            	{
            		alt11=1;
            	}
                break;
            case FUNCTION:
            	{
            		alt11=2;
            	}
                break;

            default:
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 11;
                EXCEPTION->state        = 0;


                goto ruledeclarationEx;

            }

            switch (alt11)
            {
        	case 1:
        	    // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:53:14: enumDeclaration
        	    {
        	        FOLLOWPUSH(FOLLOW_enumDeclaration_in_declaration269);
        	        enumDeclaration(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruledeclarationEx;
        	        }


        	    }
        	    break;
        	case 2:
        	    // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:53:32: functionDeclaration
        	    {
        	        FOLLOWPUSH(FOLLOW_functionDeclaration_in_declaration273);
        	        functionDeclaration(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruledeclarationEx;
        	        }


        	    }
        	    break;

            }
        }
    }

    // This is where rules clean up and exit
    //
    goto ruledeclarationEx; /* Prevent compiler warnings */
    ruledeclarationEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end declaration */

/**
 * $ANTLR start enumDeclaration
 * D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:55:1: enumDeclaration : ^( 'enum' IDENTIFIER ( enumValues )? ) ;
 */
static void
enumDeclaration(pGeoGenScriptDecls ctx)
{
    /* Initialize rule variables
     */

    {
        // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:55:16: ( ^( 'enum' IDENTIFIER ( enumValues )? ) )
        // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:55:18: ^( 'enum' IDENTIFIER ( enumValues )? )
        {
             MATCHT(ENUM, &FOLLOW_ENUM_in_enumDeclaration281);
            if  (HASEXCEPTION())
            {
                goto ruleenumDeclarationEx;
            }


            MATCHT(ANTLR3_TOKEN_DOWN, NULL);
            if  (HASEXCEPTION())
            {
                goto ruleenumDeclarationEx;
            }

             MATCHT(IDENTIFIER, &FOLLOW_IDENTIFIER_in_enumDeclaration283);
            if  (HASEXCEPTION())
            {
                goto ruleenumDeclarationEx;
            }


            // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:55:38: ( enumValues )?
            {
                int alt12=2;
                switch ( LA(1) )
                {
                    case IDENTIFIER:
                    	{
                    		alt12=1;
                    	}
                        break;
                }

                switch (alt12)
                {
            	case 1:
            	    // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:55:38: enumValues
            	    {
            	        FOLLOWPUSH(FOLLOW_enumValues_in_enumDeclaration285);
            	        enumValues(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleenumDeclarationEx;
            	        }


            	    }
            	    break;

                }
            }

            MATCHT(ANTLR3_TOKEN_UP, NULL);
            if  (HASEXCEPTION())
            {
                goto ruleenumDeclarationEx;
            }



        }

    }

    // This is where rules clean up and exit
    //
    goto ruleenumDeclarationEx; /* Prevent compiler warnings */
    ruleenumDeclarationEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end enumDeclaration */

/**
 * $ANTLR start enumValues
 * D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:57:1: enumValues : ( enumValue )+ ;
 */
static void
enumValues(pGeoGenScriptDecls ctx)
{
    /* Initialize rule variables
     */

    {
        // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:57:11: ( ( enumValue )+ )
        // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:57:13: ( enumValue )+
        {
            // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:57:13: ( enumValue )+
            {
                int cnt13=0;

                for (;;)
                {
                    int alt13=2;
            	switch ( LA(1) )
            	{
            	case IDENTIFIER:
            		{
            			alt13=1;
            		}
            	    break;

            	}

            	switch (alt13)
            	{
            	    case 1:
            	        // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:57:13: enumValue
            	        {
            	            FOLLOWPUSH(FOLLOW_enumValue_in_enumValues294);
            	            enumValue(ctx);

            	            FOLLOWPOP();
            	            if  (HASEXCEPTION())
            	            {
            	                goto ruleenumValuesEx;
            	            }


            	        }
            	        break;

            	    default:

            		if ( cnt13 >= 1 )
            		{
            		    goto loop13;
            		}
            		/* mismatchedSetEx()
            		 */
            		CONSTRUCTEX();
            		EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;
            		EXCEPTION->name = (void *)ANTLR3_EARLY_EXIT_NAME;


            		goto ruleenumValuesEx;
            	}
            	cnt13++;
                }
                loop13: ;	/* Jump to here if this rule does not match */
            }

        }

    }

    // This is where rules clean up and exit
    //
    goto ruleenumValuesEx; /* Prevent compiler warnings */
    ruleenumValuesEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end enumValues */

/**
 * $ANTLR start enumValue
 * D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:59:1: enumValue : ^( IDENTIFIER ( expression )? ) ;
 */
static void
enumValue(pGeoGenScriptDecls ctx)
{
    /* Initialize rule variables
     */

    {
        // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:59:10: ( ^( IDENTIFIER ( expression )? ) )
        // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:59:12: ^( IDENTIFIER ( expression )? )
        {
             MATCHT(IDENTIFIER, &FOLLOW_IDENTIFIER_in_enumValue303);
            if  (HASEXCEPTION())
            {
                goto ruleenumValueEx;
            }


            if ( LA(1)==ANTLR3_TOKEN_DOWN ) {
                MATCHT(ANTLR3_TOKEN_DOWN, NULL);
                if  (HASEXCEPTION())
                {
                    goto ruleenumValueEx;
                }

                // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:59:25: ( expression )?
                {
                    int alt14=2;
                    switch ( LA(1) )
                    {
                        case COORDINATE:
                        case FALSE_LIT:
                        case IDENTIFIER:
                        case LEFT_BRACKET:
                        case LEFT_SQUARE_BRACKET:
                        case NUMBER:
                        case OPERATOR_ASSIGN:
                        case OPERATOR_ASSIGN_AND:
                        case OPERATOR_ASSIGN_DIVIDE:
                        case OPERATOR_ASSIGN_LSHIFT:
                        case OPERATOR_ASSIGN_MINUS:
                        case OPERATOR_ASSIGN_MODULO:
                        case OPERATOR_ASSIGN_OR:
                        case OPERATOR_ASSIGN_PLUS:
                        case OPERATOR_ASSIGN_RSHIFT:
                        case OPERATOR_ASSIGN_TIMES:
                        case OPERATOR_ASSIGN_XOR:
                        case OPERATOR_BIT_AND:
                        case OPERATOR_BIT_XOR:
                        case OPERATOR_DIVIDE:
                        case OPERATOR_DOT:
                        case OPERATOR_EQUAL_TO:
                        case OPERATOR_EXPR_IF:
                        case OPERATOR_GREATER_THAN:
                        case OPERATOR_GREATER_THAN_OR_EQUAL_TO:
                        case OPERATOR_IS:
                        case OPERATOR_LESS_THAN:
                        case OPERATOR_LESS_THAN_OR_EQUAL_TO:
                        case OPERATOR_LSHIFT:
                        case OPERATOR_MINUS:
                        case OPERATOR_MODULO:
                        case OPERATOR_NOT_EQUAL_TO:
                        case OPERATOR_PLUS:
                        case OPERATOR_REL_AND:
                        case OPERATOR_REL_OR:
                        case OPERATOR_RSHIFT:
                        case OPERATOR_TIMES:
                        case STRING:
                        case TRUE_LIT:
                        	{
                        		alt14=1;
                        	}
                            break;
                    }

                    switch (alt14)
                    {
                	case 1:
                	    // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:59:25: expression
                	    {
                	        FOLLOWPUSH(FOLLOW_expression_in_enumValue305);
                	        expression(ctx);

                	        FOLLOWPOP();
                	        if  (HASEXCEPTION())
                	        {
                	            goto ruleenumValueEx;
                	        }


                	    }
                	    break;

                    }
                }

                MATCHT(ANTLR3_TOKEN_UP, NULL);
                if  (HASEXCEPTION())
                {
                    goto ruleenumValueEx;
                }

            }


        }

    }

    // This is where rules clean up and exit
    //
    goto ruleenumValueEx; /* Prevent compiler warnings */
    ruleenumValueEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end enumValue */

/**
 * $ANTLR start functionDeclaration
 * D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:61:1: functionDeclaration : ^( 'function' name= IDENTIFIER ^( PARAMETERS (formalParameters+= IDENTIFIER )* ) block ) ;
 */
static void
functionDeclaration(pGeoGenScriptDecls ctx)
{
    pANTLR3_BASE_TREE    name;
    pANTLR3_BASE_TREE    formalParameters;
    pANTLR3_VECTOR    list_formalParameters;

    /* Initialize rule variables
     */

    name       = NULL;
    formalParameters       = NULL;
    list_formalParameters     = NULL;

    {
        // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:61:20: ( ^( 'function' name= IDENTIFIER ^( PARAMETERS (formalParameters+= IDENTIFIER )* ) block ) )
        // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:61:22: ^( 'function' name= IDENTIFIER ^( PARAMETERS (formalParameters+= IDENTIFIER )* ) block )
        {
             MATCHT(FUNCTION, &FOLLOW_FUNCTION_in_functionDeclaration315);
            if  (HASEXCEPTION())
            {
                goto rulefunctionDeclarationEx;
            }


            MATCHT(ANTLR3_TOKEN_DOWN, NULL);
            if  (HASEXCEPTION())
            {
                goto rulefunctionDeclarationEx;
            }

            name = (pANTLR3_BASE_TREE) MATCHT(IDENTIFIER, &FOLLOW_IDENTIFIER_in_functionDeclaration319);
            if  (HASEXCEPTION())
            {
                goto rulefunctionDeclarationEx;
            }


             MATCHT(PARAMETERS, &FOLLOW_PARAMETERS_in_functionDeclaration322);
            if  (HASEXCEPTION())
            {
                goto rulefunctionDeclarationEx;
            }


            if ( LA(1)==ANTLR3_TOKEN_DOWN ) {
                MATCHT(ANTLR3_TOKEN_DOWN, NULL);
                if  (HASEXCEPTION())
                {
                    goto rulefunctionDeclarationEx;
                }

                // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:61:80: (formalParameters+= IDENTIFIER )*

                for (;;)
                {
                    int alt15=2;
                    switch ( LA(1) )
                    {
                    case IDENTIFIER:
                    	{
                    		alt15=1;
                    	}
                        break;

                    }

                    switch (alt15)
                    {
                	case 1:
                	    // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:61:80: formalParameters+= IDENTIFIER
                	    {
                	        formalParameters = (pANTLR3_BASE_TREE) MATCHT(IDENTIFIER, &FOLLOW_IDENTIFIER_in_functionDeclaration326);
                	        if  (HASEXCEPTION())
                	        {
                	            goto rulefunctionDeclarationEx;
                	        }

                	        if (list_formalParameters == NULL)
                	        {
                	            list_formalParameters=ctx->vectors->newVector(ctx->vectors);
                	        }
                	        list_formalParameters->add(list_formalParameters, formalParameters, NULL);

                	    }
                	    break;

                	default:
                	    goto loop15;	/* break out of the loop */
                	    break;
                    }
                }
                loop15: ; /* Jump out to here if this rule does not match */


                MATCHT(ANTLR3_TOKEN_UP, NULL);
                if  (HASEXCEPTION())
                {
                    goto rulefunctionDeclarationEx;
                }

            }


            FOLLOWPUSH(FOLLOW_block_in_functionDeclaration330);
            block(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulefunctionDeclarationEx;
            }


            MATCHT(ANTLR3_TOKEN_UP, NULL);
            if  (HASEXCEPTION())
            {
                goto rulefunctionDeclarationEx;
            }



            {

                	ScriptFunctionDefinition* decl = new ScriptFunctionDefinition((char*)(name->getText(name))->chars, list_formalParameters != NULL ? list_formalParameters->count : 0);
                	
                	if(list_formalParameters != NULL)
                	{
                	        SymbolDefinitionTable<VariableDefinition>& varDecls = decl->GetLocalVariableDefinitions();
                	        CodeBlock& codeBlock = decl->GetRootCodeBlock();
                	        for(int i = 0; i < list_formalParameters->count; i++)
                	        {
                			pANTLR3_BASE_TREE tree = (pANTLR3_BASE_TREE)list_formalParameters->elements[i].element;
                			varDecls.AddItem(new ScriptVariableDefinition(std::string((char*)tree->getText(tree)->chars)));
                		        codeBlock.AddInstruction(new instructions::StoreLocalValueInstruction(i));	
                		}
                	             	
                	        codeBlock.MoveInstructionsFrom(CodeBlock());
                	}

                        ctx->compiledScript->GetGlobalFunctionDefinitions().AddItem(decl);
                        ctx->compiledScript->GetSymbolNameTable().AddName(decl->GetName());

            }


        }

    }

    // This is where rules clean up and exit
    //
    goto rulefunctionDeclarationEx; /* Prevent compiler warnings */
    rulefunctionDeclarationEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end functionDeclaration */

/**
 * $ANTLR start block
 * D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:82:1: block returns [CodeBlock* returnCodeBlock] : ^( BLOCK ( statement )* ) ;
 */
static CodeBlock*
block(pGeoGenScriptDecls ctx)
{
    CodeBlock* returnCodeBlock;


    /* Initialize rule variables
     */
    ctx->pGeoGenScriptDecls_blockTop = pGeoGenScriptDecls_blockPush(ctx);
     (SCOPE_TOP(block))->codeBlock= new CodeBlock(); 
    returnCodeBlock= (SCOPE_TOP(block))->codeBlock;
     
    {
        // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:85:3: ( ^( BLOCK ( statement )* ) )
        // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:85:3: ^( BLOCK ( statement )* )
        {
             MATCHT(BLOCK, &FOLLOW_BLOCK_in_block356);
            if  (HASEXCEPTION())
            {
                goto ruleblockEx;
            }


            if ( LA(1)==ANTLR3_TOKEN_DOWN ) {
                MATCHT(ANTLR3_TOKEN_DOWN, NULL);
                if  (HASEXCEPTION())
                {
                    goto ruleblockEx;
                }

                // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:85:11: ( statement )*

                for (;;)
                {
                    int alt16=2;
                    switch ( LA(1) )
                    {
                    case BLOCK:
                    case BREAK:
                    case CONTINUE:
                    case COORDINATE:
                    case FALSE_LIT:
                    case FOR:
                    case IDENTIFIER:
                    case IF:
                    case LEFT_BRACKET:
                    case LEFT_SQUARE_BRACKET:
                    case NUMBER:
                    case OPERATOR_ASSIGN:
                    case OPERATOR_ASSIGN_AND:
                    case OPERATOR_ASSIGN_DIVIDE:
                    case OPERATOR_ASSIGN_LSHIFT:
                    case OPERATOR_ASSIGN_MINUS:
                    case OPERATOR_ASSIGN_MODULO:
                    case OPERATOR_ASSIGN_OR:
                    case OPERATOR_ASSIGN_PLUS:
                    case OPERATOR_ASSIGN_RSHIFT:
                    case OPERATOR_ASSIGN_TIMES:
                    case OPERATOR_ASSIGN_XOR:
                    case OPERATOR_BIT_AND:
                    case OPERATOR_BIT_XOR:
                    case OPERATOR_DIVIDE:
                    case OPERATOR_DOT:
                    case OPERATOR_EQUAL_TO:
                    case OPERATOR_EXPR_IF:
                    case OPERATOR_GREATER_THAN:
                    case OPERATOR_GREATER_THAN_OR_EQUAL_TO:
                    case OPERATOR_IS:
                    case OPERATOR_LESS_THAN:
                    case OPERATOR_LESS_THAN_OR_EQUAL_TO:
                    case OPERATOR_LSHIFT:
                    case OPERATOR_MINUS:
                    case OPERATOR_MODULO:
                    case OPERATOR_NOT_EQUAL_TO:
                    case OPERATOR_PLUS:
                    case OPERATOR_REL_AND:
                    case OPERATOR_REL_OR:
                    case OPERATOR_RSHIFT:
                    case OPERATOR_TIMES:
                    case RETURN:
                    case STRING:
                    case SWITCH:
                    case TRUE_LIT:
                    case VAR:
                    case WHILE:
                    case YIELD:
                    	{
                    		alt16=1;
                    	}
                        break;

                    }

                    switch (alt16)
                    {
                	case 1:
                	    // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:85:11: statement
                	    {
                	        FOLLOWPUSH(FOLLOW_statement_in_block358);
                	        statement(ctx);

                	        FOLLOWPOP();
                	        if  (HASEXCEPTION())
                	        {
                	            goto ruleblockEx;
                	        }


                	    }
                	    break;

                	default:
                	    goto loop16;	/* break out of the loop */
                	    break;
                    }
                }
                loop16: ; /* Jump out to here if this rule does not match */


                MATCHT(ANTLR3_TOKEN_UP, NULL);
                if  (HASEXCEPTION())
                {
                    goto ruleblockEx;
                }

            }


        }

    }

    // This is where rules clean up and exit
    //
    goto ruleblockEx; /* Prevent compiler warnings */
    ruleblockEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    pGeoGenScriptDecls_blockPop(ctx);

    return returnCodeBlock;
}
/* $ANTLR end block */

/**
 * $ANTLR start statement
 * D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:87:1: statement : ( BREAK | CONTINUE | variableDeclaration | expression | yieldStatement | returnStatement | whileStatement | forStatement | ifStatement | switchStatement | block );
 */
static void
statement(pGeoGenScriptDecls ctx)
{
    /* Initialize rule variables
     */

    {
        {
            //  D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:87:10: ( BREAK | CONTINUE | variableDeclaration | expression | yieldStatement | returnStatement | whileStatement | forStatement | ifStatement | switchStatement | block )

            ANTLR3_UINT32 alt17;

            alt17=11;

            switch ( LA(1) )
            {
            case BREAK:
            	{
            		alt17=1;
            	}
                break;
            case CONTINUE:
            	{
            		alt17=2;
            	}
                break;
            case VAR:
            	{
            		alt17=3;
            	}
                break;
            case COORDINATE:
            case FALSE_LIT:
            case IDENTIFIER:
            case LEFT_BRACKET:
            case LEFT_SQUARE_BRACKET:
            case NUMBER:
            case OPERATOR_ASSIGN:
            case OPERATOR_ASSIGN_AND:
            case OPERATOR_ASSIGN_DIVIDE:
            case OPERATOR_ASSIGN_LSHIFT:
            case OPERATOR_ASSIGN_MINUS:
            case OPERATOR_ASSIGN_MODULO:
            case OPERATOR_ASSIGN_OR:
            case OPERATOR_ASSIGN_PLUS:
            case OPERATOR_ASSIGN_RSHIFT:
            case OPERATOR_ASSIGN_TIMES:
            case OPERATOR_ASSIGN_XOR:
            case OPERATOR_BIT_AND:
            case OPERATOR_BIT_XOR:
            case OPERATOR_DIVIDE:
            case OPERATOR_DOT:
            case OPERATOR_EQUAL_TO:
            case OPERATOR_EXPR_IF:
            case OPERATOR_GREATER_THAN:
            case OPERATOR_GREATER_THAN_OR_EQUAL_TO:
            case OPERATOR_IS:
            case OPERATOR_LESS_THAN:
            case OPERATOR_LESS_THAN_OR_EQUAL_TO:
            case OPERATOR_LSHIFT:
            case OPERATOR_MINUS:
            case OPERATOR_MODULO:
            case OPERATOR_NOT_EQUAL_TO:
            case OPERATOR_PLUS:
            case OPERATOR_REL_AND:
            case OPERATOR_REL_OR:
            case OPERATOR_RSHIFT:
            case OPERATOR_TIMES:
            case STRING:
            case TRUE_LIT:
            	{
            		alt17=4;
            	}
                break;
            case YIELD:
            	{
            		alt17=5;
            	}
                break;
            case RETURN:
            	{
            		alt17=6;
            	}
                break;
            case WHILE:
            	{
            		alt17=7;
            	}
                break;
            case FOR:
            	{
            		alt17=8;
            	}
                break;
            case IF:
            	{
            		alt17=9;
            	}
                break;
            case SWITCH:
            	{
            		alt17=10;
            	}
                break;
            case BLOCK:
            	{
            		alt17=11;
            	}
                break;

            default:
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 17;
                EXCEPTION->state        = 0;


                goto rulestatementEx;

            }

            switch (alt17)
            {
        	case 1:
        	    // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:88:5: BREAK
        	    {
        	         MATCHT(BREAK, &FOLLOW_BREAK_in_statement376);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulestatementEx;
        	        }


        	    }
        	    break;
        	case 2:
        	    // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:89:7: CONTINUE
        	    {
        	         MATCHT(CONTINUE, &FOLLOW_CONTINUE_in_statement384);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulestatementEx;
        	        }


        	    }
        	    break;
        	case 3:
        	    // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:90:7: variableDeclaration
        	    {
        	        FOLLOWPUSH(FOLLOW_variableDeclaration_in_statement392);
        	        variableDeclaration(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulestatementEx;
        	        }


        	    }
        	    break;
        	case 4:
        	    // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:91:7: expression
        	    {
        	        FOLLOWPUSH(FOLLOW_expression_in_statement400);
        	        expression(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulestatementEx;
        	        }


        	    }
        	    break;
        	case 5:
        	    // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:92:7: yieldStatement
        	    {
        	        FOLLOWPUSH(FOLLOW_yieldStatement_in_statement408);
        	        yieldStatement(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulestatementEx;
        	        }


        	    }
        	    break;
        	case 6:
        	    // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:93:7: returnStatement
        	    {
        	        FOLLOWPUSH(FOLLOW_returnStatement_in_statement416);
        	        returnStatement(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulestatementEx;
        	        }


        	    }
        	    break;
        	case 7:
        	    // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:94:7: whileStatement
        	    {
        	        FOLLOWPUSH(FOLLOW_whileStatement_in_statement424);
        	        whileStatement(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulestatementEx;
        	        }


        	    }
        	    break;
        	case 8:
        	    // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:95:7: forStatement
        	    {
        	        FOLLOWPUSH(FOLLOW_forStatement_in_statement432);
        	        forStatement(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulestatementEx;
        	        }


        	    }
        	    break;
        	case 9:
        	    // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:96:7: ifStatement
        	    {
        	        FOLLOWPUSH(FOLLOW_ifStatement_in_statement440);
        	        ifStatement(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulestatementEx;
        	        }


        	    }
        	    break;
        	case 10:
        	    // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:97:7: switchStatement
        	    {
        	        FOLLOWPUSH(FOLLOW_switchStatement_in_statement448);
        	        switchStatement(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulestatementEx;
        	        }


        	    }
        	    break;
        	case 11:
        	    // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:98:7: block
        	    {
        	        FOLLOWPUSH(FOLLOW_block_in_statement456);
        	        block(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulestatementEx;
        	        }


        	    }
        	    break;

            }
        }
    }

    // This is where rules clean up and exit
    //
    goto rulestatementEx; /* Prevent compiler warnings */
    rulestatementEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end statement */

/**
 * $ANTLR start variableDeclaration
 * D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:100:1: variableDeclaration : ^( 'var' IDENTIFIER ( expression )? ) ;
 */
static void
variableDeclaration(pGeoGenScriptDecls ctx)
{
    /* Initialize rule variables
     */

    {
        // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:100:20: ( ^( 'var' IDENTIFIER ( expression )? ) )
        // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:100:22: ^( 'var' IDENTIFIER ( expression )? )
        {
             MATCHT(VAR, &FOLLOW_VAR_in_variableDeclaration468);
            if  (HASEXCEPTION())
            {
                goto rulevariableDeclarationEx;
            }


            MATCHT(ANTLR3_TOKEN_DOWN, NULL);
            if  (HASEXCEPTION())
            {
                goto rulevariableDeclarationEx;
            }

             MATCHT(IDENTIFIER, &FOLLOW_IDENTIFIER_in_variableDeclaration470);
            if  (HASEXCEPTION())
            {
                goto rulevariableDeclarationEx;
            }


            // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:100:41: ( expression )?
            {
                int alt18=2;
                switch ( LA(1) )
                {
                    case COORDINATE:
                    case FALSE_LIT:
                    case IDENTIFIER:
                    case LEFT_BRACKET:
                    case LEFT_SQUARE_BRACKET:
                    case NUMBER:
                    case OPERATOR_ASSIGN:
                    case OPERATOR_ASSIGN_AND:
                    case OPERATOR_ASSIGN_DIVIDE:
                    case OPERATOR_ASSIGN_LSHIFT:
                    case OPERATOR_ASSIGN_MINUS:
                    case OPERATOR_ASSIGN_MODULO:
                    case OPERATOR_ASSIGN_OR:
                    case OPERATOR_ASSIGN_PLUS:
                    case OPERATOR_ASSIGN_RSHIFT:
                    case OPERATOR_ASSIGN_TIMES:
                    case OPERATOR_ASSIGN_XOR:
                    case OPERATOR_BIT_AND:
                    case OPERATOR_BIT_XOR:
                    case OPERATOR_DIVIDE:
                    case OPERATOR_DOT:
                    case OPERATOR_EQUAL_TO:
                    case OPERATOR_EXPR_IF:
                    case OPERATOR_GREATER_THAN:
                    case OPERATOR_GREATER_THAN_OR_EQUAL_TO:
                    case OPERATOR_IS:
                    case OPERATOR_LESS_THAN:
                    case OPERATOR_LESS_THAN_OR_EQUAL_TO:
                    case OPERATOR_LSHIFT:
                    case OPERATOR_MINUS:
                    case OPERATOR_MODULO:
                    case OPERATOR_NOT_EQUAL_TO:
                    case OPERATOR_PLUS:
                    case OPERATOR_REL_AND:
                    case OPERATOR_REL_OR:
                    case OPERATOR_RSHIFT:
                    case OPERATOR_TIMES:
                    case STRING:
                    case TRUE_LIT:
                    	{
                    		alt18=1;
                    	}
                        break;
                }

                switch (alt18)
                {
            	case 1:
            	    // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:100:41: expression
            	    {
            	        FOLLOWPUSH(FOLLOW_expression_in_variableDeclaration472);
            	        expression(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulevariableDeclarationEx;
            	        }


            	    }
            	    break;

                }
            }

            MATCHT(ANTLR3_TOKEN_UP, NULL);
            if  (HASEXCEPTION())
            {
                goto rulevariableDeclarationEx;
            }



        }

    }

    // This is where rules clean up and exit
    //
    goto rulevariableDeclarationEx; /* Prevent compiler warnings */
    rulevariableDeclarationEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end variableDeclaration */

/**
 * $ANTLR start yieldStatement
 * D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:102:1: yieldStatement : ^( YIELD expression ( STRING )? ) ;
 */
static void
yieldStatement(pGeoGenScriptDecls ctx)
{
    /* Initialize rule variables
     */

    {
        // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:102:15: ( ^( YIELD expression ( STRING )? ) )
        // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:102:17: ^( YIELD expression ( STRING )? )
        {
             MATCHT(YIELD, &FOLLOW_YIELD_in_yieldStatement482);
            if  (HASEXCEPTION())
            {
                goto ruleyieldStatementEx;
            }


            MATCHT(ANTLR3_TOKEN_DOWN, NULL);
            if  (HASEXCEPTION())
            {
                goto ruleyieldStatementEx;
            }

            FOLLOWPUSH(FOLLOW_expression_in_yieldStatement484);
            expression(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleyieldStatementEx;
            }


            // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:102:36: ( STRING )?
            {
                int alt19=2;
                switch ( LA(1) )
                {
                    case STRING:
                    	{
                    		alt19=1;
                    	}
                        break;
                }

                switch (alt19)
                {
            	case 1:
            	    // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:102:36: STRING
            	    {
            	         MATCHT(STRING, &FOLLOW_STRING_in_yieldStatement486);
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleyieldStatementEx;
            	        }


            	    }
            	    break;

                }
            }

            MATCHT(ANTLR3_TOKEN_UP, NULL);
            if  (HASEXCEPTION())
            {
                goto ruleyieldStatementEx;
            }



        }

    }

    // This is where rules clean up and exit
    //
    goto ruleyieldStatementEx; /* Prevent compiler warnings */
    ruleyieldStatementEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end yieldStatement */

/**
 * $ANTLR start returnStatement
 * D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:105:1: returnStatement : ^( RETURN ( expression )? ) ;
 */
static void
returnStatement(pGeoGenScriptDecls ctx)
{
    /* Initialize rule variables
     */

    {
        // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:105:16: ( ^( RETURN ( expression )? ) )
        // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:105:18: ^( RETURN ( expression )? )
        {
             MATCHT(RETURN, &FOLLOW_RETURN_in_returnStatement497);
            if  (HASEXCEPTION())
            {
                goto rulereturnStatementEx;
            }


            if ( LA(1)==ANTLR3_TOKEN_DOWN ) {
                MATCHT(ANTLR3_TOKEN_DOWN, NULL);
                if  (HASEXCEPTION())
                {
                    goto rulereturnStatementEx;
                }

                // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:105:27: ( expression )?
                {
                    int alt20=2;
                    switch ( LA(1) )
                    {
                        case COORDINATE:
                        case FALSE_LIT:
                        case IDENTIFIER:
                        case LEFT_BRACKET:
                        case LEFT_SQUARE_BRACKET:
                        case NUMBER:
                        case OPERATOR_ASSIGN:
                        case OPERATOR_ASSIGN_AND:
                        case OPERATOR_ASSIGN_DIVIDE:
                        case OPERATOR_ASSIGN_LSHIFT:
                        case OPERATOR_ASSIGN_MINUS:
                        case OPERATOR_ASSIGN_MODULO:
                        case OPERATOR_ASSIGN_OR:
                        case OPERATOR_ASSIGN_PLUS:
                        case OPERATOR_ASSIGN_RSHIFT:
                        case OPERATOR_ASSIGN_TIMES:
                        case OPERATOR_ASSIGN_XOR:
                        case OPERATOR_BIT_AND:
                        case OPERATOR_BIT_XOR:
                        case OPERATOR_DIVIDE:
                        case OPERATOR_DOT:
                        case OPERATOR_EQUAL_TO:
                        case OPERATOR_EXPR_IF:
                        case OPERATOR_GREATER_THAN:
                        case OPERATOR_GREATER_THAN_OR_EQUAL_TO:
                        case OPERATOR_IS:
                        case OPERATOR_LESS_THAN:
                        case OPERATOR_LESS_THAN_OR_EQUAL_TO:
                        case OPERATOR_LSHIFT:
                        case OPERATOR_MINUS:
                        case OPERATOR_MODULO:
                        case OPERATOR_NOT_EQUAL_TO:
                        case OPERATOR_PLUS:
                        case OPERATOR_REL_AND:
                        case OPERATOR_REL_OR:
                        case OPERATOR_RSHIFT:
                        case OPERATOR_TIMES:
                        case STRING:
                        case TRUE_LIT:
                        	{
                        		alt20=1;
                        	}
                            break;
                    }

                    switch (alt20)
                    {
                	case 1:
                	    // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:105:27: expression
                	    {
                	        FOLLOWPUSH(FOLLOW_expression_in_returnStatement499);
                	        expression(ctx);

                	        FOLLOWPOP();
                	        if  (HASEXCEPTION())
                	        {
                	            goto rulereturnStatementEx;
                	        }


                	    }
                	    break;

                    }
                }

                MATCHT(ANTLR3_TOKEN_UP, NULL);
                if  (HASEXCEPTION())
                {
                    goto rulereturnStatementEx;
                }

            }


        }

    }

    // This is where rules clean up and exit
    //
    goto rulereturnStatementEx; /* Prevent compiler warnings */
    rulereturnStatementEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end returnStatement */

/**
 * $ANTLR start whileStatement
 * D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:107:1: whileStatement : ^( WHILE expression statement ) ;
 */
static void
whileStatement(pGeoGenScriptDecls ctx)
{
    /* Initialize rule variables
     */

    {
        // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:107:15: ( ^( WHILE expression statement ) )
        // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:107:17: ^( WHILE expression statement )
        {
             MATCHT(WHILE, &FOLLOW_WHILE_in_whileStatement509);
            if  (HASEXCEPTION())
            {
                goto rulewhileStatementEx;
            }


            MATCHT(ANTLR3_TOKEN_DOWN, NULL);
            if  (HASEXCEPTION())
            {
                goto rulewhileStatementEx;
            }

            FOLLOWPUSH(FOLLOW_expression_in_whileStatement511);
            expression(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulewhileStatementEx;
            }


            FOLLOWPUSH(FOLLOW_statement_in_whileStatement513);
            statement(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulewhileStatementEx;
            }


            MATCHT(ANTLR3_TOKEN_UP, NULL);
            if  (HASEXCEPTION())
            {
                goto rulewhileStatementEx;
            }



        }

    }

    // This is where rules clean up and exit
    //
    goto rulewhileStatementEx; /* Prevent compiler warnings */
    rulewhileStatementEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end whileStatement */

/**
 * $ANTLR start forStatement
 * D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:109:1: forStatement : ^( FOR ^( INITIALIZATION_EXPRESSION ( initExpression )? ) ^( CONDITION_EXPRESSION ( expression )? ) ^( INCREMENT_EXPRESSION ( expression )? ) statement ) ;
 */
static void
forStatement(pGeoGenScriptDecls ctx)
{
    /* Initialize rule variables
     */

    {
        // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:109:13: ( ^( FOR ^( INITIALIZATION_EXPRESSION ( initExpression )? ) ^( CONDITION_EXPRESSION ( expression )? ) ^( INCREMENT_EXPRESSION ( expression )? ) statement ) )
        // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:109:15: ^( FOR ^( INITIALIZATION_EXPRESSION ( initExpression )? ) ^( CONDITION_EXPRESSION ( expression )? ) ^( INCREMENT_EXPRESSION ( expression )? ) statement )
        {
             MATCHT(FOR, &FOLLOW_FOR_in_forStatement523);
            if  (HASEXCEPTION())
            {
                goto ruleforStatementEx;
            }


            MATCHT(ANTLR3_TOKEN_DOWN, NULL);
            if  (HASEXCEPTION())
            {
                goto ruleforStatementEx;
            }

             MATCHT(INITIALIZATION_EXPRESSION, &FOLLOW_INITIALIZATION_EXPRESSION_in_forStatement526);
            if  (HASEXCEPTION())
            {
                goto ruleforStatementEx;
            }


            if ( LA(1)==ANTLR3_TOKEN_DOWN ) {
                MATCHT(ANTLR3_TOKEN_DOWN, NULL);
                if  (HASEXCEPTION())
                {
                    goto ruleforStatementEx;
                }

                // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:109:49: ( initExpression )?
                {
                    int alt21=2;
                    switch ( LA(1) )
                    {
                        case COORDINATE:
                        case FALSE_LIT:
                        case IDENTIFIER:
                        case LEFT_BRACKET:
                        case LEFT_SQUARE_BRACKET:
                        case NUMBER:
                        case OPERATOR_ASSIGN:
                        case OPERATOR_ASSIGN_AND:
                        case OPERATOR_ASSIGN_DIVIDE:
                        case OPERATOR_ASSIGN_LSHIFT:
                        case OPERATOR_ASSIGN_MINUS:
                        case OPERATOR_ASSIGN_MODULO:
                        case OPERATOR_ASSIGN_OR:
                        case OPERATOR_ASSIGN_PLUS:
                        case OPERATOR_ASSIGN_RSHIFT:
                        case OPERATOR_ASSIGN_TIMES:
                        case OPERATOR_ASSIGN_XOR:
                        case OPERATOR_BIT_AND:
                        case OPERATOR_BIT_XOR:
                        case OPERATOR_DIVIDE:
                        case OPERATOR_DOT:
                        case OPERATOR_EQUAL_TO:
                        case OPERATOR_EXPR_IF:
                        case OPERATOR_GREATER_THAN:
                        case OPERATOR_GREATER_THAN_OR_EQUAL_TO:
                        case OPERATOR_IS:
                        case OPERATOR_LESS_THAN:
                        case OPERATOR_LESS_THAN_OR_EQUAL_TO:
                        case OPERATOR_LSHIFT:
                        case OPERATOR_MINUS:
                        case OPERATOR_MODULO:
                        case OPERATOR_NOT_EQUAL_TO:
                        case OPERATOR_PLUS:
                        case OPERATOR_REL_AND:
                        case OPERATOR_REL_OR:
                        case OPERATOR_RSHIFT:
                        case OPERATOR_TIMES:
                        case STRING:
                        case TRUE_LIT:
                        case VAR:
                        	{
                        		alt21=1;
                        	}
                            break;
                    }

                    switch (alt21)
                    {
                	case 1:
                	    // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:109:49: initExpression
                	    {
                	        FOLLOWPUSH(FOLLOW_initExpression_in_forStatement528);
                	        initExpression(ctx);

                	        FOLLOWPOP();
                	        if  (HASEXCEPTION())
                	        {
                	            goto ruleforStatementEx;
                	        }


                	    }
                	    break;

                    }
                }

                MATCHT(ANTLR3_TOKEN_UP, NULL);
                if  (HASEXCEPTION())
                {
                    goto ruleforStatementEx;
                }

            }


             MATCHT(CONDITION_EXPRESSION, &FOLLOW_CONDITION_EXPRESSION_in_forStatement533);
            if  (HASEXCEPTION())
            {
                goto ruleforStatementEx;
            }


            if ( LA(1)==ANTLR3_TOKEN_DOWN ) {
                MATCHT(ANTLR3_TOKEN_DOWN, NULL);
                if  (HASEXCEPTION())
                {
                    goto ruleforStatementEx;
                }

                // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:109:89: ( expression )?
                {
                    int alt22=2;
                    switch ( LA(1) )
                    {
                        case COORDINATE:
                        case FALSE_LIT:
                        case IDENTIFIER:
                        case LEFT_BRACKET:
                        case LEFT_SQUARE_BRACKET:
                        case NUMBER:
                        case OPERATOR_ASSIGN:
                        case OPERATOR_ASSIGN_AND:
                        case OPERATOR_ASSIGN_DIVIDE:
                        case OPERATOR_ASSIGN_LSHIFT:
                        case OPERATOR_ASSIGN_MINUS:
                        case OPERATOR_ASSIGN_MODULO:
                        case OPERATOR_ASSIGN_OR:
                        case OPERATOR_ASSIGN_PLUS:
                        case OPERATOR_ASSIGN_RSHIFT:
                        case OPERATOR_ASSIGN_TIMES:
                        case OPERATOR_ASSIGN_XOR:
                        case OPERATOR_BIT_AND:
                        case OPERATOR_BIT_XOR:
                        case OPERATOR_DIVIDE:
                        case OPERATOR_DOT:
                        case OPERATOR_EQUAL_TO:
                        case OPERATOR_EXPR_IF:
                        case OPERATOR_GREATER_THAN:
                        case OPERATOR_GREATER_THAN_OR_EQUAL_TO:
                        case OPERATOR_IS:
                        case OPERATOR_LESS_THAN:
                        case OPERATOR_LESS_THAN_OR_EQUAL_TO:
                        case OPERATOR_LSHIFT:
                        case OPERATOR_MINUS:
                        case OPERATOR_MODULO:
                        case OPERATOR_NOT_EQUAL_TO:
                        case OPERATOR_PLUS:
                        case OPERATOR_REL_AND:
                        case OPERATOR_REL_OR:
                        case OPERATOR_RSHIFT:
                        case OPERATOR_TIMES:
                        case STRING:
                        case TRUE_LIT:
                        	{
                        		alt22=1;
                        	}
                            break;
                    }

                    switch (alt22)
                    {
                	case 1:
                	    // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:109:89: expression
                	    {
                	        FOLLOWPUSH(FOLLOW_expression_in_forStatement535);
                	        expression(ctx);

                	        FOLLOWPOP();
                	        if  (HASEXCEPTION())
                	        {
                	            goto ruleforStatementEx;
                	        }


                	    }
                	    break;

                    }
                }

                MATCHT(ANTLR3_TOKEN_UP, NULL);
                if  (HASEXCEPTION())
                {
                    goto ruleforStatementEx;
                }

            }


             MATCHT(INCREMENT_EXPRESSION, &FOLLOW_INCREMENT_EXPRESSION_in_forStatement540);
            if  (HASEXCEPTION())
            {
                goto ruleforStatementEx;
            }


            if ( LA(1)==ANTLR3_TOKEN_DOWN ) {
                MATCHT(ANTLR3_TOKEN_DOWN, NULL);
                if  (HASEXCEPTION())
                {
                    goto ruleforStatementEx;
                }

                // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:109:125: ( expression )?
                {
                    int alt23=2;
                    switch ( LA(1) )
                    {
                        case COORDINATE:
                        case FALSE_LIT:
                        case IDENTIFIER:
                        case LEFT_BRACKET:
                        case LEFT_SQUARE_BRACKET:
                        case NUMBER:
                        case OPERATOR_ASSIGN:
                        case OPERATOR_ASSIGN_AND:
                        case OPERATOR_ASSIGN_DIVIDE:
                        case OPERATOR_ASSIGN_LSHIFT:
                        case OPERATOR_ASSIGN_MINUS:
                        case OPERATOR_ASSIGN_MODULO:
                        case OPERATOR_ASSIGN_OR:
                        case OPERATOR_ASSIGN_PLUS:
                        case OPERATOR_ASSIGN_RSHIFT:
                        case OPERATOR_ASSIGN_TIMES:
                        case OPERATOR_ASSIGN_XOR:
                        case OPERATOR_BIT_AND:
                        case OPERATOR_BIT_XOR:
                        case OPERATOR_DIVIDE:
                        case OPERATOR_DOT:
                        case OPERATOR_EQUAL_TO:
                        case OPERATOR_EXPR_IF:
                        case OPERATOR_GREATER_THAN:
                        case OPERATOR_GREATER_THAN_OR_EQUAL_TO:
                        case OPERATOR_IS:
                        case OPERATOR_LESS_THAN:
                        case OPERATOR_LESS_THAN_OR_EQUAL_TO:
                        case OPERATOR_LSHIFT:
                        case OPERATOR_MINUS:
                        case OPERATOR_MODULO:
                        case OPERATOR_NOT_EQUAL_TO:
                        case OPERATOR_PLUS:
                        case OPERATOR_REL_AND:
                        case OPERATOR_REL_OR:
                        case OPERATOR_RSHIFT:
                        case OPERATOR_TIMES:
                        case STRING:
                        case TRUE_LIT:
                        	{
                        		alt23=1;
                        	}
                            break;
                    }

                    switch (alt23)
                    {
                	case 1:
                	    // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:109:125: expression
                	    {
                	        FOLLOWPUSH(FOLLOW_expression_in_forStatement542);
                	        expression(ctx);

                	        FOLLOWPOP();
                	        if  (HASEXCEPTION())
                	        {
                	            goto ruleforStatementEx;
                	        }


                	    }
                	    break;

                    }
                }

                MATCHT(ANTLR3_TOKEN_UP, NULL);
                if  (HASEXCEPTION())
                {
                    goto ruleforStatementEx;
                }

            }


            FOLLOWPUSH(FOLLOW_statement_in_forStatement546);
            statement(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleforStatementEx;
            }


            MATCHT(ANTLR3_TOKEN_UP, NULL);
            if  (HASEXCEPTION())
            {
                goto ruleforStatementEx;
            }



        }

    }

    // This is where rules clean up and exit
    //
    goto ruleforStatementEx; /* Prevent compiler warnings */
    ruleforStatementEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end forStatement */

/**
 * $ANTLR start initExpression
 * D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:111:1: initExpression : ( ^( 'var' IDENTIFIER expression ) | expression );
 */
static void
initExpression(pGeoGenScriptDecls ctx)
{
    /* Initialize rule variables
     */

    {
        {
            //  D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:111:15: ( ^( 'var' IDENTIFIER expression ) | expression )

            ANTLR3_UINT32 alt24;

            alt24=2;

            switch ( LA(1) )
            {
            case VAR:
            	{
            		alt24=1;
            	}
                break;
            case COORDINATE:
            case FALSE_LIT:
            case IDENTIFIER:
            case LEFT_BRACKET:
            case LEFT_SQUARE_BRACKET:
            case NUMBER:
            case OPERATOR_ASSIGN:
            case OPERATOR_ASSIGN_AND:
            case OPERATOR_ASSIGN_DIVIDE:
            case OPERATOR_ASSIGN_LSHIFT:
            case OPERATOR_ASSIGN_MINUS:
            case OPERATOR_ASSIGN_MODULO:
            case OPERATOR_ASSIGN_OR:
            case OPERATOR_ASSIGN_PLUS:
            case OPERATOR_ASSIGN_RSHIFT:
            case OPERATOR_ASSIGN_TIMES:
            case OPERATOR_ASSIGN_XOR:
            case OPERATOR_BIT_AND:
            case OPERATOR_BIT_XOR:
            case OPERATOR_DIVIDE:
            case OPERATOR_DOT:
            case OPERATOR_EQUAL_TO:
            case OPERATOR_EXPR_IF:
            case OPERATOR_GREATER_THAN:
            case OPERATOR_GREATER_THAN_OR_EQUAL_TO:
            case OPERATOR_IS:
            case OPERATOR_LESS_THAN:
            case OPERATOR_LESS_THAN_OR_EQUAL_TO:
            case OPERATOR_LSHIFT:
            case OPERATOR_MINUS:
            case OPERATOR_MODULO:
            case OPERATOR_NOT_EQUAL_TO:
            case OPERATOR_PLUS:
            case OPERATOR_REL_AND:
            case OPERATOR_REL_OR:
            case OPERATOR_RSHIFT:
            case OPERATOR_TIMES:
            case STRING:
            case TRUE_LIT:
            	{
            		alt24=2;
            	}
                break;

            default:
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 24;
                EXCEPTION->state        = 0;


                goto ruleinitExpressionEx;

            }

            switch (alt24)
            {
        	case 1:
        	    // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:112:5: ^( 'var' IDENTIFIER expression )
        	    {
        	         MATCHT(VAR, &FOLLOW_VAR_in_initExpression560);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleinitExpressionEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_DOWN, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleinitExpressionEx;
        	        }

        	         MATCHT(IDENTIFIER, &FOLLOW_IDENTIFIER_in_initExpression562);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleinitExpressionEx;
        	        }


        	        FOLLOWPUSH(FOLLOW_expression_in_initExpression564);
        	        expression(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleinitExpressionEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_UP, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleinitExpressionEx;
        	        }



        	    }
        	    break;
        	case 2:
        	    // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:113:7: expression
        	    {
        	        FOLLOWPUSH(FOLLOW_expression_in_initExpression573);
        	        expression(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleinitExpressionEx;
        	        }


        	    }
        	    break;

            }
        }
    }

    // This is where rules clean up and exit
    //
    goto ruleinitExpressionEx; /* Prevent compiler warnings */
    ruleinitExpressionEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end initExpression */

/**
 * $ANTLR start ifStatement
 * D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:115:1: ifStatement : ^( IF expression statement ( statement )? ) ;
 */
static void
ifStatement(pGeoGenScriptDecls ctx)
{
    /* Initialize rule variables
     */

    {
        // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:115:12: ( ^( IF expression statement ( statement )? ) )
        // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:115:14: ^( IF expression statement ( statement )? )
        {
             MATCHT(IF, &FOLLOW_IF_in_ifStatement581);
            if  (HASEXCEPTION())
            {
                goto ruleifStatementEx;
            }


            MATCHT(ANTLR3_TOKEN_DOWN, NULL);
            if  (HASEXCEPTION())
            {
                goto ruleifStatementEx;
            }

            FOLLOWPUSH(FOLLOW_expression_in_ifStatement583);
            expression(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleifStatementEx;
            }


            FOLLOWPUSH(FOLLOW_statement_in_ifStatement585);
            statement(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleifStatementEx;
            }


            // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:115:40: ( statement )?
            {
                int alt25=2;
                switch ( LA(1) )
                {
                    case BLOCK:
                    case BREAK:
                    case CONTINUE:
                    case COORDINATE:
                    case FALSE_LIT:
                    case FOR:
                    case IDENTIFIER:
                    case IF:
                    case LEFT_BRACKET:
                    case LEFT_SQUARE_BRACKET:
                    case NUMBER:
                    case OPERATOR_ASSIGN:
                    case OPERATOR_ASSIGN_AND:
                    case OPERATOR_ASSIGN_DIVIDE:
                    case OPERATOR_ASSIGN_LSHIFT:
                    case OPERATOR_ASSIGN_MINUS:
                    case OPERATOR_ASSIGN_MODULO:
                    case OPERATOR_ASSIGN_OR:
                    case OPERATOR_ASSIGN_PLUS:
                    case OPERATOR_ASSIGN_RSHIFT:
                    case OPERATOR_ASSIGN_TIMES:
                    case OPERATOR_ASSIGN_XOR:
                    case OPERATOR_BIT_AND:
                    case OPERATOR_BIT_XOR:
                    case OPERATOR_DIVIDE:
                    case OPERATOR_DOT:
                    case OPERATOR_EQUAL_TO:
                    case OPERATOR_EXPR_IF:
                    case OPERATOR_GREATER_THAN:
                    case OPERATOR_GREATER_THAN_OR_EQUAL_TO:
                    case OPERATOR_IS:
                    case OPERATOR_LESS_THAN:
                    case OPERATOR_LESS_THAN_OR_EQUAL_TO:
                    case OPERATOR_LSHIFT:
                    case OPERATOR_MINUS:
                    case OPERATOR_MODULO:
                    case OPERATOR_NOT_EQUAL_TO:
                    case OPERATOR_PLUS:
                    case OPERATOR_REL_AND:
                    case OPERATOR_REL_OR:
                    case OPERATOR_RSHIFT:
                    case OPERATOR_TIMES:
                    case RETURN:
                    case STRING:
                    case SWITCH:
                    case TRUE_LIT:
                    case VAR:
                    case WHILE:
                    case YIELD:
                    	{
                    		alt25=1;
                    	}
                        break;
                }

                switch (alt25)
                {
            	case 1:
            	    // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:115:40: statement
            	    {
            	        FOLLOWPUSH(FOLLOW_statement_in_ifStatement587);
            	        statement(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleifStatementEx;
            	        }


            	    }
            	    break;

                }
            }

            MATCHT(ANTLR3_TOKEN_UP, NULL);
            if  (HASEXCEPTION())
            {
                goto ruleifStatementEx;
            }



        }

    }

    // This is where rules clean up and exit
    //
    goto ruleifStatementEx; /* Prevent compiler warnings */
    ruleifStatementEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end ifStatement */

/**
 * $ANTLR start switchStatement
 * D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:117:1: switchStatement : ^( SWITCH expression ( normalCase )* ( defaultCase )? ) ;
 */
static void
switchStatement(pGeoGenScriptDecls ctx)
{
    /* Initialize rule variables
     */

    {
        // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:117:16: ( ^( SWITCH expression ( normalCase )* ( defaultCase )? ) )
        // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:117:18: ^( SWITCH expression ( normalCase )* ( defaultCase )? )
        {
             MATCHT(SWITCH, &FOLLOW_SWITCH_in_switchStatement597);
            if  (HASEXCEPTION())
            {
                goto ruleswitchStatementEx;
            }


            MATCHT(ANTLR3_TOKEN_DOWN, NULL);
            if  (HASEXCEPTION())
            {
                goto ruleswitchStatementEx;
            }

            FOLLOWPUSH(FOLLOW_expression_in_switchStatement599);
            expression(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleswitchStatementEx;
            }


            // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:117:38: ( normalCase )*

            for (;;)
            {
                int alt26=2;
                switch ( LA(1) )
                {
                case CASE:
                	{
                		alt26=1;
                	}
                    break;

                }

                switch (alt26)
                {
            	case 1:
            	    // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:117:38: normalCase
            	    {
            	        FOLLOWPUSH(FOLLOW_normalCase_in_switchStatement601);
            	        normalCase(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleswitchStatementEx;
            	        }


            	    }
            	    break;

            	default:
            	    goto loop26;	/* break out of the loop */
            	    break;
                }
            }
            loop26: ; /* Jump out to here if this rule does not match */


            // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:117:50: ( defaultCase )?
            {
                int alt27=2;
                switch ( LA(1) )
                {
                    case DEFAULT:
                    	{
                    		alt27=1;
                    	}
                        break;
                }

                switch (alt27)
                {
            	case 1:
            	    // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:117:50: defaultCase
            	    {
            	        FOLLOWPUSH(FOLLOW_defaultCase_in_switchStatement604);
            	        defaultCase(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleswitchStatementEx;
            	        }


            	    }
            	    break;

                }
            }

            MATCHT(ANTLR3_TOKEN_UP, NULL);
            if  (HASEXCEPTION())
            {
                goto ruleswitchStatementEx;
            }



        }

    }

    // This is where rules clean up and exit
    //
    goto ruleswitchStatementEx; /* Prevent compiler warnings */
    ruleswitchStatementEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end switchStatement */

/**
 * $ANTLR start normalCase
 * D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:119:1: normalCase : ^( CASE label ^( BLOCK ( statement )* ) ) ;
 */
static void
normalCase(pGeoGenScriptDecls ctx)
{
    /* Initialize rule variables
     */

    {
        // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:119:11: ( ^( CASE label ^( BLOCK ( statement )* ) ) )
        // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:119:13: ^( CASE label ^( BLOCK ( statement )* ) )
        {
             MATCHT(CASE, &FOLLOW_CASE_in_normalCase614);
            if  (HASEXCEPTION())
            {
                goto rulenormalCaseEx;
            }


            MATCHT(ANTLR3_TOKEN_DOWN, NULL);
            if  (HASEXCEPTION())
            {
                goto rulenormalCaseEx;
            }

            FOLLOWPUSH(FOLLOW_label_in_normalCase616);
            label(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulenormalCaseEx;
            }


             MATCHT(BLOCK, &FOLLOW_BLOCK_in_normalCase619);
            if  (HASEXCEPTION())
            {
                goto rulenormalCaseEx;
            }


            if ( LA(1)==ANTLR3_TOKEN_DOWN ) {
                MATCHT(ANTLR3_TOKEN_DOWN, NULL);
                if  (HASEXCEPTION())
                {
                    goto rulenormalCaseEx;
                }

                // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:119:34: ( statement )*

                for (;;)
                {
                    int alt28=2;
                    switch ( LA(1) )
                    {
                    case BLOCK:
                    case BREAK:
                    case CONTINUE:
                    case COORDINATE:
                    case FALSE_LIT:
                    case FOR:
                    case IDENTIFIER:
                    case IF:
                    case LEFT_BRACKET:
                    case LEFT_SQUARE_BRACKET:
                    case NUMBER:
                    case OPERATOR_ASSIGN:
                    case OPERATOR_ASSIGN_AND:
                    case OPERATOR_ASSIGN_DIVIDE:
                    case OPERATOR_ASSIGN_LSHIFT:
                    case OPERATOR_ASSIGN_MINUS:
                    case OPERATOR_ASSIGN_MODULO:
                    case OPERATOR_ASSIGN_OR:
                    case OPERATOR_ASSIGN_PLUS:
                    case OPERATOR_ASSIGN_RSHIFT:
                    case OPERATOR_ASSIGN_TIMES:
                    case OPERATOR_ASSIGN_XOR:
                    case OPERATOR_BIT_AND:
                    case OPERATOR_BIT_XOR:
                    case OPERATOR_DIVIDE:
                    case OPERATOR_DOT:
                    case OPERATOR_EQUAL_TO:
                    case OPERATOR_EXPR_IF:
                    case OPERATOR_GREATER_THAN:
                    case OPERATOR_GREATER_THAN_OR_EQUAL_TO:
                    case OPERATOR_IS:
                    case OPERATOR_LESS_THAN:
                    case OPERATOR_LESS_THAN_OR_EQUAL_TO:
                    case OPERATOR_LSHIFT:
                    case OPERATOR_MINUS:
                    case OPERATOR_MODULO:
                    case OPERATOR_NOT_EQUAL_TO:
                    case OPERATOR_PLUS:
                    case OPERATOR_REL_AND:
                    case OPERATOR_REL_OR:
                    case OPERATOR_RSHIFT:
                    case OPERATOR_TIMES:
                    case RETURN:
                    case STRING:
                    case SWITCH:
                    case TRUE_LIT:
                    case VAR:
                    case WHILE:
                    case YIELD:
                    	{
                    		alt28=1;
                    	}
                        break;

                    }

                    switch (alt28)
                    {
                	case 1:
                	    // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:119:34: statement
                	    {
                	        FOLLOWPUSH(FOLLOW_statement_in_normalCase621);
                	        statement(ctx);

                	        FOLLOWPOP();
                	        if  (HASEXCEPTION())
                	        {
                	            goto rulenormalCaseEx;
                	        }


                	    }
                	    break;

                	default:
                	    goto loop28;	/* break out of the loop */
                	    break;
                    }
                }
                loop28: ; /* Jump out to here if this rule does not match */


                MATCHT(ANTLR3_TOKEN_UP, NULL);
                if  (HASEXCEPTION())
                {
                    goto rulenormalCaseEx;
                }

            }


            MATCHT(ANTLR3_TOKEN_UP, NULL);
            if  (HASEXCEPTION())
            {
                goto rulenormalCaseEx;
            }



        }

    }

    // This is where rules clean up and exit
    //
    goto rulenormalCaseEx; /* Prevent compiler warnings */
    rulenormalCaseEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end normalCase */

/**
 * $ANTLR start defaultCase
 * D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:120:1: defaultCase : ^( DEFAULT ^( BLOCK ( statement )* ) ) ;
 */
static void
defaultCase(pGeoGenScriptDecls ctx)
{
    /* Initialize rule variables
     */

    {
        // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:120:12: ( ^( DEFAULT ^( BLOCK ( statement )* ) ) )
        // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:120:14: ^( DEFAULT ^( BLOCK ( statement )* ) )
        {
             MATCHT(DEFAULT, &FOLLOW_DEFAULT_in_defaultCase631);
            if  (HASEXCEPTION())
            {
                goto ruledefaultCaseEx;
            }


            MATCHT(ANTLR3_TOKEN_DOWN, NULL);
            if  (HASEXCEPTION())
            {
                goto ruledefaultCaseEx;
            }

             MATCHT(BLOCK, &FOLLOW_BLOCK_in_defaultCase634);
            if  (HASEXCEPTION())
            {
                goto ruledefaultCaseEx;
            }


            if ( LA(1)==ANTLR3_TOKEN_DOWN ) {
                MATCHT(ANTLR3_TOKEN_DOWN, NULL);
                if  (HASEXCEPTION())
                {
                    goto ruledefaultCaseEx;
                }

                // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:120:32: ( statement )*

                for (;;)
                {
                    int alt29=2;
                    switch ( LA(1) )
                    {
                    case BLOCK:
                    case BREAK:
                    case CONTINUE:
                    case COORDINATE:
                    case FALSE_LIT:
                    case FOR:
                    case IDENTIFIER:
                    case IF:
                    case LEFT_BRACKET:
                    case LEFT_SQUARE_BRACKET:
                    case NUMBER:
                    case OPERATOR_ASSIGN:
                    case OPERATOR_ASSIGN_AND:
                    case OPERATOR_ASSIGN_DIVIDE:
                    case OPERATOR_ASSIGN_LSHIFT:
                    case OPERATOR_ASSIGN_MINUS:
                    case OPERATOR_ASSIGN_MODULO:
                    case OPERATOR_ASSIGN_OR:
                    case OPERATOR_ASSIGN_PLUS:
                    case OPERATOR_ASSIGN_RSHIFT:
                    case OPERATOR_ASSIGN_TIMES:
                    case OPERATOR_ASSIGN_XOR:
                    case OPERATOR_BIT_AND:
                    case OPERATOR_BIT_XOR:
                    case OPERATOR_DIVIDE:
                    case OPERATOR_DOT:
                    case OPERATOR_EQUAL_TO:
                    case OPERATOR_EXPR_IF:
                    case OPERATOR_GREATER_THAN:
                    case OPERATOR_GREATER_THAN_OR_EQUAL_TO:
                    case OPERATOR_IS:
                    case OPERATOR_LESS_THAN:
                    case OPERATOR_LESS_THAN_OR_EQUAL_TO:
                    case OPERATOR_LSHIFT:
                    case OPERATOR_MINUS:
                    case OPERATOR_MODULO:
                    case OPERATOR_NOT_EQUAL_TO:
                    case OPERATOR_PLUS:
                    case OPERATOR_REL_AND:
                    case OPERATOR_REL_OR:
                    case OPERATOR_RSHIFT:
                    case OPERATOR_TIMES:
                    case RETURN:
                    case STRING:
                    case SWITCH:
                    case TRUE_LIT:
                    case VAR:
                    case WHILE:
                    case YIELD:
                    	{
                    		alt29=1;
                    	}
                        break;

                    }

                    switch (alt29)
                    {
                	case 1:
                	    // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:120:32: statement
                	    {
                	        FOLLOWPUSH(FOLLOW_statement_in_defaultCase636);
                	        statement(ctx);

                	        FOLLOWPOP();
                	        if  (HASEXCEPTION())
                	        {
                	            goto ruledefaultCaseEx;
                	        }


                	    }
                	    break;

                	default:
                	    goto loop29;	/* break out of the loop */
                	    break;
                    }
                }
                loop29: ; /* Jump out to here if this rule does not match */


                MATCHT(ANTLR3_TOKEN_UP, NULL);
                if  (HASEXCEPTION())
                {
                    goto ruledefaultCaseEx;
                }

            }


            MATCHT(ANTLR3_TOKEN_UP, NULL);
            if  (HASEXCEPTION())
            {
                goto ruledefaultCaseEx;
            }



        }

    }

    // This is where rules clean up and exit
    //
    goto ruledefaultCaseEx; /* Prevent compiler warnings */
    ruledefaultCaseEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end defaultCase */

/**
 * $ANTLR start expression
 * D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:122:1: expression : ( ^( ( '=' | '+=' | '-=' | '*=' | '/=' | '%=' | '<<=' | '>>=' | '&=' | '|=' | '^=' | 'is' ) expression expression ) | ^( '?' expression expression expression ) | ^( '||' expression expression ) | ^( '&&' expression expression ) | ^( '^' expression expression ) | ^( '&' expression expression ) | ^( ( '==' | '!=' ) expression expression ) | ^( ( '<' | '<=' | '>' | '>=' ) expression expression ) | ^( ( '<<' | '>>' ) expression expression ) | ^( ( '+' | '-' ) expression expression ) | ^( ( '*' | '/' | '%' ) expression expression ) | ^( '.' expression expression ) | ^( '(' expression ( expression )* ) | ^( '[' expression ( expression )* ) | IDENTIFIER | coordinateLiteral | 'true' | 'false' | NUMBER | STRING );
 */
static void
expression(pGeoGenScriptDecls ctx)
{
    pANTLR3_BASE_TREE    NUMBER11;
    pANTLR3_BASE_TREE    STRING12;

    /* Initialize rule variables
     */

    NUMBER11       = NULL;
    STRING12       = NULL;

    {
        {
            //  D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:122:11: ( ^( ( '=' | '+=' | '-=' | '*=' | '/=' | '%=' | '<<=' | '>>=' | '&=' | '|=' | '^=' | 'is' ) expression expression ) | ^( '?' expression expression expression ) | ^( '||' expression expression ) | ^( '&&' expression expression ) | ^( '^' expression expression ) | ^( '&' expression expression ) | ^( ( '==' | '!=' ) expression expression ) | ^( ( '<' | '<=' | '>' | '>=' ) expression expression ) | ^( ( '<<' | '>>' ) expression expression ) | ^( ( '+' | '-' ) expression expression ) | ^( ( '*' | '/' | '%' ) expression expression ) | ^( '.' expression expression ) | ^( '(' expression ( expression )* ) | ^( '[' expression ( expression )* ) | IDENTIFIER | coordinateLiteral | 'true' | 'false' | NUMBER | STRING )

            ANTLR3_UINT32 alt32;

            alt32=20;

            switch ( LA(1) )
            {
            case OPERATOR_ASSIGN:
            case OPERATOR_ASSIGN_AND:
            case OPERATOR_ASSIGN_DIVIDE:
            case OPERATOR_ASSIGN_LSHIFT:
            case OPERATOR_ASSIGN_MINUS:
            case OPERATOR_ASSIGN_MODULO:
            case OPERATOR_ASSIGN_OR:
            case OPERATOR_ASSIGN_PLUS:
            case OPERATOR_ASSIGN_RSHIFT:
            case OPERATOR_ASSIGN_TIMES:
            case OPERATOR_ASSIGN_XOR:
            case OPERATOR_IS:
            	{
            		alt32=1;
            	}
                break;
            case OPERATOR_EXPR_IF:
            	{
            		alt32=2;
            	}
                break;
            case OPERATOR_REL_OR:
            	{
            		alt32=3;
            	}
                break;
            case OPERATOR_REL_AND:
            	{
            		alt32=4;
            	}
                break;
            case OPERATOR_BIT_XOR:
            	{
            		alt32=5;
            	}
                break;
            case OPERATOR_BIT_AND:
            	{
            		alt32=6;
            	}
                break;
            case OPERATOR_EQUAL_TO:
            case OPERATOR_NOT_EQUAL_TO:
            	{
            		alt32=7;
            	}
                break;
            case OPERATOR_GREATER_THAN:
            case OPERATOR_GREATER_THAN_OR_EQUAL_TO:
            case OPERATOR_LESS_THAN:
            case OPERATOR_LESS_THAN_OR_EQUAL_TO:
            	{
            		alt32=8;
            	}
                break;
            case OPERATOR_LSHIFT:
            case OPERATOR_RSHIFT:
            	{
            		alt32=9;
            	}
                break;
            case OPERATOR_MINUS:
            case OPERATOR_PLUS:
            	{
            		alt32=10;
            	}
                break;
            case OPERATOR_DIVIDE:
            case OPERATOR_MODULO:
            case OPERATOR_TIMES:
            	{
            		alt32=11;
            	}
                break;
            case OPERATOR_DOT:
            	{
            		alt32=12;
            	}
                break;
            case LEFT_BRACKET:
            	{
            		alt32=13;
            	}
                break;
            case LEFT_SQUARE_BRACKET:
            	{
            		alt32=14;
            	}
                break;
            case IDENTIFIER:
            	{
            		alt32=15;
            	}
                break;
            case COORDINATE:
            	{
            		alt32=16;
            	}
                break;
            case TRUE_LIT:
            	{
            		alt32=17;
            	}
                break;
            case FALSE_LIT:
            	{
            		alt32=18;
            	}
                break;
            case NUMBER:
            	{
            		alt32=19;
            	}
                break;
            case STRING:
            	{
            		alt32=20;
            	}
                break;

            default:
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 32;
                EXCEPTION->state        = 0;


                goto ruleexpressionEx;

            }

            switch (alt32)
            {
        	case 1:
        	    // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:123:2: ^( ( '=' | '+=' | '-=' | '*=' | '/=' | '%=' | '<<=' | '>>=' | '&=' | '|=' | '^=' | 'is' ) expression expression )
        	    {
        	        if ( ((LA(1) >= OPERATOR_ASSIGN) && (LA(1) <= OPERATOR_ASSIGN_XOR)) || LA(1) == OPERATOR_IS )
        	        {
        	            CONSUME();
        	            PERRORRECOVERY=ANTLR3_FALSE;
        	        }
        	        else
        	        {
        	            CONSTRUCTEX();
        	            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
        	            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

        	            RECOVERFROMMISMATCHEDSET(&FOLLOW_set_in_expression648);
        	            goto ruleexpressionEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_DOWN, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }

        	        FOLLOWPUSH(FOLLOW_expression_in_expression696);
        	        expression(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }


        	        FOLLOWPUSH(FOLLOW_expression_in_expression698);
        	        expression(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_UP, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }



        	    }
        	    break;
        	case 2:
        	    // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:124:4: ^( '?' expression expression expression )
        	    {
        	         MATCHT(OPERATOR_EXPR_IF, &FOLLOW_OPERATOR_EXPR_IF_in_expression705);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_DOWN, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }

        	        FOLLOWPUSH(FOLLOW_expression_in_expression707);
        	        expression(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }


        	        FOLLOWPUSH(FOLLOW_expression_in_expression710);
        	        expression(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }


        	        FOLLOWPUSH(FOLLOW_expression_in_expression712);
        	        expression(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_UP, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }



        	    }
        	    break;
        	case 3:
        	    // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:125:4: ^( '||' expression expression )
        	    {
        	         MATCHT(OPERATOR_REL_OR, &FOLLOW_OPERATOR_REL_OR_in_expression719);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_DOWN, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }

        	        FOLLOWPUSH(FOLLOW_expression_in_expression721);
        	        expression(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }


        	        FOLLOWPUSH(FOLLOW_expression_in_expression723);
        	        expression(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_UP, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }



        	    }
        	    break;
        	case 4:
        	    // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:126:4: ^( '&&' expression expression )
        	    {
        	         MATCHT(OPERATOR_REL_AND, &FOLLOW_OPERATOR_REL_AND_in_expression730);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_DOWN, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }

        	        FOLLOWPUSH(FOLLOW_expression_in_expression732);
        	        expression(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }


        	        FOLLOWPUSH(FOLLOW_expression_in_expression734);
        	        expression(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_UP, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }



        	    }
        	    break;
        	case 5:
        	    // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:127:4: ^( '^' expression expression )
        	    {
        	         MATCHT(OPERATOR_BIT_XOR, &FOLLOW_OPERATOR_BIT_XOR_in_expression741);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_DOWN, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }

        	        FOLLOWPUSH(FOLLOW_expression_in_expression743);
        	        expression(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }


        	        FOLLOWPUSH(FOLLOW_expression_in_expression745);
        	        expression(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_UP, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }



        	    }
        	    break;
        	case 6:
        	    // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:128:4: ^( '&' expression expression )
        	    {
        	         MATCHT(OPERATOR_BIT_AND, &FOLLOW_OPERATOR_BIT_AND_in_expression752);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_DOWN, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }

        	        FOLLOWPUSH(FOLLOW_expression_in_expression754);
        	        expression(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }


        	        FOLLOWPUSH(FOLLOW_expression_in_expression756);
        	        expression(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_UP, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }



        	    }
        	    break;
        	case 7:
        	    // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:129:4: ^( ( '==' | '!=' ) expression expression )
        	    {
        	        if ( LA(1) == OPERATOR_EQUAL_TO || LA(1) == OPERATOR_NOT_EQUAL_TO )
        	        {
        	            CONSUME();
        	            PERRORRECOVERY=ANTLR3_FALSE;
        	        }
        	        else
        	        {
        	            CONSTRUCTEX();
        	            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
        	            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

        	            RECOVERFROMMISMATCHEDSET(&FOLLOW_set_in_expression763);
        	            goto ruleexpressionEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_DOWN, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }

        	        FOLLOWPUSH(FOLLOW_expression_in_expression771);
        	        expression(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }


        	        FOLLOWPUSH(FOLLOW_expression_in_expression773);
        	        expression(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_UP, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }



        	    }
        	    break;
        	case 8:
        	    // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:130:4: ^( ( '<' | '<=' | '>' | '>=' ) expression expression )
        	    {
        	        if ( ((LA(1) >= OPERATOR_GREATER_THAN) && (LA(1) <= OPERATOR_GREATER_THAN_OR_EQUAL_TO)) || ((LA(1) >= OPERATOR_LESS_THAN) && (LA(1) <= OPERATOR_LESS_THAN_OR_EQUAL_TO)) )
        	        {
        	            CONSUME();
        	            PERRORRECOVERY=ANTLR3_FALSE;
        	        }
        	        else
        	        {
        	            CONSTRUCTEX();
        	            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
        	            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

        	            RECOVERFROMMISMATCHEDSET(&FOLLOW_set_in_expression780);
        	            goto ruleexpressionEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_DOWN, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }

        	        FOLLOWPUSH(FOLLOW_expression_in_expression796);
        	        expression(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }


        	        FOLLOWPUSH(FOLLOW_expression_in_expression798);
        	        expression(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_UP, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }



        	    }
        	    break;
        	case 9:
        	    // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:131:4: ^( ( '<<' | '>>' ) expression expression )
        	    {
        	        if ( LA(1) == OPERATOR_LSHIFT || LA(1) == OPERATOR_RSHIFT )
        	        {
        	            CONSUME();
        	            PERRORRECOVERY=ANTLR3_FALSE;
        	        }
        	        else
        	        {
        	            CONSTRUCTEX();
        	            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
        	            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

        	            RECOVERFROMMISMATCHEDSET(&FOLLOW_set_in_expression805);
        	            goto ruleexpressionEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_DOWN, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }

        	        FOLLOWPUSH(FOLLOW_expression_in_expression813);
        	        expression(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }


        	        FOLLOWPUSH(FOLLOW_expression_in_expression815);
        	        expression(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_UP, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }



        	    }
        	    break;
        	case 10:
        	    // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:132:4: ^( ( '+' | '-' ) expression expression )
        	    {
        	        if ( LA(1) == OPERATOR_MINUS || LA(1) == OPERATOR_PLUS )
        	        {
        	            CONSUME();
        	            PERRORRECOVERY=ANTLR3_FALSE;
        	        }
        	        else
        	        {
        	            CONSTRUCTEX();
        	            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
        	            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

        	            RECOVERFROMMISMATCHEDSET(&FOLLOW_set_in_expression822);
        	            goto ruleexpressionEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_DOWN, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }

        	        FOLLOWPUSH(FOLLOW_expression_in_expression830);
        	        expression(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }


        	        FOLLOWPUSH(FOLLOW_expression_in_expression832);
        	        expression(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_UP, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }



        	    }
        	    break;
        	case 11:
        	    // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:133:4: ^( ( '*' | '/' | '%' ) expression expression )
        	    {
        	        if ( LA(1) == OPERATOR_DIVIDE || LA(1) == OPERATOR_MODULO || LA(1) == OPERATOR_TIMES )
        	        {
        	            CONSUME();
        	            PERRORRECOVERY=ANTLR3_FALSE;
        	        }
        	        else
        	        {
        	            CONSTRUCTEX();
        	            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
        	            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;

        	            RECOVERFROMMISMATCHEDSET(&FOLLOW_set_in_expression839);
        	            goto ruleexpressionEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_DOWN, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }

        	        FOLLOWPUSH(FOLLOW_expression_in_expression851);
        	        expression(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }


        	        FOLLOWPUSH(FOLLOW_expression_in_expression853);
        	        expression(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_UP, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }



        	    }
        	    break;
        	case 12:
        	    // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:134:4: ^( '.' expression expression )
        	    {
        	         MATCHT(OPERATOR_DOT, &FOLLOW_OPERATOR_DOT_in_expression861);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_DOWN, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }

        	        FOLLOWPUSH(FOLLOW_expression_in_expression863);
        	        expression(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }


        	        FOLLOWPUSH(FOLLOW_expression_in_expression865);
        	        expression(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_UP, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }



        	    }
        	    break;
        	case 13:
        	    // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:135:4: ^( '(' expression ( expression )* )
        	    {
        	         MATCHT(LEFT_BRACKET, &FOLLOW_LEFT_BRACKET_in_expression872);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_DOWN, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }

        	        FOLLOWPUSH(FOLLOW_expression_in_expression874);
        	        expression(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }


        	        // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:135:21: ( expression )*

        	        for (;;)
        	        {
        	            int alt30=2;
        	            switch ( LA(1) )
        	            {
        	            case COORDINATE:
        	            case FALSE_LIT:
        	            case IDENTIFIER:
        	            case LEFT_BRACKET:
        	            case LEFT_SQUARE_BRACKET:
        	            case NUMBER:
        	            case OPERATOR_ASSIGN:
        	            case OPERATOR_ASSIGN_AND:
        	            case OPERATOR_ASSIGN_DIVIDE:
        	            case OPERATOR_ASSIGN_LSHIFT:
        	            case OPERATOR_ASSIGN_MINUS:
        	            case OPERATOR_ASSIGN_MODULO:
        	            case OPERATOR_ASSIGN_OR:
        	            case OPERATOR_ASSIGN_PLUS:
        	            case OPERATOR_ASSIGN_RSHIFT:
        	            case OPERATOR_ASSIGN_TIMES:
        	            case OPERATOR_ASSIGN_XOR:
        	            case OPERATOR_BIT_AND:
        	            case OPERATOR_BIT_XOR:
        	            case OPERATOR_DIVIDE:
        	            case OPERATOR_DOT:
        	            case OPERATOR_EQUAL_TO:
        	            case OPERATOR_EXPR_IF:
        	            case OPERATOR_GREATER_THAN:
        	            case OPERATOR_GREATER_THAN_OR_EQUAL_TO:
        	            case OPERATOR_IS:
        	            case OPERATOR_LESS_THAN:
        	            case OPERATOR_LESS_THAN_OR_EQUAL_TO:
        	            case OPERATOR_LSHIFT:
        	            case OPERATOR_MINUS:
        	            case OPERATOR_MODULO:
        	            case OPERATOR_NOT_EQUAL_TO:
        	            case OPERATOR_PLUS:
        	            case OPERATOR_REL_AND:
        	            case OPERATOR_REL_OR:
        	            case OPERATOR_RSHIFT:
        	            case OPERATOR_TIMES:
        	            case STRING:
        	            case TRUE_LIT:
        	            	{
        	            		alt30=1;
        	            	}
        	                break;

        	            }

        	            switch (alt30)
        	            {
        	        	case 1:
        	        	    // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:135:21: expression
        	        	    {
        	        	        FOLLOWPUSH(FOLLOW_expression_in_expression876);
        	        	        expression(ctx);

        	        	        FOLLOWPOP();
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto ruleexpressionEx;
        	        	        }


        	        	    }
        	        	    break;

        	        	default:
        	        	    goto loop30;	/* break out of the loop */
        	        	    break;
        	            }
        	        }
        	        loop30: ; /* Jump out to here if this rule does not match */


        	        MATCHT(ANTLR3_TOKEN_UP, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }



        	    }
        	    break;
        	case 14:
        	    // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:136:4: ^( '[' expression ( expression )* )
        	    {
        	         MATCHT(LEFT_SQUARE_BRACKET, &FOLLOW_LEFT_SQUARE_BRACKET_in_expression884);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_DOWN, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }

        	        FOLLOWPUSH(FOLLOW_expression_in_expression886);
        	        expression(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }


        	        // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:136:21: ( expression )*

        	        for (;;)
        	        {
        	            int alt31=2;
        	            switch ( LA(1) )
        	            {
        	            case COORDINATE:
        	            case FALSE_LIT:
        	            case IDENTIFIER:
        	            case LEFT_BRACKET:
        	            case LEFT_SQUARE_BRACKET:
        	            case NUMBER:
        	            case OPERATOR_ASSIGN:
        	            case OPERATOR_ASSIGN_AND:
        	            case OPERATOR_ASSIGN_DIVIDE:
        	            case OPERATOR_ASSIGN_LSHIFT:
        	            case OPERATOR_ASSIGN_MINUS:
        	            case OPERATOR_ASSIGN_MODULO:
        	            case OPERATOR_ASSIGN_OR:
        	            case OPERATOR_ASSIGN_PLUS:
        	            case OPERATOR_ASSIGN_RSHIFT:
        	            case OPERATOR_ASSIGN_TIMES:
        	            case OPERATOR_ASSIGN_XOR:
        	            case OPERATOR_BIT_AND:
        	            case OPERATOR_BIT_XOR:
        	            case OPERATOR_DIVIDE:
        	            case OPERATOR_DOT:
        	            case OPERATOR_EQUAL_TO:
        	            case OPERATOR_EXPR_IF:
        	            case OPERATOR_GREATER_THAN:
        	            case OPERATOR_GREATER_THAN_OR_EQUAL_TO:
        	            case OPERATOR_IS:
        	            case OPERATOR_LESS_THAN:
        	            case OPERATOR_LESS_THAN_OR_EQUAL_TO:
        	            case OPERATOR_LSHIFT:
        	            case OPERATOR_MINUS:
        	            case OPERATOR_MODULO:
        	            case OPERATOR_NOT_EQUAL_TO:
        	            case OPERATOR_PLUS:
        	            case OPERATOR_REL_AND:
        	            case OPERATOR_REL_OR:
        	            case OPERATOR_RSHIFT:
        	            case OPERATOR_TIMES:
        	            case STRING:
        	            case TRUE_LIT:
        	            	{
        	            		alt31=1;
        	            	}
        	                break;

        	            }

        	            switch (alt31)
        	            {
        	        	case 1:
        	        	    // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:136:21: expression
        	        	    {
        	        	        FOLLOWPUSH(FOLLOW_expression_in_expression888);
        	        	        expression(ctx);

        	        	        FOLLOWPOP();
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto ruleexpressionEx;
        	        	        }


        	        	    }
        	        	    break;

        	        	default:
        	        	    goto loop31;	/* break out of the loop */
        	        	    break;
        	            }
        	        }
        	        loop31: ; /* Jump out to here if this rule does not match */


        	        MATCHT(ANTLR3_TOKEN_UP, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }



        	    }
        	    break;
        	case 15:
        	    // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:137:4: IDENTIFIER
        	    {
        	         MATCHT(IDENTIFIER, &FOLLOW_IDENTIFIER_in_expression895);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }


        	    }
        	    break;
        	case 16:
        	    // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:139:4: coordinateLiteral
        	    {
        	        FOLLOWPUSH(FOLLOW_coordinateLiteral_in_expression902);
        	        coordinateLiteral(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }


        	    }
        	    break;
        	case 17:
        	    // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:140:4: 'true'
        	    {
        	         MATCHT(TRUE_LIT, &FOLLOW_TRUE_LIT_in_expression907);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }


        	        {
        	             (SCOPE_TOP(block))->codeBlock->AddInstruction(new instructions::LoadConstBooleanInstruction(true));
        	        }


        	    }
        	    break;
        	case 18:
        	    // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:141:4: 'false'
        	    {
        	         MATCHT(FALSE_LIT, &FOLLOW_FALSE_LIT_in_expression914);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }


        	        {
        	             (SCOPE_TOP(block))->codeBlock->AddInstruction(new instructions::LoadConstBooleanInstruction(false));
        	        }


        	    }
        	    break;
        	case 19:
        	    // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:142:4: NUMBER
        	    {
        	        NUMBER11 = (pANTLR3_BASE_TREE) MATCHT(NUMBER, &FOLLOW_NUMBER_in_expression921);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }


        	        {
        	             (SCOPE_TOP(block))->codeBlock->AddInstruction(new instructions::LoadConstNumberInstruction(StringToNumber((char*)(NUMBER11->getText(NUMBER11))->chars)));
        	        }


        	    }
        	    break;
        	case 20:
        	    // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:143:4: STRING
        	    {
        	        STRING12 = (pANTLR3_BASE_TREE) MATCHT(STRING, &FOLLOW_STRING_in_expression928);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleexpressionEx;
        	        }


        	        {
        	             (SCOPE_TOP(block))->codeBlock->AddInstruction(new instructions::LoadConstStringInstruction((char*)(STRING12->getText(STRING12))->chars));
        	        }


        	    }
        	    break;

            }
        }
    }

    // This is where rules clean up and exit
    //
    goto ruleexpressionEx; /* Prevent compiler warnings */
    ruleexpressionEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end expression */

/**
 * $ANTLR start unkeyedCollectionLiteral
 * D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:214:1: unkeyedCollectionLiteral : '{' ( expression ( ',' expression )* ) '}' ;
 */
static void
unkeyedCollectionLiteral(pGeoGenScriptDecls ctx)
{
    /* Initialize rule variables
     */

    {
        // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:214:25: ( '{' ( expression ( ',' expression )* ) '}' )
        // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:215:5: '{' ( expression ( ',' expression )* ) '}'
        {
             MATCHT(LEFT_CURLY_BRACKET, &FOLLOW_LEFT_CURLY_BRACKET_in_unkeyedCollectionLiteral982);
            if  (HASEXCEPTION())
            {
                goto ruleunkeyedCollectionLiteralEx;
            }


            // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:215:9: ( expression ( ',' expression )* )
            // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:215:10: expression ( ',' expression )*
            {
                FOLLOWPUSH(FOLLOW_expression_in_unkeyedCollectionLiteral985);
                expression(ctx);

                FOLLOWPOP();
                if  (HASEXCEPTION())
                {
                    goto ruleunkeyedCollectionLiteralEx;
                }


                // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:215:21: ( ',' expression )*

                for (;;)
                {
                    int alt33=2;
                    switch ( LA(1) )
                    {
                    case COMMA:
                    	{
                    		alt33=1;
                    	}
                        break;

                    }

                    switch (alt33)
                    {
                	case 1:
                	    // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:215:22: ',' expression
                	    {
                	         MATCHT(COMMA, &FOLLOW_COMMA_in_unkeyedCollectionLiteral988);
                	        if  (HASEXCEPTION())
                	        {
                	            goto ruleunkeyedCollectionLiteralEx;
                	        }


                	        FOLLOWPUSH(FOLLOW_expression_in_unkeyedCollectionLiteral990);
                	        expression(ctx);

                	        FOLLOWPOP();
                	        if  (HASEXCEPTION())
                	        {
                	            goto ruleunkeyedCollectionLiteralEx;
                	        }


                	    }
                	    break;

                	default:
                	    goto loop33;	/* break out of the loop */
                	    break;
                    }
                }
                loop33: ; /* Jump out to here if this rule does not match */


            }


             MATCHT(RIGTH_CURLY_BRACKET, &FOLLOW_RIGTH_CURLY_BRACKET_in_unkeyedCollectionLiteral995);
            if  (HASEXCEPTION())
            {
                goto ruleunkeyedCollectionLiteralEx;
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto ruleunkeyedCollectionLiteralEx; /* Prevent compiler warnings */
    ruleunkeyedCollectionLiteralEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end unkeyedCollectionLiteral */

/**
 * $ANTLR start coordinateLiteral
 * D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:217:1: coordinateLiteral : ^( COORDINATE ( expression )+ ) ;
 */
static void
coordinateLiteral(pGeoGenScriptDecls ctx)
{
    /* Initialize rule variables
     */

    {
        // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:217:18: ( ^( COORDINATE ( expression )+ ) )
        // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:217:20: ^( COORDINATE ( expression )+ )
        {
             MATCHT(COORDINATE, &FOLLOW_COORDINATE_in_coordinateLiteral1003);
            if  (HASEXCEPTION())
            {
                goto rulecoordinateLiteralEx;
            }


            MATCHT(ANTLR3_TOKEN_DOWN, NULL);
            if  (HASEXCEPTION())
            {
                goto rulecoordinateLiteralEx;
            }

            // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:217:33: ( expression )+
            {
                int cnt34=0;

                for (;;)
                {
                    int alt34=2;
            	switch ( LA(1) )
            	{
            	case COORDINATE:
            	case FALSE_LIT:
            	case IDENTIFIER:
            	case LEFT_BRACKET:
            	case LEFT_SQUARE_BRACKET:
            	case NUMBER:
            	case OPERATOR_ASSIGN:
            	case OPERATOR_ASSIGN_AND:
            	case OPERATOR_ASSIGN_DIVIDE:
            	case OPERATOR_ASSIGN_LSHIFT:
            	case OPERATOR_ASSIGN_MINUS:
            	case OPERATOR_ASSIGN_MODULO:
            	case OPERATOR_ASSIGN_OR:
            	case OPERATOR_ASSIGN_PLUS:
            	case OPERATOR_ASSIGN_RSHIFT:
            	case OPERATOR_ASSIGN_TIMES:
            	case OPERATOR_ASSIGN_XOR:
            	case OPERATOR_BIT_AND:
            	case OPERATOR_BIT_XOR:
            	case OPERATOR_DIVIDE:
            	case OPERATOR_DOT:
            	case OPERATOR_EQUAL_TO:
            	case OPERATOR_EXPR_IF:
            	case OPERATOR_GREATER_THAN:
            	case OPERATOR_GREATER_THAN_OR_EQUAL_TO:
            	case OPERATOR_IS:
            	case OPERATOR_LESS_THAN:
            	case OPERATOR_LESS_THAN_OR_EQUAL_TO:
            	case OPERATOR_LSHIFT:
            	case OPERATOR_MINUS:
            	case OPERATOR_MODULO:
            	case OPERATOR_NOT_EQUAL_TO:
            	case OPERATOR_PLUS:
            	case OPERATOR_REL_AND:
            	case OPERATOR_REL_OR:
            	case OPERATOR_RSHIFT:
            	case OPERATOR_TIMES:
            	case STRING:
            	case TRUE_LIT:
            		{
            			alt34=1;
            		}
            	    break;

            	}

            	switch (alt34)
            	{
            	    case 1:
            	        // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:217:33: expression
            	        {
            	            FOLLOWPUSH(FOLLOW_expression_in_coordinateLiteral1005);
            	            expression(ctx);

            	            FOLLOWPOP();
            	            if  (HASEXCEPTION())
            	            {
            	                goto rulecoordinateLiteralEx;
            	            }


            	        }
            	        break;

            	    default:

            		if ( cnt34 >= 1 )
            		{
            		    goto loop34;
            		}
            		/* mismatchedSetEx()
            		 */
            		CONSTRUCTEX();
            		EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;
            		EXCEPTION->name = (void *)ANTLR3_EARLY_EXIT_NAME;


            		goto rulecoordinateLiteralEx;
            	}
            	cnt34++;
                }
                loop34: ;	/* Jump to here if this rule does not match */
            }

            MATCHT(ANTLR3_TOKEN_UP, NULL);
            if  (HASEXCEPTION())
            {
                goto rulecoordinateLiteralEx;
            }



        }

    }

    // This is where rules clean up and exit
    //
    goto rulecoordinateLiteralEx; /* Prevent compiler warnings */
    rulecoordinateLiteralEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end coordinateLiteral */

/**
 * $ANTLR start label
 * D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:219:1: label : ( ^( IDENTCHAIN ( IDENTIFIER )+ ) | 'true' | 'false' | NUMBER | STRING );
 */
static void
label(pGeoGenScriptDecls ctx)
{
    /* Initialize rule variables
     */

    {
        {
            //  D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:219:6: ( ^( IDENTCHAIN ( IDENTIFIER )+ ) | 'true' | 'false' | NUMBER | STRING )

            ANTLR3_UINT32 alt36;

            alt36=5;

            switch ( LA(1) )
            {
            case IDENTCHAIN:
            	{
            		alt36=1;
            	}
                break;
            case TRUE_LIT:
            	{
            		alt36=2;
            	}
                break;
            case FALSE_LIT:
            	{
            		alt36=3;
            	}
                break;
            case NUMBER:
            	{
            		alt36=4;
            	}
                break;
            case STRING:
            	{
            		alt36=5;
            	}
                break;

            default:
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 36;
                EXCEPTION->state        = 0;


                goto rulelabelEx;

            }

            switch (alt36)
            {
        	case 1:
        	    // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:220:2: ^( IDENTCHAIN ( IDENTIFIER )+ )
        	    {
        	         MATCHT(IDENTCHAIN, &FOLLOW_IDENTCHAIN_in_label1024);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulelabelEx;
        	        }


        	        MATCHT(ANTLR3_TOKEN_DOWN, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulelabelEx;
        	        }

        	        // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:220:15: ( IDENTIFIER )+
        	        {
        	            int cnt35=0;

        	            for (;;)
        	            {
        	                int alt35=2;
        	        	switch ( LA(1) )
        	        	{
        	        	case IDENTIFIER:
        	        		{
        	        			alt35=1;
        	        		}
        	        	    break;

        	        	}

        	        	switch (alt35)
        	        	{
        	        	    case 1:
        	        	        // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:220:15: IDENTIFIER
        	        	        {
        	        	             MATCHT(IDENTIFIER, &FOLLOW_IDENTIFIER_in_label1026);
        	        	            if  (HASEXCEPTION())
        	        	            {
        	        	                goto rulelabelEx;
        	        	            }


        	        	        }
        	        	        break;

        	        	    default:

        	        		if ( cnt35 >= 1 )
        	        		{
        	        		    goto loop35;
        	        		}
        	        		/* mismatchedSetEx()
        	        		 */
        	        		CONSTRUCTEX();
        	        		EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;
        	        		EXCEPTION->name = (void *)ANTLR3_EARLY_EXIT_NAME;


        	        		goto rulelabelEx;
        	        	}
        	        	cnt35++;
        	            }
        	            loop35: ;	/* Jump to here if this rule does not match */
        	        }

        	        MATCHT(ANTLR3_TOKEN_UP, NULL);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulelabelEx;
        	        }



        	    }
        	    break;
        	case 2:
        	    // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:221:4: 'true'
        	    {
        	         MATCHT(TRUE_LIT, &FOLLOW_TRUE_LIT_in_label1033);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulelabelEx;
        	        }


        	    }
        	    break;
        	case 3:
        	    // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:222:11: 'false'
        	    {
        	         MATCHT(FALSE_LIT, &FOLLOW_FALSE_LIT_in_label1045);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulelabelEx;
        	        }


        	    }
        	    break;
        	case 4:
        	    // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:223:4: NUMBER
        	    {
        	         MATCHT(NUMBER, &FOLLOW_NUMBER_in_label1050);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulelabelEx;
        	        }


        	    }
        	    break;
        	case 5:
        	    // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScriptDecls.g:224:4: STRING
        	    {
        	         MATCHT(STRING, &FOLLOW_STRING_in_label1055);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulelabelEx;
        	        }


        	    }
        	    break;

            }
        }
    }

    // This is where rules clean up and exit
    //
    goto rulelabelEx; /* Prevent compiler warnings */
    rulelabelEx: ;

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
            }
    return ;
}
/* $ANTLR end label */
/* End of parsing rules
 * ==============================================
 */

/* ==============================================
 * Syntactic predicates
 */
/* End of syntactic predicates
 * ==============================================
 */






/* End of code
 * =============================================================================
 */
