/** \file
 *  This C++ source file was generated by $ANTLR version 3.5-rc-2
 *
 *     -  From the grammar source file : D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScript.g
 *     -                            On : 2013-11-10 01:12:51
 *     -                for the parser : GeoGenScriptParserParser
 *
 * Editing it, at least manually, is not wise.
 *
 * C++ language generator and runtime by Gokulakannan Somasundaram ( heavy lifting from C Run-time by Jim Idle )
 *
 *
*/
// [The "BSD license"]
// Copyright (c) 2005-2009 Gokulakannan Somasundaram, ElectronDB
//
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. The name of the author may not be used to endorse or promote products
//    derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

/* -----------------------------------------
 * Include the ANTLR3 generated header file.
 */
#include    "GeoGenScriptParser.hpp"
/* ----------------------------------------- */


/* ============================================================================= */

/* =============================================================================
 * Start of recognizer
 */

	namespace 
    geogen_generated
 {

using namespace antlr3;
/** \brief Table of all token names in symbolic order, mainly used for
 *         error reporting.
 */
ANTLR_UINT8*   GeoGenScriptParserTokenNames[73+4]
     = {
        (ANTLR_UINT8*) "<invalid>",       /* String to print to indicate an invalid token */
        (ANTLR_UINT8*) "<EOR>",
        (ANTLR_UINT8*) "<DOWN>",
        (ANTLR_UINT8*) "<UP>",
        (ANTLR_UINT8*) "AS",
        (ANTLR_UINT8*) "AT",
        (ANTLR_UINT8*) "BREAK",
        (ANTLR_UINT8*) "CASE",
        (ANTLR_UINT8*) "COLON",
        (ANTLR_UINT8*) "COMMA",
        (ANTLR_UINT8*) "COMMENT",
        (ANTLR_UINT8*) "CONTINUE",
        (ANTLR_UINT8*) "DEFAULT",
        (ANTLR_UINT8*) "ELSE",
        (ANTLR_UINT8*) "ENUM",
        (ANTLR_UINT8*) "ESC_SEQ",
        (ANTLR_UINT8*) "FALSE_LIT",
        (ANTLR_UINT8*) "FOR",
        (ANTLR_UINT8*) "FUNCTION",
        (ANTLR_UINT8*) "HEX_DIGIT",
        (ANTLR_UINT8*) "IDENTIFIER",
        (ANTLR_UINT8*) "IF",
        (ANTLR_UINT8*) "INTEGER",
        (ANTLR_UINT8*) "LEFT_BRACKET",
        (ANTLR_UINT8*) "LEFT_CURLY_BRACKET",
        (ANTLR_UINT8*) "LEFT_SQUARE_BRACKET",
        (ANTLR_UINT8*) "METADATA",
        (ANTLR_UINT8*) "NUMBER",
        (ANTLR_UINT8*) "OCTAL_ESC",
        (ANTLR_UINT8*) "OPERATOR_ASSIGN",
        (ANTLR_UINT8*) "OPERATOR_ASSIGN_AND",
        (ANTLR_UINT8*) "OPERATOR_ASSIGN_DIVIDE",
        (ANTLR_UINT8*) "OPERATOR_ASSIGN_LSHIFT",
        (ANTLR_UINT8*) "OPERATOR_ASSIGN_MINUS",
        (ANTLR_UINT8*) "OPERATOR_ASSIGN_MODULO",
        (ANTLR_UINT8*) "OPERATOR_ASSIGN_OR",
        (ANTLR_UINT8*) "OPERATOR_ASSIGN_PLUS",
        (ANTLR_UINT8*) "OPERATOR_ASSIGN_RSHIFT",
        (ANTLR_UINT8*) "OPERATOR_ASSIGN_TIMES",
        (ANTLR_UINT8*) "OPERATOR_ASSIGN_XOR",
        (ANTLR_UINT8*) "OPERATOR_BIT_AND",
        (ANTLR_UINT8*) "OPERATOR_BIT_OR",
        (ANTLR_UINT8*) "OPERATOR_BIT_XOR",
        (ANTLR_UINT8*) "OPERATOR_DECREMENT",
        (ANTLR_UINT8*) "OPERATOR_DIVIDE",
        (ANTLR_UINT8*) "OPERATOR_DOT",
        (ANTLR_UINT8*) "OPERATOR_EQUAL_TO",
        (ANTLR_UINT8*) "OPERATOR_EXPR_IF",
        (ANTLR_UINT8*) "OPERATOR_GREATER_THAN",
        (ANTLR_UINT8*) "OPERATOR_GREATER_THAN_OR_EQUAL_TO",
        (ANTLR_UINT8*) "OPERATOR_INCREMENT",
        (ANTLR_UINT8*) "OPERATOR_IS",
        (ANTLR_UINT8*) "OPERATOR_LESS_THAN",
        (ANTLR_UINT8*) "OPERATOR_LESS_THAN_OR_EQUAL_TO",
        (ANTLR_UINT8*) "OPERATOR_LSHIFT",
        (ANTLR_UINT8*) "OPERATOR_MINUS",
        (ANTLR_UINT8*) "OPERATOR_MODULO",
        (ANTLR_UINT8*) "OPERATOR_NOT",
        (ANTLR_UINT8*) "OPERATOR_NOT_EQUAL_TO",
        (ANTLR_UINT8*) "OPERATOR_PLUS",
        (ANTLR_UINT8*) "OPERATOR_REL_AND",
        (ANTLR_UINT8*) "OPERATOR_REL_OR",
        (ANTLR_UINT8*) "OPERATOR_RSHIFT",
        (ANTLR_UINT8*) "OPERATOR_TIMES",
        (ANTLR_UINT8*) "RETURN",
        (ANTLR_UINT8*) "RIGHT_BRACKET",
        (ANTLR_UINT8*) "RIGHT_SQUARE_BRACKET",
        (ANTLR_UINT8*) "RIGTH_CURLY_BRACKET",
        (ANTLR_UINT8*) "SEMICOLON",
        (ANTLR_UINT8*) "STRING",
        (ANTLR_UINT8*) "SWITCH",
        (ANTLR_UINT8*) "TRUE_LIT",
        (ANTLR_UINT8*) "UNICODE_ESC",
        (ANTLR_UINT8*) "VAR",
        (ANTLR_UINT8*) "WHILE",
        (ANTLR_UINT8*) "WHITESPACE",
        (ANTLR_UINT8*) "YIELD"
       };


/** \brief Name of the grammar file that generated this code
 */
static const char fileName[] = "D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScript.g";

/** \brief Return the name of the grammar file that generated this code.
 */
const char* GeoGenScriptParser::getGrammarFileName()
{
	return fileName;
}
/** \brief Create a new GeoGenScriptParser parser and return a context for it.
 *
 * \param[in] instream Pointer to an input stream interface.
 *
 * \return Pointer to new parser context upon success.
 */
GeoGenScriptParser::GeoGenScriptParser( StreamType* instream)
    :ImplTraits::BaseParserType(ANTLR_SIZE_HINT, instream, NULL)

{
	// See if we can create a new parser with the standard constructor
	//
	this->init(instream);
}

/** \brief Create a new GeoGenScriptParser parser and return a context for it.
 *
 * \param[in] instream Pointer to an input stream interface.
 *
 * \return Pointer to new parser context upon success.
 */
GeoGenScriptParser::GeoGenScriptParser( StreamType* instream, RecognizerSharedStateType* state)
    :ImplTraits::BaseParserType(ANTLR_SIZE_HINT, instream, state)

{
	this->init(instream );
}

void GeoGenScriptParser::init(StreamType* instream)
{
	/* Install the token table
	*/
	this->get_psrstate()->set_tokenNames( GeoGenScriptParserTokenNames );


}

void
GeoGenScriptParser::reset()
{
    this->get_rec()->reset();
}

/** Free the parser resources
 */
GeoGenScriptParser::~GeoGenScriptParser()
 {
}

/** Return token names used by this 
parser

 *
 * The returned pointer is used as an index into the token names table (using the token
 * number as the index).
 *
 * \return Pointer to first char * in the table.
 */
static ANTLR_UINT8**	getTokenNames()
{
        return GeoGenScriptParserTokenNames;
}


/* Declare the bitsets
 */
/** Bitset defining follow set for error recovery in rule state: GeoGenScriptParser  */
static	ANTLR_BITWORD FOLLOW_declaration_in_script80_bits[]	= { ANTLR_UINT64_LIT(0x0A8408000FB74862), ANTLR_UINT64_LIT(0x00000000000016F1) };
static  GeoGenScriptParserImplTraits::BitsetListType FOLLOW_declaration_in_script80( FOLLOW_declaration_in_script80_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: GeoGenScriptParser  */
static	ANTLR_BITWORD FOLLOW_metadata_in_script83_bits[]	= { ANTLR_UINT64_LIT(0x0A8408000BB74862), ANTLR_UINT64_LIT(0x00000000000016F1) };
static  GeoGenScriptParserImplTraits::BitsetListType FOLLOW_metadata_in_script83( FOLLOW_metadata_in_script83_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: GeoGenScriptParser  */
static	ANTLR_BITWORD FOLLOW_statement_in_script87_bits[]	= { ANTLR_UINT64_LIT(0x0A8408000BB74862), ANTLR_UINT64_LIT(0x00000000000016F1) };
static  GeoGenScriptParserImplTraits::BitsetListType FOLLOW_statement_in_script87( FOLLOW_statement_in_script87_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: GeoGenScriptParser  */
static	ANTLR_BITWORD FOLLOW_declaration_in_script91_bits[]	= { ANTLR_UINT64_LIT(0x0A8408000BB74862), ANTLR_UINT64_LIT(0x00000000000016F1) };
static  GeoGenScriptParserImplTraits::BitsetListType FOLLOW_declaration_in_script91( FOLLOW_declaration_in_script91_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: GeoGenScriptParser  */
static	ANTLR_BITWORD FOLLOW_METADATA_in_metadata109_bits[]	= { ANTLR_UINT64_LIT(0x0000000001000000) };
static  GeoGenScriptParserImplTraits::BitsetListType FOLLOW_METADATA_in_metadata109( FOLLOW_METADATA_in_metadata109_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: GeoGenScriptParser  */
static	ANTLR_BITWORD FOLLOW_keyValueCollection_in_metadata112_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  GeoGenScriptParserImplTraits::BitsetListType FOLLOW_keyValueCollection_in_metadata112( FOLLOW_keyValueCollection_in_metadata112_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: GeoGenScriptParser  */
static	ANTLR_BITWORD FOLLOW_LEFT_CURLY_BRACKET_in_keyValueCollection119_bits[]	= { ANTLR_UINT64_LIT(0x0000000008100020), ANTLR_UINT64_LIT(0x0000000000000008) };
static  GeoGenScriptParserImplTraits::BitsetListType FOLLOW_LEFT_CURLY_BRACKET_in_keyValueCollection119( FOLLOW_LEFT_CURLY_BRACKET_in_keyValueCollection119_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: GeoGenScriptParser  */
static	ANTLR_BITWORD FOLLOW_keyValuePair_in_keyValueCollection122_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000200), ANTLR_UINT64_LIT(0x0000000000000008) };
static  GeoGenScriptParserImplTraits::BitsetListType FOLLOW_keyValuePair_in_keyValueCollection122( FOLLOW_keyValuePair_in_keyValueCollection122_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: GeoGenScriptParser  */
static	ANTLR_BITWORD FOLLOW_COMMA_in_keyValueCollection125_bits[]	= { ANTLR_UINT64_LIT(0x0000000008100020) };
static  GeoGenScriptParserImplTraits::BitsetListType FOLLOW_COMMA_in_keyValueCollection125( FOLLOW_COMMA_in_keyValueCollection125_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: GeoGenScriptParser  */
static	ANTLR_BITWORD FOLLOW_keyValuePair_in_keyValueCollection127_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000200), ANTLR_UINT64_LIT(0x0000000000000008) };
static  GeoGenScriptParserImplTraits::BitsetListType FOLLOW_keyValuePair_in_keyValueCollection127( FOLLOW_keyValuePair_in_keyValueCollection127_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: GeoGenScriptParser  */
static	ANTLR_BITWORD FOLLOW_RIGTH_CURLY_BRACKET_in_keyValueCollection134_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  GeoGenScriptParserImplTraits::BitsetListType FOLLOW_RIGTH_CURLY_BRACKET_in_keyValueCollection134( FOLLOW_RIGTH_CURLY_BRACKET_in_keyValueCollection134_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: GeoGenScriptParser  */
static	ANTLR_BITWORD FOLLOW_IDENTIFIER_in_keyValuePair142_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000100) };
static  GeoGenScriptParserImplTraits::BitsetListType FOLLOW_IDENTIFIER_in_keyValuePair142( FOLLOW_IDENTIFIER_in_keyValuePair142_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: GeoGenScriptParser  */
static	ANTLR_BITWORD FOLLOW_AT_in_keyValuePair147_bits[]	= { ANTLR_UINT64_LIT(0x0000000008000000) };
static  GeoGenScriptParserImplTraits::BitsetListType FOLLOW_AT_in_keyValuePair147( FOLLOW_AT_in_keyValuePair147_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: GeoGenScriptParser  */
static	ANTLR_BITWORD FOLLOW_NUMBER_in_keyValuePair150_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000100) };
static  GeoGenScriptParserImplTraits::BitsetListType FOLLOW_NUMBER_in_keyValuePair150( FOLLOW_NUMBER_in_keyValuePair150_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: GeoGenScriptParser  */
static	ANTLR_BITWORD FOLLOW_COLON_in_keyValuePair155_bits[]	= { ANTLR_UINT64_LIT(0x0A8408000B910020), ANTLR_UINT64_LIT(0x00000000000000A0) };
static  GeoGenScriptParserImplTraits::BitsetListType FOLLOW_COLON_in_keyValuePair155( FOLLOW_COLON_in_keyValuePair155_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: GeoGenScriptParser  */
static	ANTLR_BITWORD FOLLOW_keyValueValue_in_keyValuePair157_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  GeoGenScriptParserImplTraits::BitsetListType FOLLOW_keyValueValue_in_keyValuePair157( FOLLOW_keyValueValue_in_keyValuePair157_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: GeoGenScriptParser  */
static	ANTLR_BITWORD FOLLOW_expression_in_keyValueValue164_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  GeoGenScriptParserImplTraits::BitsetListType FOLLOW_expression_in_keyValueValue164( FOLLOW_expression_in_keyValueValue164_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: GeoGenScriptParser  */
static	ANTLR_BITWORD FOLLOW_keyValueCollection_in_keyValueValue168_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  GeoGenScriptParserImplTraits::BitsetListType FOLLOW_keyValueCollection_in_keyValueValue168( FOLLOW_keyValueCollection_in_keyValueValue168_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: GeoGenScriptParser  */
static	ANTLR_BITWORD FOLLOW_enumDeclaration_in_declaration175_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  GeoGenScriptParserImplTraits::BitsetListType FOLLOW_enumDeclaration_in_declaration175( FOLLOW_enumDeclaration_in_declaration175_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: GeoGenScriptParser  */
static	ANTLR_BITWORD FOLLOW_functionDeclaration_in_declaration179_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  GeoGenScriptParserImplTraits::BitsetListType FOLLOW_functionDeclaration_in_declaration179( FOLLOW_functionDeclaration_in_declaration179_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: GeoGenScriptParser  */
static	ANTLR_BITWORD FOLLOW_ENUM_in_enumDeclaration186_bits[]	= { ANTLR_UINT64_LIT(0x0000000000100000) };
static  GeoGenScriptParserImplTraits::BitsetListType FOLLOW_ENUM_in_enumDeclaration186( FOLLOW_ENUM_in_enumDeclaration186_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: GeoGenScriptParser  */
static	ANTLR_BITWORD FOLLOW_IDENTIFIER_in_enumDeclaration188_bits[]	= { ANTLR_UINT64_LIT(0x0000000001000000) };
static  GeoGenScriptParserImplTraits::BitsetListType FOLLOW_IDENTIFIER_in_enumDeclaration188( FOLLOW_IDENTIFIER_in_enumDeclaration188_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: GeoGenScriptParser  */
static	ANTLR_BITWORD FOLLOW_LEFT_CURLY_BRACKET_in_enumDeclaration190_bits[]	= { ANTLR_UINT64_LIT(0x0000000000100000), ANTLR_UINT64_LIT(0x0000000000000008) };
static  GeoGenScriptParserImplTraits::BitsetListType FOLLOW_LEFT_CURLY_BRACKET_in_enumDeclaration190( FOLLOW_LEFT_CURLY_BRACKET_in_enumDeclaration190_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: GeoGenScriptParser  */
static	ANTLR_BITWORD FOLLOW_enumValues_in_enumDeclaration192_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000008) };
static  GeoGenScriptParserImplTraits::BitsetListType FOLLOW_enumValues_in_enumDeclaration192( FOLLOW_enumValues_in_enumDeclaration192_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: GeoGenScriptParser  */
static	ANTLR_BITWORD FOLLOW_RIGTH_CURLY_BRACKET_in_enumDeclaration195_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  GeoGenScriptParserImplTraits::BitsetListType FOLLOW_RIGTH_CURLY_BRACKET_in_enumDeclaration195( FOLLOW_RIGTH_CURLY_BRACKET_in_enumDeclaration195_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: GeoGenScriptParser  */
static	ANTLR_BITWORD FOLLOW_enumValue_in_enumValues202_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000202) };
static  GeoGenScriptParserImplTraits::BitsetListType FOLLOW_enumValue_in_enumValues202( FOLLOW_enumValue_in_enumValues202_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: GeoGenScriptParser  */
static	ANTLR_BITWORD FOLLOW_COMMA_in_enumValues205_bits[]	= { ANTLR_UINT64_LIT(0x0000000000100000) };
static  GeoGenScriptParserImplTraits::BitsetListType FOLLOW_COMMA_in_enumValues205( FOLLOW_COMMA_in_enumValues205_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: GeoGenScriptParser  */
static	ANTLR_BITWORD FOLLOW_enumValue_in_enumValues207_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000202) };
static  GeoGenScriptParserImplTraits::BitsetListType FOLLOW_enumValue_in_enumValues207( FOLLOW_enumValue_in_enumValues207_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: GeoGenScriptParser  */
static	ANTLR_BITWORD FOLLOW_IDENTIFIER_in_enumValue221_bits[]	= { ANTLR_UINT64_LIT(0x0000000020000002) };
static  GeoGenScriptParserImplTraits::BitsetListType FOLLOW_IDENTIFIER_in_enumValue221( FOLLOW_IDENTIFIER_in_enumValue221_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: GeoGenScriptParser  */
static	ANTLR_BITWORD FOLLOW_OPERATOR_ASSIGN_in_enumValue225_bits[]	= { ANTLR_UINT64_LIT(0x0A8408000B910020), ANTLR_UINT64_LIT(0x00000000000000A0) };
static  GeoGenScriptParserImplTraits::BitsetListType FOLLOW_OPERATOR_ASSIGN_in_enumValue225( FOLLOW_OPERATOR_ASSIGN_in_enumValue225_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: GeoGenScriptParser  */
static	ANTLR_BITWORD FOLLOW_expression_in_enumValue227_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  GeoGenScriptParserImplTraits::BitsetListType FOLLOW_expression_in_enumValue227( FOLLOW_expression_in_enumValue227_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: GeoGenScriptParser  */
static	ANTLR_BITWORD FOLLOW_FUNCTION_in_functionDeclaration236_bits[]	= { ANTLR_UINT64_LIT(0x0000000000100000) };
static  GeoGenScriptParserImplTraits::BitsetListType FOLLOW_FUNCTION_in_functionDeclaration236( FOLLOW_FUNCTION_in_functionDeclaration236_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: GeoGenScriptParser  */
static	ANTLR_BITWORD FOLLOW_IDENTIFIER_in_functionDeclaration238_bits[]	= { ANTLR_UINT64_LIT(0x0000000000800000) };
static  GeoGenScriptParserImplTraits::BitsetListType FOLLOW_IDENTIFIER_in_functionDeclaration238( FOLLOW_IDENTIFIER_in_functionDeclaration238_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: GeoGenScriptParser  */
static	ANTLR_BITWORD FOLLOW_LEFT_BRACKET_in_functionDeclaration240_bits[]	= { ANTLR_UINT64_LIT(0x0000000000100000), ANTLR_UINT64_LIT(0x0000000000000002) };
static  GeoGenScriptParserImplTraits::BitsetListType FOLLOW_LEFT_BRACKET_in_functionDeclaration240( FOLLOW_LEFT_BRACKET_in_functionDeclaration240_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: GeoGenScriptParser  */
static	ANTLR_BITWORD FOLLOW_formalParameters_in_functionDeclaration242_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000002) };
static  GeoGenScriptParserImplTraits::BitsetListType FOLLOW_formalParameters_in_functionDeclaration242( FOLLOW_formalParameters_in_functionDeclaration242_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: GeoGenScriptParser  */
static	ANTLR_BITWORD FOLLOW_RIGHT_BRACKET_in_functionDeclaration245_bits[]	= { ANTLR_UINT64_LIT(0x0000000001000000) };
static  GeoGenScriptParserImplTraits::BitsetListType FOLLOW_RIGHT_BRACKET_in_functionDeclaration245( FOLLOW_RIGHT_BRACKET_in_functionDeclaration245_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: GeoGenScriptParser  */
static	ANTLR_BITWORD FOLLOW_block_in_functionDeclaration247_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  GeoGenScriptParserImplTraits::BitsetListType FOLLOW_block_in_functionDeclaration247( FOLLOW_block_in_functionDeclaration247_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: GeoGenScriptParser  */
static	ANTLR_BITWORD FOLLOW_IDENTIFIER_in_formalParameters254_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000202) };
static  GeoGenScriptParserImplTraits::BitsetListType FOLLOW_IDENTIFIER_in_formalParameters254( FOLLOW_IDENTIFIER_in_formalParameters254_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: GeoGenScriptParser  */
static	ANTLR_BITWORD FOLLOW_COMMA_in_formalParameters257_bits[]	= { ANTLR_UINT64_LIT(0x0000000000100000) };
static  GeoGenScriptParserImplTraits::BitsetListType FOLLOW_COMMA_in_formalParameters257( FOLLOW_COMMA_in_formalParameters257_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: GeoGenScriptParser  */
static	ANTLR_BITWORD FOLLOW_IDENTIFIER_in_formalParameters259_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000202) };
static  GeoGenScriptParserImplTraits::BitsetListType FOLLOW_IDENTIFIER_in_formalParameters259( FOLLOW_IDENTIFIER_in_formalParameters259_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: GeoGenScriptParser  */
static	ANTLR_BITWORD FOLLOW_LEFT_CURLY_BRACKET_in_block268_bits[]	= { ANTLR_UINT64_LIT(0x0A8408000BB30860), ANTLR_UINT64_LIT(0x00000000000016F9) };
static  GeoGenScriptParserImplTraits::BitsetListType FOLLOW_LEFT_CURLY_BRACKET_in_block268( FOLLOW_LEFT_CURLY_BRACKET_in_block268_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: GeoGenScriptParser  */
static	ANTLR_BITWORD FOLLOW_statement_in_block270_bits[]	= { ANTLR_UINT64_LIT(0x0A8408000BB30860), ANTLR_UINT64_LIT(0x00000000000016F9) };
static  GeoGenScriptParserImplTraits::BitsetListType FOLLOW_statement_in_block270( FOLLOW_statement_in_block270_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: GeoGenScriptParser  */
static	ANTLR_BITWORD FOLLOW_RIGTH_CURLY_BRACKET_in_block273_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  GeoGenScriptParserImplTraits::BitsetListType FOLLOW_RIGTH_CURLY_BRACKET_in_block273( FOLLOW_RIGTH_CURLY_BRACKET_in_block273_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: GeoGenScriptParser  */
static	ANTLR_BITWORD FOLLOW_BREAK_in_statement289_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000010) };
static  GeoGenScriptParserImplTraits::BitsetListType FOLLOW_BREAK_in_statement289( FOLLOW_BREAK_in_statement289_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: GeoGenScriptParser  */
static	ANTLR_BITWORD FOLLOW_SEMICOLON_in_statement291_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  GeoGenScriptParserImplTraits::BitsetListType FOLLOW_SEMICOLON_in_statement291( FOLLOW_SEMICOLON_in_statement291_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: GeoGenScriptParser  */
static	ANTLR_BITWORD FOLLOW_CONTINUE_in_statement299_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000010) };
static  GeoGenScriptParserImplTraits::BitsetListType FOLLOW_CONTINUE_in_statement299( FOLLOW_CONTINUE_in_statement299_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: GeoGenScriptParser  */
static	ANTLR_BITWORD FOLLOW_SEMICOLON_in_statement301_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  GeoGenScriptParserImplTraits::BitsetListType FOLLOW_SEMICOLON_in_statement301( FOLLOW_SEMICOLON_in_statement301_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: GeoGenScriptParser  */
static	ANTLR_BITWORD FOLLOW_variableDeclaration_in_statement309_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000010) };
static  GeoGenScriptParserImplTraits::BitsetListType FOLLOW_variableDeclaration_in_statement309( FOLLOW_variableDeclaration_in_statement309_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: GeoGenScriptParser  */
static	ANTLR_BITWORD FOLLOW_SEMICOLON_in_statement311_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  GeoGenScriptParserImplTraits::BitsetListType FOLLOW_SEMICOLON_in_statement311( FOLLOW_SEMICOLON_in_statement311_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: GeoGenScriptParser  */
static	ANTLR_BITWORD FOLLOW_expression_in_statement319_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000010) };
static  GeoGenScriptParserImplTraits::BitsetListType FOLLOW_expression_in_statement319( FOLLOW_expression_in_statement319_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: GeoGenScriptParser  */
static	ANTLR_BITWORD FOLLOW_SEMICOLON_in_statement321_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  GeoGenScriptParserImplTraits::BitsetListType FOLLOW_SEMICOLON_in_statement321( FOLLOW_SEMICOLON_in_statement321_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: GeoGenScriptParser  */
static	ANTLR_BITWORD FOLLOW_yieldStatement_in_statement329_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000010) };
static  GeoGenScriptParserImplTraits::BitsetListType FOLLOW_yieldStatement_in_statement329( FOLLOW_yieldStatement_in_statement329_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: GeoGenScriptParser  */
static	ANTLR_BITWORD FOLLOW_SEMICOLON_in_statement331_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  GeoGenScriptParserImplTraits::BitsetListType FOLLOW_SEMICOLON_in_statement331( FOLLOW_SEMICOLON_in_statement331_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: GeoGenScriptParser  */
static	ANTLR_BITWORD FOLLOW_returnStatement_in_statement339_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000010) };
static  GeoGenScriptParserImplTraits::BitsetListType FOLLOW_returnStatement_in_statement339( FOLLOW_returnStatement_in_statement339_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: GeoGenScriptParser  */
static	ANTLR_BITWORD FOLLOW_SEMICOLON_in_statement341_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  GeoGenScriptParserImplTraits::BitsetListType FOLLOW_SEMICOLON_in_statement341( FOLLOW_SEMICOLON_in_statement341_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: GeoGenScriptParser  */
static	ANTLR_BITWORD FOLLOW_whileStatement_in_statement349_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  GeoGenScriptParserImplTraits::BitsetListType FOLLOW_whileStatement_in_statement349( FOLLOW_whileStatement_in_statement349_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: GeoGenScriptParser  */
static	ANTLR_BITWORD FOLLOW_forStatement_in_statement357_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  GeoGenScriptParserImplTraits::BitsetListType FOLLOW_forStatement_in_statement357( FOLLOW_forStatement_in_statement357_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: GeoGenScriptParser  */
static	ANTLR_BITWORD FOLLOW_ifStatement_in_statement365_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  GeoGenScriptParserImplTraits::BitsetListType FOLLOW_ifStatement_in_statement365( FOLLOW_ifStatement_in_statement365_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: GeoGenScriptParser  */
static	ANTLR_BITWORD FOLLOW_switchStatement_in_statement373_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  GeoGenScriptParserImplTraits::BitsetListType FOLLOW_switchStatement_in_statement373( FOLLOW_switchStatement_in_statement373_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: GeoGenScriptParser  */
static	ANTLR_BITWORD FOLLOW_block_in_statement385_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  GeoGenScriptParserImplTraits::BitsetListType FOLLOW_block_in_statement385( FOLLOW_block_in_statement385_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: GeoGenScriptParser  */
static	ANTLR_BITWORD FOLLOW_SEMICOLON_in_statement393_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  GeoGenScriptParserImplTraits::BitsetListType FOLLOW_SEMICOLON_in_statement393( FOLLOW_SEMICOLON_in_statement393_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: GeoGenScriptParser  */
static	ANTLR_BITWORD FOLLOW_VAR_in_variableDeclaration404_bits[]	= { ANTLR_UINT64_LIT(0x0000000000100000) };
static  GeoGenScriptParserImplTraits::BitsetListType FOLLOW_VAR_in_variableDeclaration404( FOLLOW_VAR_in_variableDeclaration404_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: GeoGenScriptParser  */
static	ANTLR_BITWORD FOLLOW_IDENTIFIER_in_variableDeclaration406_bits[]	= { ANTLR_UINT64_LIT(0x0000000020000002) };
static  GeoGenScriptParserImplTraits::BitsetListType FOLLOW_IDENTIFIER_in_variableDeclaration406( FOLLOW_IDENTIFIER_in_variableDeclaration406_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: GeoGenScriptParser  */
static	ANTLR_BITWORD FOLLOW_OPERATOR_ASSIGN_in_variableDeclaration409_bits[]	= { ANTLR_UINT64_LIT(0x0A8408000B910020), ANTLR_UINT64_LIT(0x00000000000000A0) };
static  GeoGenScriptParserImplTraits::BitsetListType FOLLOW_OPERATOR_ASSIGN_in_variableDeclaration409( FOLLOW_OPERATOR_ASSIGN_in_variableDeclaration409_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: GeoGenScriptParser  */
static	ANTLR_BITWORD FOLLOW_expression_in_variableDeclaration411_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  GeoGenScriptParserImplTraits::BitsetListType FOLLOW_expression_in_variableDeclaration411( FOLLOW_expression_in_variableDeclaration411_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: GeoGenScriptParser  */
static	ANTLR_BITWORD FOLLOW_YIELD_in_yieldStatement425_bits[]	= { ANTLR_UINT64_LIT(0x0A8408000B910020), ANTLR_UINT64_LIT(0x00000000000000A0) };
static  GeoGenScriptParserImplTraits::BitsetListType FOLLOW_YIELD_in_yieldStatement425( FOLLOW_YIELD_in_yieldStatement425_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: GeoGenScriptParser  */
static	ANTLR_BITWORD FOLLOW_expression_in_yieldStatement427_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000010) };
static  GeoGenScriptParserImplTraits::BitsetListType FOLLOW_expression_in_yieldStatement427( FOLLOW_expression_in_yieldStatement427_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: GeoGenScriptParser  */
static	ANTLR_BITWORD FOLLOW_AS_in_yieldStatement429_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000020) };
static  GeoGenScriptParserImplTraits::BitsetListType FOLLOW_AS_in_yieldStatement429( FOLLOW_AS_in_yieldStatement429_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: GeoGenScriptParser  */
static	ANTLR_BITWORD FOLLOW_STRING_in_yieldStatement431_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  GeoGenScriptParserImplTraits::BitsetListType FOLLOW_STRING_in_yieldStatement431( FOLLOW_STRING_in_yieldStatement431_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: GeoGenScriptParser  */
static	ANTLR_BITWORD FOLLOW_YIELD_in_yieldStatement439_bits[]	= { ANTLR_UINT64_LIT(0x0A8408000B910020), ANTLR_UINT64_LIT(0x00000000000000A0) };
static  GeoGenScriptParserImplTraits::BitsetListType FOLLOW_YIELD_in_yieldStatement439( FOLLOW_YIELD_in_yieldStatement439_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: GeoGenScriptParser  */
static	ANTLR_BITWORD FOLLOW_expression_in_yieldStatement441_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  GeoGenScriptParserImplTraits::BitsetListType FOLLOW_expression_in_yieldStatement441( FOLLOW_expression_in_yieldStatement441_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: GeoGenScriptParser  */
static	ANTLR_BITWORD FOLLOW_RETURN_in_returnStatement449_bits[]	= { ANTLR_UINT64_LIT(0x0A8408000B910020), ANTLR_UINT64_LIT(0x00000000000000A0) };
static  GeoGenScriptParserImplTraits::BitsetListType FOLLOW_RETURN_in_returnStatement449( FOLLOW_RETURN_in_returnStatement449_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: GeoGenScriptParser  */
static	ANTLR_BITWORD FOLLOW_expression_in_returnStatement451_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  GeoGenScriptParserImplTraits::BitsetListType FOLLOW_expression_in_returnStatement451( FOLLOW_expression_in_returnStatement451_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: GeoGenScriptParser  */
static	ANTLR_BITWORD FOLLOW_WHILE_in_whileStatement458_bits[]	= { ANTLR_UINT64_LIT(0x0000000000800000) };
static  GeoGenScriptParserImplTraits::BitsetListType FOLLOW_WHILE_in_whileStatement458( FOLLOW_WHILE_in_whileStatement458_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: GeoGenScriptParser  */
static	ANTLR_BITWORD FOLLOW_LEFT_BRACKET_in_whileStatement460_bits[]	= { ANTLR_UINT64_LIT(0x0A8408000B910020), ANTLR_UINT64_LIT(0x00000000000000A0) };
static  GeoGenScriptParserImplTraits::BitsetListType FOLLOW_LEFT_BRACKET_in_whileStatement460( FOLLOW_LEFT_BRACKET_in_whileStatement460_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: GeoGenScriptParser  */
static	ANTLR_BITWORD FOLLOW_expression_in_whileStatement462_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000002) };
static  GeoGenScriptParserImplTraits::BitsetListType FOLLOW_expression_in_whileStatement462( FOLLOW_expression_in_whileStatement462_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: GeoGenScriptParser  */
static	ANTLR_BITWORD FOLLOW_RIGHT_BRACKET_in_whileStatement464_bits[]	= { ANTLR_UINT64_LIT(0x0A8408000BB30860), ANTLR_UINT64_LIT(0x00000000000016F1) };
static  GeoGenScriptParserImplTraits::BitsetListType FOLLOW_RIGHT_BRACKET_in_whileStatement464( FOLLOW_RIGHT_BRACKET_in_whileStatement464_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: GeoGenScriptParser  */
static	ANTLR_BITWORD FOLLOW_statement_in_whileStatement466_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  GeoGenScriptParserImplTraits::BitsetListType FOLLOW_statement_in_whileStatement466( FOLLOW_statement_in_whileStatement466_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: GeoGenScriptParser  */
static	ANTLR_BITWORD FOLLOW_FOR_in_forStatement474_bits[]	= { ANTLR_UINT64_LIT(0x0000000000800000) };
static  GeoGenScriptParserImplTraits::BitsetListType FOLLOW_FOR_in_forStatement474( FOLLOW_FOR_in_forStatement474_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: GeoGenScriptParser  */
static	ANTLR_BITWORD FOLLOW_LEFT_BRACKET_in_forStatement476_bits[]	= { ANTLR_UINT64_LIT(0x0A8408000B910020), ANTLR_UINT64_LIT(0x00000000000002B0) };
static  GeoGenScriptParserImplTraits::BitsetListType FOLLOW_LEFT_BRACKET_in_forStatement476( FOLLOW_LEFT_BRACKET_in_forStatement476_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: GeoGenScriptParser  */
static	ANTLR_BITWORD FOLLOW_initExpression_in_forStatement478_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000010) };
static  GeoGenScriptParserImplTraits::BitsetListType FOLLOW_initExpression_in_forStatement478( FOLLOW_initExpression_in_forStatement478_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: GeoGenScriptParser  */
static	ANTLR_BITWORD FOLLOW_SEMICOLON_in_forStatement481_bits[]	= { ANTLR_UINT64_LIT(0x0A8408000B910020), ANTLR_UINT64_LIT(0x00000000000000B0) };
static  GeoGenScriptParserImplTraits::BitsetListType FOLLOW_SEMICOLON_in_forStatement481( FOLLOW_SEMICOLON_in_forStatement481_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: GeoGenScriptParser  */
static	ANTLR_BITWORD FOLLOW_expression_in_forStatement483_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000010) };
static  GeoGenScriptParserImplTraits::BitsetListType FOLLOW_expression_in_forStatement483( FOLLOW_expression_in_forStatement483_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: GeoGenScriptParser  */
static	ANTLR_BITWORD FOLLOW_SEMICOLON_in_forStatement486_bits[]	= { ANTLR_UINT64_LIT(0x0A8408000B910020), ANTLR_UINT64_LIT(0x00000000000000A2) };
static  GeoGenScriptParserImplTraits::BitsetListType FOLLOW_SEMICOLON_in_forStatement486( FOLLOW_SEMICOLON_in_forStatement486_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: GeoGenScriptParser  */
static	ANTLR_BITWORD FOLLOW_expression_in_forStatement488_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000002) };
static  GeoGenScriptParserImplTraits::BitsetListType FOLLOW_expression_in_forStatement488( FOLLOW_expression_in_forStatement488_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: GeoGenScriptParser  */
static	ANTLR_BITWORD FOLLOW_RIGHT_BRACKET_in_forStatement491_bits[]	= { ANTLR_UINT64_LIT(0x0A8408000BB30860), ANTLR_UINT64_LIT(0x00000000000016F1) };
static  GeoGenScriptParserImplTraits::BitsetListType FOLLOW_RIGHT_BRACKET_in_forStatement491( FOLLOW_RIGHT_BRACKET_in_forStatement491_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: GeoGenScriptParser  */
static	ANTLR_BITWORD FOLLOW_statement_in_forStatement493_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  GeoGenScriptParserImplTraits::BitsetListType FOLLOW_statement_in_forStatement493( FOLLOW_statement_in_forStatement493_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: GeoGenScriptParser  */
static	ANTLR_BITWORD FOLLOW_VAR_in_initExpression505_bits[]	= { ANTLR_UINT64_LIT(0x0000000000100000) };
static  GeoGenScriptParserImplTraits::BitsetListType FOLLOW_VAR_in_initExpression505( FOLLOW_VAR_in_initExpression505_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: GeoGenScriptParser  */
static	ANTLR_BITWORD FOLLOW_IDENTIFIER_in_initExpression507_bits[]	= { ANTLR_UINT64_LIT(0x0000000020000000) };
static  GeoGenScriptParserImplTraits::BitsetListType FOLLOW_IDENTIFIER_in_initExpression507( FOLLOW_IDENTIFIER_in_initExpression507_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: GeoGenScriptParser  */
static	ANTLR_BITWORD FOLLOW_OPERATOR_ASSIGN_in_initExpression509_bits[]	= { ANTLR_UINT64_LIT(0x0A8408000B910020), ANTLR_UINT64_LIT(0x00000000000000A0) };
static  GeoGenScriptParserImplTraits::BitsetListType FOLLOW_OPERATOR_ASSIGN_in_initExpression509( FOLLOW_OPERATOR_ASSIGN_in_initExpression509_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: GeoGenScriptParser  */
static	ANTLR_BITWORD FOLLOW_expression_in_initExpression511_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  GeoGenScriptParserImplTraits::BitsetListType FOLLOW_expression_in_initExpression511( FOLLOW_expression_in_initExpression511_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: GeoGenScriptParser  */
static	ANTLR_BITWORD FOLLOW_expression_in_initExpression519_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  GeoGenScriptParserImplTraits::BitsetListType FOLLOW_expression_in_initExpression519( FOLLOW_expression_in_initExpression519_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: GeoGenScriptParser  */
static	ANTLR_BITWORD FOLLOW_IF_in_ifStatement530_bits[]	= { ANTLR_UINT64_LIT(0x0000000000800000) };
static  GeoGenScriptParserImplTraits::BitsetListType FOLLOW_IF_in_ifStatement530( FOLLOW_IF_in_ifStatement530_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: GeoGenScriptParser  */
static	ANTLR_BITWORD FOLLOW_LEFT_BRACKET_in_ifStatement532_bits[]	= { ANTLR_UINT64_LIT(0x0A8408000B910020), ANTLR_UINT64_LIT(0x00000000000000A0) };
static  GeoGenScriptParserImplTraits::BitsetListType FOLLOW_LEFT_BRACKET_in_ifStatement532( FOLLOW_LEFT_BRACKET_in_ifStatement532_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: GeoGenScriptParser  */
static	ANTLR_BITWORD FOLLOW_expression_in_ifStatement534_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000002) };
static  GeoGenScriptParserImplTraits::BitsetListType FOLLOW_expression_in_ifStatement534( FOLLOW_expression_in_ifStatement534_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: GeoGenScriptParser  */
static	ANTLR_BITWORD FOLLOW_RIGHT_BRACKET_in_ifStatement536_bits[]	= { ANTLR_UINT64_LIT(0x0A8408000BB30860), ANTLR_UINT64_LIT(0x00000000000016F1) };
static  GeoGenScriptParserImplTraits::BitsetListType FOLLOW_RIGHT_BRACKET_in_ifStatement536( FOLLOW_RIGHT_BRACKET_in_ifStatement536_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: GeoGenScriptParser  */
static	ANTLR_BITWORD FOLLOW_statement_in_ifStatement538_bits[]	= { ANTLR_UINT64_LIT(0x0000000000002002) };
static  GeoGenScriptParserImplTraits::BitsetListType FOLLOW_statement_in_ifStatement538( FOLLOW_statement_in_ifStatement538_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: GeoGenScriptParser  */
static	ANTLR_BITWORD FOLLOW_ELSE_in_ifStatement545_bits[]	= { ANTLR_UINT64_LIT(0x0A8408000BB30860), ANTLR_UINT64_LIT(0x00000000000016F1) };
static  GeoGenScriptParserImplTraits::BitsetListType FOLLOW_ELSE_in_ifStatement545( FOLLOW_ELSE_in_ifStatement545_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: GeoGenScriptParser  */
static	ANTLR_BITWORD FOLLOW_statement_in_ifStatement547_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  GeoGenScriptParserImplTraits::BitsetListType FOLLOW_statement_in_ifStatement547( FOLLOW_statement_in_ifStatement547_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: GeoGenScriptParser  */
static	ANTLR_BITWORD FOLLOW_SWITCH_in_switchStatement561_bits[]	= { ANTLR_UINT64_LIT(0x0000000000800000) };
static  GeoGenScriptParserImplTraits::BitsetListType FOLLOW_SWITCH_in_switchStatement561( FOLLOW_SWITCH_in_switchStatement561_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: GeoGenScriptParser  */
static	ANTLR_BITWORD FOLLOW_LEFT_BRACKET_in_switchStatement563_bits[]	= { ANTLR_UINT64_LIT(0x0A8408000B910020), ANTLR_UINT64_LIT(0x00000000000000A0) };
static  GeoGenScriptParserImplTraits::BitsetListType FOLLOW_LEFT_BRACKET_in_switchStatement563( FOLLOW_LEFT_BRACKET_in_switchStatement563_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: GeoGenScriptParser  */
static	ANTLR_BITWORD FOLLOW_expression_in_switchStatement565_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000002) };
static  GeoGenScriptParserImplTraits::BitsetListType FOLLOW_expression_in_switchStatement565( FOLLOW_expression_in_switchStatement565_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: GeoGenScriptParser  */
static	ANTLR_BITWORD FOLLOW_RIGHT_BRACKET_in_switchStatement567_bits[]	= { ANTLR_UINT64_LIT(0x0000000001000000) };
static  GeoGenScriptParserImplTraits::BitsetListType FOLLOW_RIGHT_BRACKET_in_switchStatement567( FOLLOW_RIGHT_BRACKET_in_switchStatement567_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: GeoGenScriptParser  */
static	ANTLR_BITWORD FOLLOW_LEFT_CURLY_BRACKET_in_switchStatement569_bits[]	= { ANTLR_UINT64_LIT(0x0000000000001080), ANTLR_UINT64_LIT(0x0000000000000008) };
static  GeoGenScriptParserImplTraits::BitsetListType FOLLOW_LEFT_CURLY_BRACKET_in_switchStatement569( FOLLOW_LEFT_CURLY_BRACKET_in_switchStatement569_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: GeoGenScriptParser  */
static	ANTLR_BITWORD FOLLOW_CASE_in_switchStatement580_bits[]	= { ANTLR_UINT64_LIT(0x0000000008110000), ANTLR_UINT64_LIT(0x00000000000000A0) };
static  GeoGenScriptParserImplTraits::BitsetListType FOLLOW_CASE_in_switchStatement580( FOLLOW_CASE_in_switchStatement580_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: GeoGenScriptParser  */
static	ANTLR_BITWORD FOLLOW_label_in_switchStatement582_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000100) };
static  GeoGenScriptParserImplTraits::BitsetListType FOLLOW_label_in_switchStatement582( FOLLOW_label_in_switchStatement582_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: GeoGenScriptParser  */
static	ANTLR_BITWORD FOLLOW_COLON_in_switchStatement584_bits[]	= { ANTLR_UINT64_LIT(0x0A8408000BB318E0), ANTLR_UINT64_LIT(0x00000000000016F9) };
static  GeoGenScriptParserImplTraits::BitsetListType FOLLOW_COLON_in_switchStatement584( FOLLOW_COLON_in_switchStatement584_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: GeoGenScriptParser  */
static	ANTLR_BITWORD FOLLOW_statement_in_switchStatement586_bits[]	= { ANTLR_UINT64_LIT(0x0A8408000BB318E0), ANTLR_UINT64_LIT(0x00000000000016F9) };
static  GeoGenScriptParserImplTraits::BitsetListType FOLLOW_statement_in_switchStatement586( FOLLOW_statement_in_switchStatement586_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: GeoGenScriptParser  */
static	ANTLR_BITWORD FOLLOW_DEFAULT_in_switchStatement600_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000100) };
static  GeoGenScriptParserImplTraits::BitsetListType FOLLOW_DEFAULT_in_switchStatement600( FOLLOW_DEFAULT_in_switchStatement600_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: GeoGenScriptParser  */
static	ANTLR_BITWORD FOLLOW_COLON_in_switchStatement602_bits[]	= { ANTLR_UINT64_LIT(0x0A8408000BB30860), ANTLR_UINT64_LIT(0x00000000000016F9) };
static  GeoGenScriptParserImplTraits::BitsetListType FOLLOW_COLON_in_switchStatement602( FOLLOW_COLON_in_switchStatement602_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: GeoGenScriptParser  */
static	ANTLR_BITWORD FOLLOW_statement_in_switchStatement605_bits[]	= { ANTLR_UINT64_LIT(0x0A8408000BB30860), ANTLR_UINT64_LIT(0x00000000000016F9) };
static  GeoGenScriptParserImplTraits::BitsetListType FOLLOW_statement_in_switchStatement605( FOLLOW_statement_in_switchStatement605_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: GeoGenScriptParser  */
static	ANTLR_BITWORD FOLLOW_RIGTH_CURLY_BRACKET_in_switchStatement615_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  GeoGenScriptParserImplTraits::BitsetListType FOLLOW_RIGTH_CURLY_BRACKET_in_switchStatement615( FOLLOW_RIGTH_CURLY_BRACKET_in_switchStatement615_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: GeoGenScriptParser  */
static	ANTLR_BITWORD FOLLOW_prio14Expression_in_expression631_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  GeoGenScriptParserImplTraits::BitsetListType FOLLOW_prio14Expression_in_expression631( FOLLOW_prio14Expression_in_expression631_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: GeoGenScriptParser  */
static	ANTLR_BITWORD FOLLOW_prio13Expression_in_prio14Expression685_bits[]	= { ANTLR_UINT64_LIT(0x000800F7E0000002) };
static  GeoGenScriptParserImplTraits::BitsetListType FOLLOW_prio13Expression_in_prio14Expression685( FOLLOW_prio13Expression_in_prio14Expression685_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: GeoGenScriptParser  */
static	ANTLR_BITWORD FOLLOW_prio14Operator_in_prio14Expression688_bits[]	= { ANTLR_UINT64_LIT(0x0A8408000B910020), ANTLR_UINT64_LIT(0x00000000000000A0) };
static  GeoGenScriptParserImplTraits::BitsetListType FOLLOW_prio14Operator_in_prio14Expression688( FOLLOW_prio14Operator_in_prio14Expression688_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: GeoGenScriptParser  */
static	ANTLR_BITWORD FOLLOW_prio13Expression_in_prio14Expression690_bits[]	= { ANTLR_UINT64_LIT(0x000800F7E0000002) };
static  GeoGenScriptParserImplTraits::BitsetListType FOLLOW_prio13Expression_in_prio14Expression690( FOLLOW_prio13Expression_in_prio14Expression690_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: GeoGenScriptParser  */
static	ANTLR_BITWORD FOLLOW_prio12Expression_in_prio13Expression700_bits[]	= { ANTLR_UINT64_LIT(0x0000800000000002) };
static  GeoGenScriptParserImplTraits::BitsetListType FOLLOW_prio12Expression_in_prio13Expression700( FOLLOW_prio12Expression_in_prio13Expression700_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: GeoGenScriptParser  */
static	ANTLR_BITWORD FOLLOW_OPERATOR_EXPR_IF_in_prio13Expression703_bits[]	= { ANTLR_UINT64_LIT(0x0A8408000B910020), ANTLR_UINT64_LIT(0x00000000000000A0) };
static  GeoGenScriptParserImplTraits::BitsetListType FOLLOW_OPERATOR_EXPR_IF_in_prio13Expression703( FOLLOW_OPERATOR_EXPR_IF_in_prio13Expression703_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: GeoGenScriptParser  */
static	ANTLR_BITWORD FOLLOW_prio12Expression_in_prio13Expression705_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000100) };
static  GeoGenScriptParserImplTraits::BitsetListType FOLLOW_prio12Expression_in_prio13Expression705( FOLLOW_prio12Expression_in_prio13Expression705_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: GeoGenScriptParser  */
static	ANTLR_BITWORD FOLLOW_COLON_in_prio13Expression707_bits[]	= { ANTLR_UINT64_LIT(0x0A8408000B910020), ANTLR_UINT64_LIT(0x00000000000000A0) };
static  GeoGenScriptParserImplTraits::BitsetListType FOLLOW_COLON_in_prio13Expression707( FOLLOW_COLON_in_prio13Expression707_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: GeoGenScriptParser  */
static	ANTLR_BITWORD FOLLOW_prio12Expression_in_prio13Expression709_bits[]	= { ANTLR_UINT64_LIT(0x0000800000000002) };
static  GeoGenScriptParserImplTraits::BitsetListType FOLLOW_prio12Expression_in_prio13Expression709( FOLLOW_prio12Expression_in_prio13Expression709_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: GeoGenScriptParser  */
static	ANTLR_BITWORD FOLLOW_OPERATOR_REL_OR_in_prio12Operator718_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  GeoGenScriptParserImplTraits::BitsetListType FOLLOW_OPERATOR_REL_OR_in_prio12Operator718( FOLLOW_OPERATOR_REL_OR_in_prio12Operator718_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: GeoGenScriptParser  */
static	ANTLR_BITWORD FOLLOW_prio11Expression_in_prio12Expression724_bits[]	= { ANTLR_UINT64_LIT(0x2000000000000002) };
static  GeoGenScriptParserImplTraits::BitsetListType FOLLOW_prio11Expression_in_prio12Expression724( FOLLOW_prio11Expression_in_prio12Expression724_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: GeoGenScriptParser  */
static	ANTLR_BITWORD FOLLOW_prio12Operator_in_prio12Expression727_bits[]	= { ANTLR_UINT64_LIT(0x0A8408000B910020), ANTLR_UINT64_LIT(0x00000000000000A0) };
static  GeoGenScriptParserImplTraits::BitsetListType FOLLOW_prio12Operator_in_prio12Expression727( FOLLOW_prio12Operator_in_prio12Expression727_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: GeoGenScriptParser  */
static	ANTLR_BITWORD FOLLOW_prio11Expression_in_prio12Expression729_bits[]	= { ANTLR_UINT64_LIT(0x2000000000000002) };
static  GeoGenScriptParserImplTraits::BitsetListType FOLLOW_prio11Expression_in_prio12Expression729( FOLLOW_prio11Expression_in_prio12Expression729_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: GeoGenScriptParser  */
static	ANTLR_BITWORD FOLLOW_OPERATOR_REL_AND_in_prio11Operator738_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  GeoGenScriptParserImplTraits::BitsetListType FOLLOW_OPERATOR_REL_AND_in_prio11Operator738( FOLLOW_OPERATOR_REL_AND_in_prio11Operator738_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: GeoGenScriptParser  */
static	ANTLR_BITWORD FOLLOW_prio10Expression_in_prio11Expression744_bits[]	= { ANTLR_UINT64_LIT(0x1000000000000002) };
static  GeoGenScriptParserImplTraits::BitsetListType FOLLOW_prio10Expression_in_prio11Expression744( FOLLOW_prio10Expression_in_prio11Expression744_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: GeoGenScriptParser  */
static	ANTLR_BITWORD FOLLOW_prio11Operator_in_prio11Expression747_bits[]	= { ANTLR_UINT64_LIT(0x0A8408000B910020), ANTLR_UINT64_LIT(0x00000000000000A0) };
static  GeoGenScriptParserImplTraits::BitsetListType FOLLOW_prio11Operator_in_prio11Expression747( FOLLOW_prio11Operator_in_prio11Expression747_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: GeoGenScriptParser  */
static	ANTLR_BITWORD FOLLOW_prio10Expression_in_prio11Expression749_bits[]	= { ANTLR_UINT64_LIT(0x1000000000000002) };
static  GeoGenScriptParserImplTraits::BitsetListType FOLLOW_prio10Expression_in_prio11Expression749( FOLLOW_prio10Expression_in_prio11Expression749_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: GeoGenScriptParser  */
static	ANTLR_BITWORD FOLLOW_OPERATOR_BIT_OR_in_prio10Operator758_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  GeoGenScriptParserImplTraits::BitsetListType FOLLOW_OPERATOR_BIT_OR_in_prio10Operator758( FOLLOW_OPERATOR_BIT_OR_in_prio10Operator758_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: GeoGenScriptParser  */
static	ANTLR_BITWORD FOLLOW_prio9Expression_in_prio10Expression764_bits[]	= { ANTLR_UINT64_LIT(0x0000020000000002) };
static  GeoGenScriptParserImplTraits::BitsetListType FOLLOW_prio9Expression_in_prio10Expression764( FOLLOW_prio9Expression_in_prio10Expression764_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: GeoGenScriptParser  */
static	ANTLR_BITWORD FOLLOW_prio10Operator_in_prio10Expression767_bits[]	= { ANTLR_UINT64_LIT(0x0A8408000B910020), ANTLR_UINT64_LIT(0x00000000000000A0) };
static  GeoGenScriptParserImplTraits::BitsetListType FOLLOW_prio10Operator_in_prio10Expression767( FOLLOW_prio10Operator_in_prio10Expression767_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: GeoGenScriptParser  */
static	ANTLR_BITWORD FOLLOW_prio9Expression_in_prio10Expression769_bits[]	= { ANTLR_UINT64_LIT(0x0000020000000002) };
static  GeoGenScriptParserImplTraits::BitsetListType FOLLOW_prio9Expression_in_prio10Expression769( FOLLOW_prio9Expression_in_prio10Expression769_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: GeoGenScriptParser  */
static	ANTLR_BITWORD FOLLOW_OPERATOR_BIT_XOR_in_prio9Operator778_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  GeoGenScriptParserImplTraits::BitsetListType FOLLOW_OPERATOR_BIT_XOR_in_prio9Operator778( FOLLOW_OPERATOR_BIT_XOR_in_prio9Operator778_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: GeoGenScriptParser  */
static	ANTLR_BITWORD FOLLOW_prio8Expression_in_prio9Expression784_bits[]	= { ANTLR_UINT64_LIT(0x0000040000000002) };
static  GeoGenScriptParserImplTraits::BitsetListType FOLLOW_prio8Expression_in_prio9Expression784( FOLLOW_prio8Expression_in_prio9Expression784_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: GeoGenScriptParser  */
static	ANTLR_BITWORD FOLLOW_prio9Operator_in_prio9Expression787_bits[]	= { ANTLR_UINT64_LIT(0x0A8408000B910020), ANTLR_UINT64_LIT(0x00000000000000A0) };
static  GeoGenScriptParserImplTraits::BitsetListType FOLLOW_prio9Operator_in_prio9Expression787( FOLLOW_prio9Operator_in_prio9Expression787_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: GeoGenScriptParser  */
static	ANTLR_BITWORD FOLLOW_prio8Expression_in_prio9Expression789_bits[]	= { ANTLR_UINT64_LIT(0x0000040000000002) };
static  GeoGenScriptParserImplTraits::BitsetListType FOLLOW_prio8Expression_in_prio9Expression789( FOLLOW_prio8Expression_in_prio9Expression789_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: GeoGenScriptParser  */
static	ANTLR_BITWORD FOLLOW_OPERATOR_BIT_AND_in_prio8Operator798_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  GeoGenScriptParserImplTraits::BitsetListType FOLLOW_OPERATOR_BIT_AND_in_prio8Operator798( FOLLOW_OPERATOR_BIT_AND_in_prio8Operator798_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: GeoGenScriptParser  */
static	ANTLR_BITWORD FOLLOW_prio7Expression_in_prio8Expression804_bits[]	= { ANTLR_UINT64_LIT(0x0000010000000002) };
static  GeoGenScriptParserImplTraits::BitsetListType FOLLOW_prio7Expression_in_prio8Expression804( FOLLOW_prio7Expression_in_prio8Expression804_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: GeoGenScriptParser  */
static	ANTLR_BITWORD FOLLOW_prio8Operator_in_prio8Expression807_bits[]	= { ANTLR_UINT64_LIT(0x0A8408000B910020), ANTLR_UINT64_LIT(0x00000000000000A0) };
static  GeoGenScriptParserImplTraits::BitsetListType FOLLOW_prio8Operator_in_prio8Expression807( FOLLOW_prio8Operator_in_prio8Expression807_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: GeoGenScriptParser  */
static	ANTLR_BITWORD FOLLOW_prio7Expression_in_prio8Expression809_bits[]	= { ANTLR_UINT64_LIT(0x0000010000000002) };
static  GeoGenScriptParserImplTraits::BitsetListType FOLLOW_prio7Expression_in_prio8Expression809( FOLLOW_prio7Expression_in_prio8Expression809_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: GeoGenScriptParser  */
static	ANTLR_BITWORD FOLLOW_prio6Expression_in_prio7Expression828_bits[]	= { ANTLR_UINT64_LIT(0x0400400000000002) };
static  GeoGenScriptParserImplTraits::BitsetListType FOLLOW_prio6Expression_in_prio7Expression828( FOLLOW_prio6Expression_in_prio7Expression828_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: GeoGenScriptParser  */
static	ANTLR_BITWORD FOLLOW_prio7Operator_in_prio7Expression831_bits[]	= { ANTLR_UINT64_LIT(0x0A8408000B910020), ANTLR_UINT64_LIT(0x00000000000000A0) };
static  GeoGenScriptParserImplTraits::BitsetListType FOLLOW_prio7Operator_in_prio7Expression831( FOLLOW_prio7Operator_in_prio7Expression831_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: GeoGenScriptParser  */
static	ANTLR_BITWORD FOLLOW_prio6Expression_in_prio7Expression833_bits[]	= { ANTLR_UINT64_LIT(0x0400400000000002) };
static  GeoGenScriptParserImplTraits::BitsetListType FOLLOW_prio6Expression_in_prio7Expression833( FOLLOW_prio6Expression_in_prio7Expression833_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: GeoGenScriptParser  */
static	ANTLR_BITWORD FOLLOW_prio5Expression_in_prio6Expression860_bits[]	= { ANTLR_UINT64_LIT(0x0033000000000002) };
static  GeoGenScriptParserImplTraits::BitsetListType FOLLOW_prio5Expression_in_prio6Expression860( FOLLOW_prio5Expression_in_prio6Expression860_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: GeoGenScriptParser  */
static	ANTLR_BITWORD FOLLOW_prio6Operator_in_prio6Expression863_bits[]	= { ANTLR_UINT64_LIT(0x0A8408000B910020), ANTLR_UINT64_LIT(0x00000000000000A0) };
static  GeoGenScriptParserImplTraits::BitsetListType FOLLOW_prio6Operator_in_prio6Expression863( FOLLOW_prio6Operator_in_prio6Expression863_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: GeoGenScriptParser  */
static	ANTLR_BITWORD FOLLOW_prio5Expression_in_prio6Expression865_bits[]	= { ANTLR_UINT64_LIT(0x0033000000000002) };
static  GeoGenScriptParserImplTraits::BitsetListType FOLLOW_prio5Expression_in_prio6Expression865( FOLLOW_prio5Expression_in_prio6Expression865_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: GeoGenScriptParser  */
static	ANTLR_BITWORD FOLLOW_prio4Expression_in_prio5Expression884_bits[]	= { ANTLR_UINT64_LIT(0x4040000000000002) };
static  GeoGenScriptParserImplTraits::BitsetListType FOLLOW_prio4Expression_in_prio5Expression884( FOLLOW_prio4Expression_in_prio5Expression884_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: GeoGenScriptParser  */
static	ANTLR_BITWORD FOLLOW_prio5Operator_in_prio5Expression887_bits[]	= { ANTLR_UINT64_LIT(0x0A8408000B910020), ANTLR_UINT64_LIT(0x00000000000000A0) };
static  GeoGenScriptParserImplTraits::BitsetListType FOLLOW_prio5Operator_in_prio5Expression887( FOLLOW_prio5Operator_in_prio5Expression887_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: GeoGenScriptParser  */
static	ANTLR_BITWORD FOLLOW_prio4Expression_in_prio5Expression889_bits[]	= { ANTLR_UINT64_LIT(0x4040000000000002) };
static  GeoGenScriptParserImplTraits::BitsetListType FOLLOW_prio4Expression_in_prio5Expression889( FOLLOW_prio4Expression_in_prio5Expression889_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: GeoGenScriptParser  */
static	ANTLR_BITWORD FOLLOW_prio3Expression_in_prio4Expression908_bits[]	= { ANTLR_UINT64_LIT(0x0880000000000002) };
static  GeoGenScriptParserImplTraits::BitsetListType FOLLOW_prio3Expression_in_prio4Expression908( FOLLOW_prio3Expression_in_prio4Expression908_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: GeoGenScriptParser  */
static	ANTLR_BITWORD FOLLOW_prio4Operator_in_prio4Expression911_bits[]	= { ANTLR_UINT64_LIT(0x0A8408000B910020), ANTLR_UINT64_LIT(0x00000000000000A0) };
static  GeoGenScriptParserImplTraits::BitsetListType FOLLOW_prio4Operator_in_prio4Expression911( FOLLOW_prio4Operator_in_prio4Expression911_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: GeoGenScriptParser  */
static	ANTLR_BITWORD FOLLOW_prio3Expression_in_prio4Expression913_bits[]	= { ANTLR_UINT64_LIT(0x0880000000000002) };
static  GeoGenScriptParserImplTraits::BitsetListType FOLLOW_prio3Expression_in_prio4Expression913( FOLLOW_prio3Expression_in_prio4Expression913_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: GeoGenScriptParser  */
static	ANTLR_BITWORD FOLLOW_prio2Expression_in_prio3Expression936_bits[]	= { ANTLR_UINT64_LIT(0x8100100000000002) };
static  GeoGenScriptParserImplTraits::BitsetListType FOLLOW_prio2Expression_in_prio3Expression936( FOLLOW_prio2Expression_in_prio3Expression936_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: GeoGenScriptParser  */
static	ANTLR_BITWORD FOLLOW_prio3Operator_in_prio3Expression939_bits[]	= { ANTLR_UINT64_LIT(0x0A8408000B910020), ANTLR_UINT64_LIT(0x00000000000000A0) };
static  GeoGenScriptParserImplTraits::BitsetListType FOLLOW_prio3Operator_in_prio3Expression939( FOLLOW_prio3Operator_in_prio3Expression939_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: GeoGenScriptParser  */
static	ANTLR_BITWORD FOLLOW_prio2Expression_in_prio3Expression941_bits[]	= { ANTLR_UINT64_LIT(0x8100100000000002) };
static  GeoGenScriptParserImplTraits::BitsetListType FOLLOW_prio2Expression_in_prio3Expression941( FOLLOW_prio2Expression_in_prio3Expression941_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: GeoGenScriptParser  */
static	ANTLR_BITWORD FOLLOW_prio2PrefixOperator_in_prio2Expression982_bits[]	= { ANTLR_UINT64_LIT(0x0A8408000B910020), ANTLR_UINT64_LIT(0x00000000000000A0) };
static  GeoGenScriptParserImplTraits::BitsetListType FOLLOW_prio2PrefixOperator_in_prio2Expression982( FOLLOW_prio2PrefixOperator_in_prio2Expression982_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: GeoGenScriptParser  */
static	ANTLR_BITWORD FOLLOW_prio1Expression_in_prio2Expression985_bits[]	= { ANTLR_UINT64_LIT(0x0004080000000002) };
static  GeoGenScriptParserImplTraits::BitsetListType FOLLOW_prio1Expression_in_prio2Expression985( FOLLOW_prio1Expression_in_prio2Expression985_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: GeoGenScriptParser  */
static	ANTLR_BITWORD FOLLOW_prio2PostfixOperator_in_prio2Expression987_bits[]	= { ANTLR_UINT64_LIT(0x0004080000000002) };
static  GeoGenScriptParserImplTraits::BitsetListType FOLLOW_prio2PostfixOperator_in_prio2Expression987( FOLLOW_prio2PostfixOperator_in_prio2Expression987_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: GeoGenScriptParser  */
static	ANTLR_BITWORD FOLLOW_prio0Expression_in_prio1Expression1002_bits[]	= { ANTLR_UINT64_LIT(0x0000200002800002) };
static  GeoGenScriptParserImplTraits::BitsetListType FOLLOW_prio0Expression_in_prio1Expression1002( FOLLOW_prio0Expression_in_prio1Expression1002_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: GeoGenScriptParser  */
static	ANTLR_BITWORD FOLLOW_OPERATOR_DOT_in_prio1Expression1014_bits[]	= { ANTLR_UINT64_LIT(0x000000000B910020), ANTLR_UINT64_LIT(0x00000000000000A0) };
static  GeoGenScriptParserImplTraits::BitsetListType FOLLOW_OPERATOR_DOT_in_prio1Expression1014( FOLLOW_OPERATOR_DOT_in_prio1Expression1014_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: GeoGenScriptParser  */
static	ANTLR_BITWORD FOLLOW_prio0Expression_in_prio1Expression1016_bits[]	= { ANTLR_UINT64_LIT(0x0000200002800002) };
static  GeoGenScriptParserImplTraits::BitsetListType FOLLOW_prio0Expression_in_prio1Expression1016( FOLLOW_prio0Expression_in_prio1Expression1016_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: GeoGenScriptParser  */
static	ANTLR_BITWORD FOLLOW_LEFT_BRACKET_in_prio1Expression1028_bits[]	= { ANTLR_UINT64_LIT(0x0A8408000B910020), ANTLR_UINT64_LIT(0x00000000000000A2) };
static  GeoGenScriptParserImplTraits::BitsetListType FOLLOW_LEFT_BRACKET_in_prio1Expression1028( FOLLOW_LEFT_BRACKET_in_prio1Expression1028_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: GeoGenScriptParser  */
static	ANTLR_BITWORD FOLLOW_expression_in_prio1Expression1031_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000200), ANTLR_UINT64_LIT(0x0000000000000002) };
static  GeoGenScriptParserImplTraits::BitsetListType FOLLOW_expression_in_prio1Expression1031( FOLLOW_expression_in_prio1Expression1031_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: GeoGenScriptParser  */
static	ANTLR_BITWORD FOLLOW_COMMA_in_prio1Expression1034_bits[]	= { ANTLR_UINT64_LIT(0x0A8408000B910020), ANTLR_UINT64_LIT(0x00000000000000A0) };
static  GeoGenScriptParserImplTraits::BitsetListType FOLLOW_COMMA_in_prio1Expression1034( FOLLOW_COMMA_in_prio1Expression1034_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: GeoGenScriptParser  */
static	ANTLR_BITWORD FOLLOW_expression_in_prio1Expression1036_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000200), ANTLR_UINT64_LIT(0x0000000000000002) };
static  GeoGenScriptParserImplTraits::BitsetListType FOLLOW_expression_in_prio1Expression1036( FOLLOW_expression_in_prio1Expression1036_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: GeoGenScriptParser  */
static	ANTLR_BITWORD FOLLOW_RIGHT_BRACKET_in_prio1Expression1042_bits[]	= { ANTLR_UINT64_LIT(0x0000200002800002) };
static  GeoGenScriptParserImplTraits::BitsetListType FOLLOW_RIGHT_BRACKET_in_prio1Expression1042( FOLLOW_RIGHT_BRACKET_in_prio1Expression1042_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: GeoGenScriptParser  */
static	ANTLR_BITWORD FOLLOW_LEFT_SQUARE_BRACKET_in_prio1Expression1054_bits[]	= { ANTLR_UINT64_LIT(0x0A8408000B910020), ANTLR_UINT64_LIT(0x00000000000000A0) };
static  GeoGenScriptParserImplTraits::BitsetListType FOLLOW_LEFT_SQUARE_BRACKET_in_prio1Expression1054( FOLLOW_LEFT_SQUARE_BRACKET_in_prio1Expression1054_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: GeoGenScriptParser  */
static	ANTLR_BITWORD FOLLOW_expression_in_prio1Expression1056_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000200), ANTLR_UINT64_LIT(0x0000000000000004) };
static  GeoGenScriptParserImplTraits::BitsetListType FOLLOW_expression_in_prio1Expression1056( FOLLOW_expression_in_prio1Expression1056_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: GeoGenScriptParser  */
static	ANTLR_BITWORD FOLLOW_COMMA_in_prio1Expression1059_bits[]	= { ANTLR_UINT64_LIT(0x0A8408000B910020), ANTLR_UINT64_LIT(0x00000000000000A0) };
static  GeoGenScriptParserImplTraits::BitsetListType FOLLOW_COMMA_in_prio1Expression1059( FOLLOW_COMMA_in_prio1Expression1059_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: GeoGenScriptParser  */
static	ANTLR_BITWORD FOLLOW_expression_in_prio1Expression1061_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000200), ANTLR_UINT64_LIT(0x0000000000000004) };
static  GeoGenScriptParserImplTraits::BitsetListType FOLLOW_expression_in_prio1Expression1061( FOLLOW_expression_in_prio1Expression1061_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: GeoGenScriptParser  */
static	ANTLR_BITWORD FOLLOW_RIGHT_SQUARE_BRACKET_in_prio1Expression1065_bits[]	= { ANTLR_UINT64_LIT(0x0000200002800002) };
static  GeoGenScriptParserImplTraits::BitsetListType FOLLOW_RIGHT_SQUARE_BRACKET_in_prio1Expression1065( FOLLOW_RIGHT_SQUARE_BRACKET_in_prio1Expression1065_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: GeoGenScriptParser  */
static	ANTLR_BITWORD FOLLOW_IDENTIFIER_in_prio0Expression1084_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  GeoGenScriptParserImplTraits::BitsetListType FOLLOW_IDENTIFIER_in_prio0Expression1084( FOLLOW_IDENTIFIER_in_prio0Expression1084_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: GeoGenScriptParser  */
static	ANTLR_BITWORD FOLLOW_collectionLiteral_in_prio0Expression1092_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  GeoGenScriptParserImplTraits::BitsetListType FOLLOW_collectionLiteral_in_prio0Expression1092( FOLLOW_collectionLiteral_in_prio0Expression1092_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: GeoGenScriptParser  */
static	ANTLR_BITWORD FOLLOW_coordinateLiteral_in_prio0Expression1100_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  GeoGenScriptParserImplTraits::BitsetListType FOLLOW_coordinateLiteral_in_prio0Expression1100( FOLLOW_coordinateLiteral_in_prio0Expression1100_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: GeoGenScriptParser  */
static	ANTLR_BITWORD FOLLOW_literal_in_prio0Expression1108_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  GeoGenScriptParserImplTraits::BitsetListType FOLLOW_literal_in_prio0Expression1108( FOLLOW_literal_in_prio0Expression1108_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: GeoGenScriptParser  */
static	ANTLR_BITWORD FOLLOW_LEFT_BRACKET_in_prio0Expression1116_bits[]	= { ANTLR_UINT64_LIT(0x0A8408000B910020), ANTLR_UINT64_LIT(0x00000000000000A0) };
static  GeoGenScriptParserImplTraits::BitsetListType FOLLOW_LEFT_BRACKET_in_prio0Expression1116( FOLLOW_LEFT_BRACKET_in_prio0Expression1116_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: GeoGenScriptParser  */
static	ANTLR_BITWORD FOLLOW_expression_in_prio0Expression1118_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000002) };
static  GeoGenScriptParserImplTraits::BitsetListType FOLLOW_expression_in_prio0Expression1118( FOLLOW_expression_in_prio0Expression1118_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: GeoGenScriptParser  */
static	ANTLR_BITWORD FOLLOW_RIGHT_BRACKET_in_prio0Expression1120_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  GeoGenScriptParserImplTraits::BitsetListType FOLLOW_RIGHT_BRACKET_in_prio0Expression1120( FOLLOW_RIGHT_BRACKET_in_prio0Expression1120_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: GeoGenScriptParser  */
static	ANTLR_BITWORD FOLLOW_keyValueCollection_in_collectionLiteral1133_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  GeoGenScriptParserImplTraits::BitsetListType FOLLOW_keyValueCollection_in_collectionLiteral1133( FOLLOW_keyValueCollection_in_collectionLiteral1133_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: GeoGenScriptParser  */
static	ANTLR_BITWORD FOLLOW_unkeyedCollectionLiteral_in_collectionLiteral1141_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  GeoGenScriptParserImplTraits::BitsetListType FOLLOW_unkeyedCollectionLiteral_in_collectionLiteral1141( FOLLOW_unkeyedCollectionLiteral_in_collectionLiteral1141_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: GeoGenScriptParser  */
static	ANTLR_BITWORD FOLLOW_LEFT_CURLY_BRACKET_in_unkeyedCollectionLiteral1152_bits[]	= { ANTLR_UINT64_LIT(0x0A8408000B910020), ANTLR_UINT64_LIT(0x00000000000000A0) };
static  GeoGenScriptParserImplTraits::BitsetListType FOLLOW_LEFT_CURLY_BRACKET_in_unkeyedCollectionLiteral1152( FOLLOW_LEFT_CURLY_BRACKET_in_unkeyedCollectionLiteral1152_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: GeoGenScriptParser  */
static	ANTLR_BITWORD FOLLOW_expression_in_unkeyedCollectionLiteral1155_bits[]	= { ANTLR_UINT64_LIT(0x0A8408000B910220), ANTLR_UINT64_LIT(0x00000000000000A8) };
static  GeoGenScriptParserImplTraits::BitsetListType FOLLOW_expression_in_unkeyedCollectionLiteral1155( FOLLOW_expression_in_unkeyedCollectionLiteral1155_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: GeoGenScriptParser  */
static	ANTLR_BITWORD FOLLOW_COMMA_in_unkeyedCollectionLiteral1160_bits[]	= { ANTLR_UINT64_LIT(0x0A8408000B910020), ANTLR_UINT64_LIT(0x00000000000000A0) };
static  GeoGenScriptParserImplTraits::BitsetListType FOLLOW_COMMA_in_unkeyedCollectionLiteral1160( FOLLOW_COMMA_in_unkeyedCollectionLiteral1160_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: GeoGenScriptParser  */
static	ANTLR_BITWORD FOLLOW_expression_in_unkeyedCollectionLiteral1162_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000200), ANTLR_UINT64_LIT(0x0000000000000008) };
static  GeoGenScriptParserImplTraits::BitsetListType FOLLOW_expression_in_unkeyedCollectionLiteral1162( FOLLOW_expression_in_unkeyedCollectionLiteral1162_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: GeoGenScriptParser  */
static	ANTLR_BITWORD FOLLOW_RIGTH_CURLY_BRACKET_in_unkeyedCollectionLiteral1167_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  GeoGenScriptParserImplTraits::BitsetListType FOLLOW_RIGTH_CURLY_BRACKET_in_unkeyedCollectionLiteral1167( FOLLOW_RIGTH_CURLY_BRACKET_in_unkeyedCollectionLiteral1167_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: GeoGenScriptParser  */
static	ANTLR_BITWORD FOLLOW_AT_in_coordinateLiteral1178_bits[]	= { ANTLR_UINT64_LIT(0x0000000002000000) };
static  GeoGenScriptParserImplTraits::BitsetListType FOLLOW_AT_in_coordinateLiteral1178( FOLLOW_AT_in_coordinateLiteral1178_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: GeoGenScriptParser  */
static	ANTLR_BITWORD FOLLOW_LEFT_SQUARE_BRACKET_in_coordinateLiteral1181_bits[]	= { ANTLR_UINT64_LIT(0x0A8408000B910020), ANTLR_UINT64_LIT(0x00000000000000A0) };
static  GeoGenScriptParserImplTraits::BitsetListType FOLLOW_LEFT_SQUARE_BRACKET_in_coordinateLiteral1181( FOLLOW_LEFT_SQUARE_BRACKET_in_coordinateLiteral1181_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: GeoGenScriptParser  */
static	ANTLR_BITWORD FOLLOW_expression_in_coordinateLiteral1183_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000200), ANTLR_UINT64_LIT(0x0000000000000004) };
static  GeoGenScriptParserImplTraits::BitsetListType FOLLOW_expression_in_coordinateLiteral1183( FOLLOW_expression_in_coordinateLiteral1183_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: GeoGenScriptParser  */
static	ANTLR_BITWORD FOLLOW_COMMA_in_coordinateLiteral1186_bits[]	= { ANTLR_UINT64_LIT(0x0A8408000B910020), ANTLR_UINT64_LIT(0x00000000000000A0) };
static  GeoGenScriptParserImplTraits::BitsetListType FOLLOW_COMMA_in_coordinateLiteral1186( FOLLOW_COMMA_in_coordinateLiteral1186_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: GeoGenScriptParser  */
static	ANTLR_BITWORD FOLLOW_expression_in_coordinateLiteral1188_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000200), ANTLR_UINT64_LIT(0x0000000000000004) };
static  GeoGenScriptParserImplTraits::BitsetListType FOLLOW_expression_in_coordinateLiteral1188( FOLLOW_expression_in_coordinateLiteral1188_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: GeoGenScriptParser  */
static	ANTLR_BITWORD FOLLOW_RIGHT_SQUARE_BRACKET_in_coordinateLiteral1192_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  GeoGenScriptParserImplTraits::BitsetListType FOLLOW_RIGHT_SQUARE_BRACKET_in_coordinateLiteral1192( FOLLOW_RIGHT_SQUARE_BRACKET_in_coordinateLiteral1192_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: GeoGenScriptParser  */
static	ANTLR_BITWORD FOLLOW_IDENTIFIER_in_label1208_bits[]	= { ANTLR_UINT64_LIT(0x0000200000000002) };
static  GeoGenScriptParserImplTraits::BitsetListType FOLLOW_IDENTIFIER_in_label1208( FOLLOW_IDENTIFIER_in_label1208_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: GeoGenScriptParser  */
static	ANTLR_BITWORD FOLLOW_OPERATOR_DOT_in_label1211_bits[]	= { ANTLR_UINT64_LIT(0x0000000000100000) };
static  GeoGenScriptParserImplTraits::BitsetListType FOLLOW_OPERATOR_DOT_in_label1211( FOLLOW_OPERATOR_DOT_in_label1211_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: GeoGenScriptParser  */
static	ANTLR_BITWORD FOLLOW_IDENTIFIER_in_label1213_bits[]	= { ANTLR_UINT64_LIT(0x0000200000000002) };
static  GeoGenScriptParserImplTraits::BitsetListType FOLLOW_IDENTIFIER_in_label1213( FOLLOW_IDENTIFIER_in_label1213_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: GeoGenScriptParser  */
static	ANTLR_BITWORD FOLLOW_literal_in_label1220_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  GeoGenScriptParserImplTraits::BitsetListType FOLLOW_literal_in_label1220( FOLLOW_literal_in_label1220_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: GeoGenScriptParser  */
static	ANTLR_BITWORD FOLLOW_declaration_in_synpred1_GeoGenScript80_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  GeoGenScriptParserImplTraits::BitsetListType FOLLOW_declaration_in_synpred1_GeoGenScript80( FOLLOW_declaration_in_synpred1_GeoGenScript80_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: GeoGenScriptParser  */
static	ANTLR_BITWORD FOLLOW_expression_in_synpred9_GeoGenScript164_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  GeoGenScriptParserImplTraits::BitsetListType FOLLOW_expression_in_synpred9_GeoGenScript164( FOLLOW_expression_in_synpred9_GeoGenScript164_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: GeoGenScriptParser  */
static	ANTLR_BITWORD FOLLOW_expression_in_synpred20_GeoGenScript319_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000010) };
static  GeoGenScriptParserImplTraits::BitsetListType FOLLOW_expression_in_synpred20_GeoGenScript319( FOLLOW_expression_in_synpred20_GeoGenScript319_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: GeoGenScriptParser  */
static	ANTLR_BITWORD FOLLOW_SEMICOLON_in_synpred20_GeoGenScript321_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  GeoGenScriptParserImplTraits::BitsetListType FOLLOW_SEMICOLON_in_synpred20_GeoGenScript321( FOLLOW_SEMICOLON_in_synpred20_GeoGenScript321_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: GeoGenScriptParser  */
static	ANTLR_BITWORD FOLLOW_block_in_synpred27_GeoGenScript385_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  GeoGenScriptParserImplTraits::BitsetListType FOLLOW_block_in_synpred27_GeoGenScript385( FOLLOW_block_in_synpred27_GeoGenScript385_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: GeoGenScriptParser  */
static	ANTLR_BITWORD FOLLOW_YIELD_in_synpred29_GeoGenScript425_bits[]	= { ANTLR_UINT64_LIT(0x0A8408000B910020), ANTLR_UINT64_LIT(0x00000000000000A0) };
static  GeoGenScriptParserImplTraits::BitsetListType FOLLOW_YIELD_in_synpred29_GeoGenScript425( FOLLOW_YIELD_in_synpred29_GeoGenScript425_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: GeoGenScriptParser  */
static	ANTLR_BITWORD FOLLOW_expression_in_synpred29_GeoGenScript427_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000010) };
static  GeoGenScriptParserImplTraits::BitsetListType FOLLOW_expression_in_synpred29_GeoGenScript427( FOLLOW_expression_in_synpred29_GeoGenScript427_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: GeoGenScriptParser  */
static	ANTLR_BITWORD FOLLOW_AS_in_synpred29_GeoGenScript429_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000000), ANTLR_UINT64_LIT(0x0000000000000020) };
static  GeoGenScriptParserImplTraits::BitsetListType FOLLOW_AS_in_synpred29_GeoGenScript429( FOLLOW_AS_in_synpred29_GeoGenScript429_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: GeoGenScriptParser  */
static	ANTLR_BITWORD FOLLOW_STRING_in_synpred29_GeoGenScript431_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  GeoGenScriptParserImplTraits::BitsetListType FOLLOW_STRING_in_synpred29_GeoGenScript431( FOLLOW_STRING_in_synpred29_GeoGenScript431_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: GeoGenScriptParser  */
static	ANTLR_BITWORD FOLLOW_ELSE_in_synpred34_GeoGenScript545_bits[]	= { ANTLR_UINT64_LIT(0x0A8408000BB30860), ANTLR_UINT64_LIT(0x00000000000016F1) };
static  GeoGenScriptParserImplTraits::BitsetListType FOLLOW_ELSE_in_synpred34_GeoGenScript545( FOLLOW_ELSE_in_synpred34_GeoGenScript545_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: GeoGenScriptParser  */
static	ANTLR_BITWORD FOLLOW_statement_in_synpred34_GeoGenScript547_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  GeoGenScriptParserImplTraits::BitsetListType FOLLOW_statement_in_synpred34_GeoGenScript547( FOLLOW_statement_in_synpred34_GeoGenScript547_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: GeoGenScriptParser  */
static	ANTLR_BITWORD FOLLOW_prio4Operator_in_synpred65_GeoGenScript911_bits[]	= { ANTLR_UINT64_LIT(0x0A8408000B910020), ANTLR_UINT64_LIT(0x00000000000000A0) };
static  GeoGenScriptParserImplTraits::BitsetListType FOLLOW_prio4Operator_in_synpred65_GeoGenScript911( FOLLOW_prio4Operator_in_synpred65_GeoGenScript911_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: GeoGenScriptParser  */
static	ANTLR_BITWORD FOLLOW_prio3Expression_in_synpred65_GeoGenScript913_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  GeoGenScriptParserImplTraits::BitsetListType FOLLOW_prio3Expression_in_synpred65_GeoGenScript913( FOLLOW_prio3Expression_in_synpred65_GeoGenScript913_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: GeoGenScriptParser  */
static	ANTLR_BITWORD FOLLOW_prio2PostfixOperator_in_synpred75_GeoGenScript987_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  GeoGenScriptParserImplTraits::BitsetListType FOLLOW_prio2PostfixOperator_in_synpred75_GeoGenScript987( FOLLOW_prio2PostfixOperator_in_synpred75_GeoGenScript987_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: GeoGenScriptParser  */
static	ANTLR_BITWORD FOLLOW_LEFT_BRACKET_in_synpred79_GeoGenScript1028_bits[]	= { ANTLR_UINT64_LIT(0x0A8408000B910020), ANTLR_UINT64_LIT(0x00000000000000A2) };
static  GeoGenScriptParserImplTraits::BitsetListType FOLLOW_LEFT_BRACKET_in_synpred79_GeoGenScript1028( FOLLOW_LEFT_BRACKET_in_synpred79_GeoGenScript1028_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: GeoGenScriptParser  */
static	ANTLR_BITWORD FOLLOW_expression_in_synpred79_GeoGenScript1031_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000200), ANTLR_UINT64_LIT(0x0000000000000002) };
static  GeoGenScriptParserImplTraits::BitsetListType FOLLOW_expression_in_synpred79_GeoGenScript1031( FOLLOW_expression_in_synpred79_GeoGenScript1031_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: GeoGenScriptParser  */
static	ANTLR_BITWORD FOLLOW_COMMA_in_synpred79_GeoGenScript1034_bits[]	= { ANTLR_UINT64_LIT(0x0A8408000B910020), ANTLR_UINT64_LIT(0x00000000000000A0) };
static  GeoGenScriptParserImplTraits::BitsetListType FOLLOW_COMMA_in_synpred79_GeoGenScript1034( FOLLOW_COMMA_in_synpred79_GeoGenScript1034_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: GeoGenScriptParser  */
static	ANTLR_BITWORD FOLLOW_expression_in_synpred79_GeoGenScript1036_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000200), ANTLR_UINT64_LIT(0x0000000000000002) };
static  GeoGenScriptParserImplTraits::BitsetListType FOLLOW_expression_in_synpred79_GeoGenScript1036( FOLLOW_expression_in_synpred79_GeoGenScript1036_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: GeoGenScriptParser  */
static	ANTLR_BITWORD FOLLOW_RIGHT_BRACKET_in_synpred79_GeoGenScript1042_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  GeoGenScriptParserImplTraits::BitsetListType FOLLOW_RIGHT_BRACKET_in_synpred79_GeoGenScript1042( FOLLOW_RIGHT_BRACKET_in_synpred79_GeoGenScript1042_bits, 1 );
/** Bitset defining follow set for error recovery in rule state: GeoGenScriptParser  */
static	ANTLR_BITWORD FOLLOW_LEFT_SQUARE_BRACKET_in_synpred81_GeoGenScript1054_bits[]	= { ANTLR_UINT64_LIT(0x0A8408000B910020), ANTLR_UINT64_LIT(0x00000000000000A0) };
static  GeoGenScriptParserImplTraits::BitsetListType FOLLOW_LEFT_SQUARE_BRACKET_in_synpred81_GeoGenScript1054( FOLLOW_LEFT_SQUARE_BRACKET_in_synpred81_GeoGenScript1054_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: GeoGenScriptParser  */
static	ANTLR_BITWORD FOLLOW_expression_in_synpred81_GeoGenScript1056_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000200), ANTLR_UINT64_LIT(0x0000000000000004) };
static  GeoGenScriptParserImplTraits::BitsetListType FOLLOW_expression_in_synpred81_GeoGenScript1056( FOLLOW_expression_in_synpred81_GeoGenScript1056_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: GeoGenScriptParser  */
static	ANTLR_BITWORD FOLLOW_COMMA_in_synpred81_GeoGenScript1059_bits[]	= { ANTLR_UINT64_LIT(0x0A8408000B910020), ANTLR_UINT64_LIT(0x00000000000000A0) };
static  GeoGenScriptParserImplTraits::BitsetListType FOLLOW_COMMA_in_synpred81_GeoGenScript1059( FOLLOW_COMMA_in_synpred81_GeoGenScript1059_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: GeoGenScriptParser  */
static	ANTLR_BITWORD FOLLOW_expression_in_synpred81_GeoGenScript1061_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000200), ANTLR_UINT64_LIT(0x0000000000000004) };
static  GeoGenScriptParserImplTraits::BitsetListType FOLLOW_expression_in_synpred81_GeoGenScript1061( FOLLOW_expression_in_synpred81_GeoGenScript1061_bits, 2 );
/** Bitset defining follow set for error recovery in rule state: GeoGenScriptParser  */
static	ANTLR_BITWORD FOLLOW_RIGHT_SQUARE_BRACKET_in_synpred81_GeoGenScript1065_bits[]	= { ANTLR_UINT64_LIT(0x0000000000000002) };
static  GeoGenScriptParserImplTraits::BitsetListType FOLLOW_RIGHT_SQUARE_BRACKET_in_synpred81_GeoGenScript1065( FOLLOW_RIGHT_SQUARE_BRACKET_in_synpred81_GeoGenScript1065_bits, 1 );


/* ==============================================
 * Parsing rules
 */
/**
 * $ANTLR start script
 * D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScript.g:66:1: script : ( declaration )* ( metadata )? ( statement | declaration )* ;
 */
void
GeoGenScriptParser::script()
{
        GeoGenScriptParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScript.g:66:7: ( ( declaration )* ( metadata )? ( statement | declaration )* )
        // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScript.g:66:9: ( declaration )* ( metadata )? ( statement | declaration )*
        {
            // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScript.g:66:9: ( declaration )*

            for (;;)
            {
                int alt1=2;
                switch ( this->LA(1) )
                {
                case ENUM:
                	{
                		{
                		   /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
                		    */
                		    int LA1_19 = this->LA(2);
                		    if ( (this->msynpred( antlr3::ClassForwarder<synpred1_GeoGenScript>() )))
                		    {
                		        alt1=1;
                		    }

                		}
                	}
                    break;
                case FUNCTION:
                	{
                		{
                		   /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
                		    */
                		    int LA1_20 = this->LA(2);
                		    if ( (this->msynpred( antlr3::ClassForwarder<synpred1_GeoGenScript>() )))
                		    {
                		        alt1=1;
                		    }

                		}
                	}
                    break;

                }

                switch (alt1)
                {
            	case 1:
            	    // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScript.g:66:9: declaration
            	    {
            	        this->followPush(FOLLOW_declaration_in_script80);
            	        declaration();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulescriptEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

            	default:
            	    goto loop1;	/* break out of the loop */
            	    break;
                }
            }
            loop1: ; /* Jump out to here if this rule does not match */


            // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScript.g:66:22: ( metadata )?
            {
                int alt2=2;
                switch ( this->LA(1) )
                {
                    case METADATA:
                    	{
                    		alt2=1;
                    	}
                        break;
                }

                switch (alt2)
                {
            	case 1:
            	    // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScript.g:66:22: metadata
            	    {
            	        this->followPush(FOLLOW_metadata_in_script83);
            	        metadata();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulescriptEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

            // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScript.g:66:32: ( statement | declaration )*

            for (;;)
            {
                int alt3=3;
                switch ( this->LA(1) )
                {
                case AT:
                case BREAK:
                case CONTINUE:
                case FALSE_LIT:
                case FOR:
                case IDENTIFIER:
                case IF:
                case LEFT_BRACKET:
                case LEFT_CURLY_BRACKET:
                case LEFT_SQUARE_BRACKET:
                case NUMBER:
                case OPERATOR_DECREMENT:
                case OPERATOR_INCREMENT:
                case OPERATOR_MINUS:
                case OPERATOR_NOT:
                case OPERATOR_PLUS:
                case RETURN:
                case SEMICOLON:
                case STRING:
                case SWITCH:
                case TRUE_LIT:
                case VAR:
                case WHILE:
                case YIELD:
                	{
                		alt3=1;
                	}
                    break;
                case ENUM:
                case FUNCTION:
                	{
                		alt3=2;
                	}
                    break;

                }

                switch (alt3)
                {
            	case 1:
            	    // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScript.g:66:33: statement
            	    {
            	        this->followPush(FOLLOW_statement_in_script87);
            	        statement();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulescriptEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;
            	case 2:
            	    // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScript.g:66:45: declaration
            	    {
            	        this->followPush(FOLLOW_declaration_in_script91);
            	        declaration();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulescriptEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

            	default:
            	    goto loop3;	/* break out of the loop */
            	    break;
                }
            }
            loop3: ; /* Jump out to here if this rule does not match */


        }

    }
    // This is where rules clean up and exit
    //
    goto rulescriptEx; /* Prevent compiler warnings */
    rulescriptEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end script */

/**
 * $ANTLR start metadata
 * D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScript.g:68:1: metadata : ( 'metadata' ) keyValueCollection ;
 */
void
GeoGenScriptParser::metadata()
{
        GeoGenScriptParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScript.g:68:9: ( ( 'metadata' ) keyValueCollection )
        // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScript.g:68:11: ( 'metadata' ) keyValueCollection
        {
            // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScript.g:68:11: ( 'metadata' )
            // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScript.g:68:12: 'metadata'
            {
                 this->matchToken(METADATA, &FOLLOW_METADATA_in_metadata109);
                if  (this->hasException())
                {
                    goto rulemetadataEx;
                }
                if (this->hasFailed())
                {
                    return ;
                }


            }


            this->followPush(FOLLOW_keyValueCollection_in_metadata112);
            keyValueCollection();

            this->followPop();
            if  (this->hasException())
            {
                goto rulemetadataEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulemetadataEx; /* Prevent compiler warnings */
    rulemetadataEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end metadata */

/**
 * $ANTLR start keyValueCollection
 * D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScript.g:70:1: keyValueCollection : '{' ( keyValuePair ( ',' keyValuePair )* )? '}' ;
 */
void
GeoGenScriptParser::keyValueCollection()
{
        GeoGenScriptParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScript.g:70:19: ( '{' ( keyValuePair ( ',' keyValuePair )* )? '}' )
        // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScript.g:70:21: '{' ( keyValuePair ( ',' keyValuePair )* )? '}'
        {
             this->matchToken(LEFT_CURLY_BRACKET, &FOLLOW_LEFT_CURLY_BRACKET_in_keyValueCollection119);
            if  (this->hasException())
            {
                goto rulekeyValueCollectionEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScript.g:70:25: ( keyValuePair ( ',' keyValuePair )* )?
            {
                int alt5=2;
                switch ( this->LA(1) )
                {
                    case AT:
                    case IDENTIFIER:
                    case NUMBER:
                    	{
                    		alt5=1;
                    	}
                        break;
                }

                switch (alt5)
                {
            	case 1:
            	    // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScript.g:70:26: keyValuePair ( ',' keyValuePair )*
            	    {
            	        this->followPush(FOLLOW_keyValuePair_in_keyValueCollection122);
            	        keyValuePair();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulekeyValueCollectionEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScript.g:70:39: ( ',' keyValuePair )*

            	        for (;;)
            	        {
            	            int alt4=2;
            	            switch ( this->LA(1) )
            	            {
            	            case COMMA:
            	            	{
            	            		alt4=1;
            	            	}
            	                break;

            	            }

            	            switch (alt4)
            	            {
            	        	case 1:
            	        	    // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScript.g:70:40: ',' keyValuePair
            	        	    {
            	        	         this->matchToken(COMMA, &FOLLOW_COMMA_in_keyValueCollection125);
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto rulekeyValueCollectionEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return ;
            	        	        }


            	        	        this->followPush(FOLLOW_keyValuePair_in_keyValueCollection127);
            	        	        keyValuePair();

            	        	        this->followPop();
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto rulekeyValueCollectionEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return ;
            	        	        }


            	        	    }
            	        	    break;

            	        	default:
            	        	    goto loop4;	/* break out of the loop */
            	        	    break;
            	            }
            	        }
            	        loop4: ; /* Jump out to here if this rule does not match */


            	    }
            	    break;

                }
            }

             this->matchToken(RIGTH_CURLY_BRACKET, &FOLLOW_RIGTH_CURLY_BRACKET_in_keyValueCollection134);
            if  (this->hasException())
            {
                goto rulekeyValueCollectionEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulekeyValueCollectionEx; /* Prevent compiler warnings */
    rulekeyValueCollectionEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end keyValueCollection */

/**
 * $ANTLR start keyValuePair
 * D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScript.g:72:1: keyValuePair : ( IDENTIFIER | ( ( '@' )? NUMBER ) ) ':' keyValueValue ;
 */
void
GeoGenScriptParser::keyValuePair()
{
        GeoGenScriptParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScript.g:72:13: ( ( IDENTIFIER | ( ( '@' )? NUMBER ) ) ':' keyValueValue )
        // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScript.g:72:15: ( IDENTIFIER | ( ( '@' )? NUMBER ) ) ':' keyValueValue
        {
            // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScript.g:72:15: ( IDENTIFIER | ( ( '@' )? NUMBER ) )
            {
                int alt7=2;
                switch ( this->LA(1) )
                {
                case IDENTIFIER:
                	{
                		alt7=1;
                	}
                    break;
                case AT:
                case NUMBER:
                	{
                		alt7=2;
                	}
                    break;

                default:
                    if (this->get_backtracking()>0)
                    {
                        this->set_failedflag( true );
                        return ;
                    }

                    ExceptionBaseType* ex = new ANTLR_Exception< GeoGenScriptParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                    ex->set_decisionNum( 7 );
                    ex->set_state( 0 );


                    goto rulekeyValuePairEx;

                }

                switch (alt7)
                {
            	case 1:
            	    // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScript.g:72:16: IDENTIFIER
            	    {
            	         this->matchToken(IDENTIFIER, &FOLLOW_IDENTIFIER_in_keyValuePair142);
            	        if  (this->hasException())
            	        {
            	            goto rulekeyValuePairEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;
            	case 2:
            	    // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScript.g:72:29: ( ( '@' )? NUMBER )
            	    {
            	        // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScript.g:72:29: ( ( '@' )? NUMBER )
            	        // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScript.g:72:30: ( '@' )? NUMBER
            	        {
            	            // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScript.g:72:30: ( '@' )?
            	            {
            	                int alt6=2;
            	                switch ( this->LA(1) )
            	                {
            	                    case AT:
            	                    	{
            	                    		alt6=1;
            	                    	}
            	                        break;
            	                }

            	                switch (alt6)
            	                {
            	            	case 1:
            	            	    // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScript.g:72:30: '@'
            	            	    {
            	            	         this->matchToken(AT, &FOLLOW_AT_in_keyValuePair147);
            	            	        if  (this->hasException())
            	            	        {
            	            	            goto rulekeyValuePairEx;
            	            	        }
            	            	        if (this->hasFailed())
            	            	        {
            	            	            return ;
            	            	        }


            	            	    }
            	            	    break;

            	                }
            	            }

            	             this->matchToken(NUMBER, &FOLLOW_NUMBER_in_keyValuePair150);
            	            if  (this->hasException())
            	            {
            	                goto rulekeyValuePairEx;
            	            }
            	            if (this->hasFailed())
            	            {
            	                return ;
            	            }


            	        }


            	    }
            	    break;

                }
            }

             this->matchToken(COLON, &FOLLOW_COLON_in_keyValuePair155);
            if  (this->hasException())
            {
                goto rulekeyValuePairEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_keyValueValue_in_keyValuePair157);
            keyValueValue();

            this->followPop();
            if  (this->hasException())
            {
                goto rulekeyValuePairEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulekeyValuePairEx; /* Prevent compiler warnings */
    rulekeyValuePairEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end keyValuePair */

/**
 * $ANTLR start keyValueValue
 * D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScript.g:74:1: keyValueValue : ( expression | keyValueCollection );
 */
void
GeoGenScriptParser::keyValueValue()
{
        GeoGenScriptParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        {
            //  D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScript.g:74:14: ( expression | keyValueCollection )

            ANTLR_UINT32 alt8;

            alt8=2;

            switch ( this->LA(1) )
            {
            case AT:
            case FALSE_LIT:
            case IDENTIFIER:
            case LEFT_BRACKET:
            case LEFT_SQUARE_BRACKET:
            case NUMBER:
            case OPERATOR_DECREMENT:
            case OPERATOR_INCREMENT:
            case OPERATOR_MINUS:
            case OPERATOR_NOT:
            case OPERATOR_PLUS:
            case STRING:
            case TRUE_LIT:
            	{
            		alt8=1;
            	}
                break;
            case LEFT_CURLY_BRACKET:
            	{
            		{
            		    int LA8_3 = this->LA(2);
            		    if ( (this->msynpred( antlr3::ClassForwarder<synpred9_GeoGenScript>() )))
            		    {
            		        alt8=1;
            		    }
            		    else if ( (true))
            		    {
            		        alt8=2;
            		    }
            		    else
            		    {
            		        if (this->get_backtracking()>0)
            		        {
            		            this->set_failedflag( true );
            		            return ;
            		        }


            		        ExceptionBaseType* ex = new ANTLR_Exception< GeoGenScriptParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
            		        ex->set_decisionNum( 8 );
            		        ex->set_state( 3 );


            		        goto rulekeyValueValueEx;

            		    }
            		}
            	}
                break;

            default:
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                ExceptionBaseType* ex = new ANTLR_Exception< GeoGenScriptParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                ex->set_decisionNum( 8 );
                ex->set_state( 0 );


                goto rulekeyValueValueEx;

            }

            switch (alt8)
            {
        	case 1:
        	    // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScript.g:74:16: expression
        	    {
        	        this->followPush(FOLLOW_expression_in_keyValueValue164);
        	        expression();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulekeyValueValueEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 2:
        	    // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScript.g:74:29: keyValueCollection
        	    {
        	        this->followPush(FOLLOW_keyValueCollection_in_keyValueValue168);
        	        keyValueCollection();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulekeyValueValueEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;

            }
        }
    }
    // This is where rules clean up and exit
    //
    goto rulekeyValueValueEx; /* Prevent compiler warnings */
    rulekeyValueValueEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end keyValueValue */

/**
 * $ANTLR start declaration
 * D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScript.g:76:1: declaration : ( enumDeclaration | functionDeclaration );
 */
void
GeoGenScriptParser::declaration()
{
        GeoGenScriptParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        {
            //  D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScript.g:76:12: ( enumDeclaration | functionDeclaration )

            ANTLR_UINT32 alt9;

            alt9=2;

            switch ( this->LA(1) )
            {
            case ENUM:
            	{
            		alt9=1;
            	}
                break;
            case FUNCTION:
            	{
            		alt9=2;
            	}
                break;

            default:
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                ExceptionBaseType* ex = new ANTLR_Exception< GeoGenScriptParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                ex->set_decisionNum( 9 );
                ex->set_state( 0 );


                goto ruledeclarationEx;

            }

            switch (alt9)
            {
        	case 1:
        	    // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScript.g:76:14: enumDeclaration
        	    {
        	        this->followPush(FOLLOW_enumDeclaration_in_declaration175);
        	        enumDeclaration();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruledeclarationEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 2:
        	    // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScript.g:76:32: functionDeclaration
        	    {
        	        this->followPush(FOLLOW_functionDeclaration_in_declaration179);
        	        functionDeclaration();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruledeclarationEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;

            }
        }
    }
    // This is where rules clean up and exit
    //
    goto ruledeclarationEx; /* Prevent compiler warnings */
    ruledeclarationEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end declaration */

/**
 * $ANTLR start enumDeclaration
 * D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScript.g:78:1: enumDeclaration : 'enum' IDENTIFIER '{' ( enumValues )? '}' ;
 */
void
GeoGenScriptParser::enumDeclaration()
{
        GeoGenScriptParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScript.g:78:16: ( 'enum' IDENTIFIER '{' ( enumValues )? '}' )
        // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScript.g:78:18: 'enum' IDENTIFIER '{' ( enumValues )? '}'
        {
             this->matchToken(ENUM, &FOLLOW_ENUM_in_enumDeclaration186);
            if  (this->hasException())
            {
                goto ruleenumDeclarationEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


             this->matchToken(IDENTIFIER, &FOLLOW_IDENTIFIER_in_enumDeclaration188);
            if  (this->hasException())
            {
                goto ruleenumDeclarationEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


             this->matchToken(LEFT_CURLY_BRACKET, &FOLLOW_LEFT_CURLY_BRACKET_in_enumDeclaration190);
            if  (this->hasException())
            {
                goto ruleenumDeclarationEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScript.g:78:40: ( enumValues )?
            {
                int alt10=2;
                switch ( this->LA(1) )
                {
                    case IDENTIFIER:
                    	{
                    		alt10=1;
                    	}
                        break;
                }

                switch (alt10)
                {
            	case 1:
            	    // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScript.g:78:40: enumValues
            	    {
            	        this->followPush(FOLLOW_enumValues_in_enumDeclaration192);
            	        enumValues();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleenumDeclarationEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

             this->matchToken(RIGTH_CURLY_BRACKET, &FOLLOW_RIGTH_CURLY_BRACKET_in_enumDeclaration195);
            if  (this->hasException())
            {
                goto ruleenumDeclarationEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleenumDeclarationEx; /* Prevent compiler warnings */
    ruleenumDeclarationEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end enumDeclaration */

/**
 * $ANTLR start enumValues
 * D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScript.g:80:1: enumValues : enumValue ( ',' enumValue )* ;
 */
void
GeoGenScriptParser::enumValues()
{
        GeoGenScriptParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScript.g:80:11: ( enumValue ( ',' enumValue )* )
        // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScript.g:80:13: enumValue ( ',' enumValue )*
        {
            this->followPush(FOLLOW_enumValue_in_enumValues202);
            enumValue();

            this->followPop();
            if  (this->hasException())
            {
                goto ruleenumValuesEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScript.g:80:23: ( ',' enumValue )*

            for (;;)
            {
                int alt11=2;
                switch ( this->LA(1) )
                {
                case COMMA:
                	{
                		alt11=1;
                	}
                    break;

                }

                switch (alt11)
                {
            	case 1:
            	    // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScript.g:80:24: ',' enumValue
            	    {
            	         this->matchToken(COMMA, &FOLLOW_COMMA_in_enumValues205);
            	        if  (this->hasException())
            	        {
            	            goto ruleenumValuesEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        this->followPush(FOLLOW_enumValue_in_enumValues207);
            	        enumValue();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleenumValuesEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

            	default:
            	    goto loop11;	/* break out of the loop */
            	    break;
                }
            }
            loop11: ; /* Jump out to here if this rule does not match */


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleenumValuesEx; /* Prevent compiler warnings */
    ruleenumValuesEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end enumValues */

/**
 * $ANTLR start enumValue
 * D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScript.g:82:1: enumValue : IDENTIFIER ( '=' expression )? ;
 */
void
GeoGenScriptParser::enumValue()
{
        GeoGenScriptParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScript.g:82:10: ( IDENTIFIER ( '=' expression )? )
        // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScript.g:83:5: IDENTIFIER ( '=' expression )?
        {
             this->matchToken(IDENTIFIER, &FOLLOW_IDENTIFIER_in_enumValue221);
            if  (this->hasException())
            {
                goto ruleenumValueEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScript.g:83:16: ( '=' expression )?
            {
                int alt12=2;
                switch ( this->LA(1) )
                {
                    case OPERATOR_ASSIGN:
                    	{
                    		alt12=1;
                    	}
                        break;
                }

                switch (alt12)
                {
            	case 1:
            	    // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScript.g:83:18: '=' expression
            	    {
            	         this->matchToken(OPERATOR_ASSIGN, &FOLLOW_OPERATOR_ASSIGN_in_enumValue225);
            	        if  (this->hasException())
            	        {
            	            goto ruleenumValueEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        this->followPush(FOLLOW_expression_in_enumValue227);
            	        expression();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleenumValueEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

        }

    }
    // This is where rules clean up and exit
    //
    goto ruleenumValueEx; /* Prevent compiler warnings */
    ruleenumValueEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end enumValue */

/**
 * $ANTLR start functionDeclaration
 * D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScript.g:85:1: functionDeclaration : 'function' IDENTIFIER '(' ( formalParameters )? ')' block ;
 */
void
GeoGenScriptParser::functionDeclaration()
{
        GeoGenScriptParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScript.g:85:20: ( 'function' IDENTIFIER '(' ( formalParameters )? ')' block )
        // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScript.g:85:22: 'function' IDENTIFIER '(' ( formalParameters )? ')' block
        {
             this->matchToken(FUNCTION, &FOLLOW_FUNCTION_in_functionDeclaration236);
            if  (this->hasException())
            {
                goto rulefunctionDeclarationEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


             this->matchToken(IDENTIFIER, &FOLLOW_IDENTIFIER_in_functionDeclaration238);
            if  (this->hasException())
            {
                goto rulefunctionDeclarationEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


             this->matchToken(LEFT_BRACKET, &FOLLOW_LEFT_BRACKET_in_functionDeclaration240);
            if  (this->hasException())
            {
                goto rulefunctionDeclarationEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScript.g:85:48: ( formalParameters )?
            {
                int alt13=2;
                switch ( this->LA(1) )
                {
                    case IDENTIFIER:
                    	{
                    		alt13=1;
                    	}
                        break;
                }

                switch (alt13)
                {
            	case 1:
            	    // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScript.g:85:48: formalParameters
            	    {
            	        this->followPush(FOLLOW_formalParameters_in_functionDeclaration242);
            	        formalParameters();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulefunctionDeclarationEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

             this->matchToken(RIGHT_BRACKET, &FOLLOW_RIGHT_BRACKET_in_functionDeclaration245);
            if  (this->hasException())
            {
                goto rulefunctionDeclarationEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_block_in_functionDeclaration247);
            block();

            this->followPop();
            if  (this->hasException())
            {
                goto rulefunctionDeclarationEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulefunctionDeclarationEx; /* Prevent compiler warnings */
    rulefunctionDeclarationEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end functionDeclaration */

/**
 * $ANTLR start formalParameters
 * D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScript.g:87:1: formalParameters : IDENTIFIER ( ',' IDENTIFIER )* ;
 */
void
GeoGenScriptParser::formalParameters()
{
        GeoGenScriptParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScript.g:87:17: ( IDENTIFIER ( ',' IDENTIFIER )* )
        // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScript.g:87:19: IDENTIFIER ( ',' IDENTIFIER )*
        {
             this->matchToken(IDENTIFIER, &FOLLOW_IDENTIFIER_in_formalParameters254);
            if  (this->hasException())
            {
                goto ruleformalParametersEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScript.g:87:30: ( ',' IDENTIFIER )*

            for (;;)
            {
                int alt14=2;
                switch ( this->LA(1) )
                {
                case COMMA:
                	{
                		alt14=1;
                	}
                    break;

                }

                switch (alt14)
                {
            	case 1:
            	    // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScript.g:87:31: ',' IDENTIFIER
            	    {
            	         this->matchToken(COMMA, &FOLLOW_COMMA_in_formalParameters257);
            	        if  (this->hasException())
            	        {
            	            goto ruleformalParametersEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	         this->matchToken(IDENTIFIER, &FOLLOW_IDENTIFIER_in_formalParameters259);
            	        if  (this->hasException())
            	        {
            	            goto ruleformalParametersEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

            	default:
            	    goto loop14;	/* break out of the loop */
            	    break;
                }
            }
            loop14: ; /* Jump out to here if this rule does not match */


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleformalParametersEx; /* Prevent compiler warnings */
    ruleformalParametersEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end formalParameters */

/**
 * $ANTLR start block
 * D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScript.g:89:1: block : '{' ( statement )* '}' ;
 */
void
GeoGenScriptParser::block()
{
        GeoGenScriptParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScript.g:89:6: ( '{' ( statement )* '}' )
        // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScript.g:89:8: '{' ( statement )* '}'
        {
             this->matchToken(LEFT_CURLY_BRACKET, &FOLLOW_LEFT_CURLY_BRACKET_in_block268);
            if  (this->hasException())
            {
                goto ruleblockEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScript.g:89:12: ( statement )*

            for (;;)
            {
                int alt15=2;
                switch ( this->LA(1) )
                {
                case AT:
                case BREAK:
                case CONTINUE:
                case FALSE_LIT:
                case FOR:
                case IDENTIFIER:
                case IF:
                case LEFT_BRACKET:
                case LEFT_CURLY_BRACKET:
                case LEFT_SQUARE_BRACKET:
                case NUMBER:
                case OPERATOR_DECREMENT:
                case OPERATOR_INCREMENT:
                case OPERATOR_MINUS:
                case OPERATOR_NOT:
                case OPERATOR_PLUS:
                case RETURN:
                case SEMICOLON:
                case STRING:
                case SWITCH:
                case TRUE_LIT:
                case VAR:
                case WHILE:
                case YIELD:
                	{
                		alt15=1;
                	}
                    break;

                }

                switch (alt15)
                {
            	case 1:
            	    // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScript.g:89:12: statement
            	    {
            	        this->followPush(FOLLOW_statement_in_block270);
            	        statement();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleblockEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

            	default:
            	    goto loop15;	/* break out of the loop */
            	    break;
                }
            }
            loop15: ; /* Jump out to here if this rule does not match */


             this->matchToken(RIGTH_CURLY_BRACKET, &FOLLOW_RIGTH_CURLY_BRACKET_in_block273);
            if  (this->hasException())
            {
                goto ruleblockEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleblockEx; /* Prevent compiler warnings */
    ruleblockEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end block */

/**
 * $ANTLR start statement
 * D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScript.g:91:1: statement : ( 'break' ';' | 'continue' ';' | variableDeclaration ';' | expression ';' | yieldStatement ';' | returnStatement ';' | whileStatement | forStatement | ifStatement | switchStatement | block | ';' );
 */
void
GeoGenScriptParser::statement()
{
        GeoGenScriptParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        {
            //  D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScript.g:91:10: ( 'break' ';' | 'continue' ';' | variableDeclaration ';' | expression ';' | yieldStatement ';' | returnStatement ';' | whileStatement | forStatement | ifStatement | switchStatement | block | ';' )

            ANTLR_UINT32 alt16;

            alt16=12;

            switch ( this->LA(1) )
            {
            case BREAK:
            	{
            		alt16=1;
            	}
                break;
            case CONTINUE:
            	{
            		alt16=2;
            	}
                break;
            case VAR:
            	{
            		alt16=3;
            	}
                break;
            case AT:
            case FALSE_LIT:
            case IDENTIFIER:
            case LEFT_BRACKET:
            case LEFT_SQUARE_BRACKET:
            case NUMBER:
            case OPERATOR_DECREMENT:
            case OPERATOR_INCREMENT:
            case OPERATOR_MINUS:
            case OPERATOR_NOT:
            case OPERATOR_PLUS:
            case STRING:
            case TRUE_LIT:
            	{
            		alt16=4;
            	}
                break;
            case LEFT_CURLY_BRACKET:
            	{
            		{
            		    int LA16_6 = this->LA(2);
            		    if ( (this->msynpred( antlr3::ClassForwarder<synpred20_GeoGenScript>() )))
            		    {
            		        alt16=4;
            		    }
            		    else if ( (this->msynpred( antlr3::ClassForwarder<synpred27_GeoGenScript>() )))
            		    {
            		        alt16=11;
            		    }
            		    else
            		    {
            		        if (this->get_backtracking()>0)
            		        {
            		            this->set_failedflag( true );
            		            return ;
            		        }


            		        ExceptionBaseType* ex = new ANTLR_Exception< GeoGenScriptParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
            		        ex->set_decisionNum( 16 );
            		        ex->set_state( 6 );


            		        goto rulestatementEx;

            		    }
            		}
            	}
                break;
            case YIELD:
            	{
            		alt16=5;
            	}
                break;
            case RETURN:
            	{
            		alt16=6;
            	}
                break;
            case WHILE:
            	{
            		alt16=7;
            	}
                break;
            case FOR:
            	{
            		alt16=8;
            	}
                break;
            case IF:
            	{
            		alt16=9;
            	}
                break;
            case SWITCH:
            	{
            		alt16=10;
            	}
                break;
            case SEMICOLON:
            	{
            		alt16=12;
            	}
                break;

            default:
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                ExceptionBaseType* ex = new ANTLR_Exception< GeoGenScriptParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                ex->set_decisionNum( 16 );
                ex->set_state( 0 );


                goto rulestatementEx;

            }

            switch (alt16)
            {
        	case 1:
        	    // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScript.g:92:5: 'break' ';'
        	    {
        	         this->matchToken(BREAK, &FOLLOW_BREAK_in_statement289);
        	        if  (this->hasException())
        	        {
        	            goto rulestatementEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	         this->matchToken(SEMICOLON, &FOLLOW_SEMICOLON_in_statement291);
        	        if  (this->hasException())
        	        {
        	            goto rulestatementEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 2:
        	    // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScript.g:93:5: 'continue' ';'
        	    {
        	         this->matchToken(CONTINUE, &FOLLOW_CONTINUE_in_statement299);
        	        if  (this->hasException())
        	        {
        	            goto rulestatementEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	         this->matchToken(SEMICOLON, &FOLLOW_SEMICOLON_in_statement301);
        	        if  (this->hasException())
        	        {
        	            goto rulestatementEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 3:
        	    // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScript.g:94:5: variableDeclaration ';'
        	    {
        	        this->followPush(FOLLOW_variableDeclaration_in_statement309);
        	        variableDeclaration();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulestatementEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	         this->matchToken(SEMICOLON, &FOLLOW_SEMICOLON_in_statement311);
        	        if  (this->hasException())
        	        {
        	            goto rulestatementEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 4:
        	    // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScript.g:95:5: expression ';'
        	    {
        	        this->followPush(FOLLOW_expression_in_statement319);
        	        expression();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulestatementEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	         this->matchToken(SEMICOLON, &FOLLOW_SEMICOLON_in_statement321);
        	        if  (this->hasException())
        	        {
        	            goto rulestatementEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 5:
        	    // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScript.g:96:5: yieldStatement ';'
        	    {
        	        this->followPush(FOLLOW_yieldStatement_in_statement329);
        	        yieldStatement();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulestatementEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	         this->matchToken(SEMICOLON, &FOLLOW_SEMICOLON_in_statement331);
        	        if  (this->hasException())
        	        {
        	            goto rulestatementEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 6:
        	    // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScript.g:97:5: returnStatement ';'
        	    {
        	        this->followPush(FOLLOW_returnStatement_in_statement339);
        	        returnStatement();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulestatementEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	         this->matchToken(SEMICOLON, &FOLLOW_SEMICOLON_in_statement341);
        	        if  (this->hasException())
        	        {
        	            goto rulestatementEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 7:
        	    // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScript.g:98:5: whileStatement
        	    {
        	        this->followPush(FOLLOW_whileStatement_in_statement349);
        	        whileStatement();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulestatementEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 8:
        	    // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScript.g:99:5: forStatement
        	    {
        	        this->followPush(FOLLOW_forStatement_in_statement357);
        	        forStatement();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulestatementEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 9:
        	    // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScript.g:100:5: ifStatement
        	    {
        	        this->followPush(FOLLOW_ifStatement_in_statement365);
        	        ifStatement();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulestatementEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 10:
        	    // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScript.g:101:5: switchStatement
        	    {
        	        this->followPush(FOLLOW_switchStatement_in_statement373);
        	        switchStatement();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulestatementEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 11:
        	    // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScript.g:102:5: block
        	    {
        	        this->followPush(FOLLOW_block_in_statement385);
        	        block();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulestatementEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 12:
        	    // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScript.g:103:5: ';'
        	    {
        	         this->matchToken(SEMICOLON, &FOLLOW_SEMICOLON_in_statement393);
        	        if  (this->hasException())
        	        {
        	            goto rulestatementEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;

            }
        }
    }
    // This is where rules clean up and exit
    //
    goto rulestatementEx; /* Prevent compiler warnings */
    rulestatementEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end statement */

/**
 * $ANTLR start variableDeclaration
 * D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScript.g:105:1: variableDeclaration : 'var' IDENTIFIER ( '=' expression )? ;
 */
void
GeoGenScriptParser::variableDeclaration()
{
        GeoGenScriptParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScript.g:105:20: ( 'var' IDENTIFIER ( '=' expression )? )
        // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScript.g:105:22: 'var' IDENTIFIER ( '=' expression )?
        {
             this->matchToken(VAR, &FOLLOW_VAR_in_variableDeclaration404);
            if  (this->hasException())
            {
                goto rulevariableDeclarationEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


             this->matchToken(IDENTIFIER, &FOLLOW_IDENTIFIER_in_variableDeclaration406);
            if  (this->hasException())
            {
                goto rulevariableDeclarationEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScript.g:105:39: ( '=' expression )?
            {
                int alt17=2;
                switch ( this->LA(1) )
                {
                    case OPERATOR_ASSIGN:
                    	{
                    		alt17=1;
                    	}
                        break;
                }

                switch (alt17)
                {
            	case 1:
            	    // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScript.g:105:40: '=' expression
            	    {
            	         this->matchToken(OPERATOR_ASSIGN, &FOLLOW_OPERATOR_ASSIGN_in_variableDeclaration409);
            	        if  (this->hasException())
            	        {
            	            goto rulevariableDeclarationEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        this->followPush(FOLLOW_expression_in_variableDeclaration411);
            	        expression();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulevariableDeclarationEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

        }

    }
    // This is where rules clean up and exit
    //
    goto rulevariableDeclarationEx; /* Prevent compiler warnings */
    rulevariableDeclarationEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end variableDeclaration */

/**
 * $ANTLR start yieldStatement
 * D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScript.g:107:1: yieldStatement : ( 'yield' expression 'as' STRING | 'yield' expression );
 */
void
GeoGenScriptParser::yieldStatement()
{
        GeoGenScriptParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        {
            //  D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScript.g:107:15: ( 'yield' expression 'as' STRING | 'yield' expression )

            ANTLR_UINT32 alt18;

            alt18=2;

            switch ( this->LA(1) )
            {
            case YIELD:
            	{
            		{
            		    int LA18_1 = this->LA(2);
            		    if ( (this->msynpred( antlr3::ClassForwarder<synpred29_GeoGenScript>() )))
            		    {
            		        alt18=1;
            		    }
            		    else if ( (true))
            		    {
            		        alt18=2;
            		    }
            		    else
            		    {
            		        if (this->get_backtracking()>0)
            		        {
            		            this->set_failedflag( true );
            		            return ;
            		        }


            		        ExceptionBaseType* ex = new ANTLR_Exception< GeoGenScriptParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
            		        ex->set_decisionNum( 18 );
            		        ex->set_state( 1 );


            		        goto ruleyieldStatementEx;

            		    }
            		}
            	}
                break;

            default:
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                ExceptionBaseType* ex = new ANTLR_Exception< GeoGenScriptParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                ex->set_decisionNum( 18 );
                ex->set_state( 0 );


                goto ruleyieldStatementEx;

            }

            switch (alt18)
            {
        	case 1:
        	    // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScript.g:108:5: 'yield' expression 'as' STRING
        	    {
        	         this->matchToken(YIELD, &FOLLOW_YIELD_in_yieldStatement425);
        	        if  (this->hasException())
        	        {
        	            goto ruleyieldStatementEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	        this->followPush(FOLLOW_expression_in_yieldStatement427);
        	        expression();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruleyieldStatementEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	         this->matchToken(AS, &FOLLOW_AS_in_yieldStatement429);
        	        if  (this->hasException())
        	        {
        	            goto ruleyieldStatementEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	         this->matchToken(STRING, &FOLLOW_STRING_in_yieldStatement431);
        	        if  (this->hasException())
        	        {
        	            goto ruleyieldStatementEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 2:
        	    // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScript.g:109:5: 'yield' expression
        	    {
        	         this->matchToken(YIELD, &FOLLOW_YIELD_in_yieldStatement439);
        	        if  (this->hasException())
        	        {
        	            goto ruleyieldStatementEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	        this->followPush(FOLLOW_expression_in_yieldStatement441);
        	        expression();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruleyieldStatementEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;

            }
        }
    }
    // This is where rules clean up and exit
    //
    goto ruleyieldStatementEx; /* Prevent compiler warnings */
    ruleyieldStatementEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end yieldStatement */

/**
 * $ANTLR start returnStatement
 * D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScript.g:112:1: returnStatement : 'return' expression ;
 */
void
GeoGenScriptParser::returnStatement()
{
        GeoGenScriptParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScript.g:112:16: ( 'return' expression )
        // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScript.g:112:18: 'return' expression
        {
             this->matchToken(RETURN, &FOLLOW_RETURN_in_returnStatement449);
            if  (this->hasException())
            {
                goto rulereturnStatementEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_expression_in_returnStatement451);
            expression();

            this->followPop();
            if  (this->hasException())
            {
                goto rulereturnStatementEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulereturnStatementEx; /* Prevent compiler warnings */
    rulereturnStatementEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end returnStatement */

/**
 * $ANTLR start whileStatement
 * D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScript.g:114:1: whileStatement : 'while' '(' expression ')' statement ;
 */
void
GeoGenScriptParser::whileStatement()
{
        GeoGenScriptParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScript.g:114:15: ( 'while' '(' expression ')' statement )
        // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScript.g:114:17: 'while' '(' expression ')' statement
        {
             this->matchToken(WHILE, &FOLLOW_WHILE_in_whileStatement458);
            if  (this->hasException())
            {
                goto rulewhileStatementEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


             this->matchToken(LEFT_BRACKET, &FOLLOW_LEFT_BRACKET_in_whileStatement460);
            if  (this->hasException())
            {
                goto rulewhileStatementEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_expression_in_whileStatement462);
            expression();

            this->followPop();
            if  (this->hasException())
            {
                goto rulewhileStatementEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


             this->matchToken(RIGHT_BRACKET, &FOLLOW_RIGHT_BRACKET_in_whileStatement464);
            if  (this->hasException())
            {
                goto rulewhileStatementEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_statement_in_whileStatement466);
            statement();

            this->followPop();
            if  (this->hasException())
            {
                goto rulewhileStatementEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulewhileStatementEx; /* Prevent compiler warnings */
    rulewhileStatementEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end whileStatement */

/**
 * $ANTLR start forStatement
 * D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScript.g:116:1: forStatement : 'for' '(' ( initExpression )? ';' ( expression )? ';' ( expression )? ')' statement ;
 */
void
GeoGenScriptParser::forStatement()
{
        GeoGenScriptParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScript.g:116:13: ( 'for' '(' ( initExpression )? ';' ( expression )? ';' ( expression )? ')' statement )
        // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScript.g:116:15: 'for' '(' ( initExpression )? ';' ( expression )? ';' ( expression )? ')' statement
        {
             this->matchToken(FOR, &FOLLOW_FOR_in_forStatement474);
            if  (this->hasException())
            {
                goto ruleforStatementEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


             this->matchToken(LEFT_BRACKET, &FOLLOW_LEFT_BRACKET_in_forStatement476);
            if  (this->hasException())
            {
                goto ruleforStatementEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScript.g:116:25: ( initExpression )?
            {
                int alt19=2;
                switch ( this->LA(1) )
                {
                    case AT:
                    case FALSE_LIT:
                    case IDENTIFIER:
                    case LEFT_BRACKET:
                    case LEFT_CURLY_BRACKET:
                    case LEFT_SQUARE_BRACKET:
                    case NUMBER:
                    case OPERATOR_DECREMENT:
                    case OPERATOR_INCREMENT:
                    case OPERATOR_MINUS:
                    case OPERATOR_NOT:
                    case OPERATOR_PLUS:
                    case STRING:
                    case TRUE_LIT:
                    case VAR:
                    	{
                    		alt19=1;
                    	}
                        break;
                }

                switch (alt19)
                {
            	case 1:
            	    // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScript.g:116:25: initExpression
            	    {
            	        this->followPush(FOLLOW_initExpression_in_forStatement478);
            	        initExpression();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleforStatementEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

             this->matchToken(SEMICOLON, &FOLLOW_SEMICOLON_in_forStatement481);
            if  (this->hasException())
            {
                goto ruleforStatementEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScript.g:116:45: ( expression )?
            {
                int alt20=2;
                switch ( this->LA(1) )
                {
                    case AT:
                    case FALSE_LIT:
                    case IDENTIFIER:
                    case LEFT_BRACKET:
                    case LEFT_CURLY_BRACKET:
                    case LEFT_SQUARE_BRACKET:
                    case NUMBER:
                    case OPERATOR_DECREMENT:
                    case OPERATOR_INCREMENT:
                    case OPERATOR_MINUS:
                    case OPERATOR_NOT:
                    case OPERATOR_PLUS:
                    case STRING:
                    case TRUE_LIT:
                    	{
                    		alt20=1;
                    	}
                        break;
                }

                switch (alt20)
                {
            	case 1:
            	    // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScript.g:116:45: expression
            	    {
            	        this->followPush(FOLLOW_expression_in_forStatement483);
            	        expression();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleforStatementEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

             this->matchToken(SEMICOLON, &FOLLOW_SEMICOLON_in_forStatement486);
            if  (this->hasException())
            {
                goto ruleforStatementEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScript.g:116:61: ( expression )?
            {
                int alt21=2;
                switch ( this->LA(1) )
                {
                    case AT:
                    case FALSE_LIT:
                    case IDENTIFIER:
                    case LEFT_BRACKET:
                    case LEFT_CURLY_BRACKET:
                    case LEFT_SQUARE_BRACKET:
                    case NUMBER:
                    case OPERATOR_DECREMENT:
                    case OPERATOR_INCREMENT:
                    case OPERATOR_MINUS:
                    case OPERATOR_NOT:
                    case OPERATOR_PLUS:
                    case STRING:
                    case TRUE_LIT:
                    	{
                    		alt21=1;
                    	}
                        break;
                }

                switch (alt21)
                {
            	case 1:
            	    // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScript.g:116:61: expression
            	    {
            	        this->followPush(FOLLOW_expression_in_forStatement488);
            	        expression();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleforStatementEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

             this->matchToken(RIGHT_BRACKET, &FOLLOW_RIGHT_BRACKET_in_forStatement491);
            if  (this->hasException())
            {
                goto ruleforStatementEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_statement_in_forStatement493);
            statement();

            this->followPop();
            if  (this->hasException())
            {
                goto ruleforStatementEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleforStatementEx; /* Prevent compiler warnings */
    ruleforStatementEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end forStatement */

/**
 * $ANTLR start initExpression
 * D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScript.g:118:1: initExpression : ( 'var' IDENTIFIER '=' expression | expression );
 */
void
GeoGenScriptParser::initExpression()
{
        GeoGenScriptParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        {
            //  D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScript.g:118:15: ( 'var' IDENTIFIER '=' expression | expression )

            ANTLR_UINT32 alt22;

            alt22=2;

            switch ( this->LA(1) )
            {
            case VAR:
            	{
            		alt22=1;
            	}
                break;
            case AT:
            case FALSE_LIT:
            case IDENTIFIER:
            case LEFT_BRACKET:
            case LEFT_CURLY_BRACKET:
            case LEFT_SQUARE_BRACKET:
            case NUMBER:
            case OPERATOR_DECREMENT:
            case OPERATOR_INCREMENT:
            case OPERATOR_MINUS:
            case OPERATOR_NOT:
            case OPERATOR_PLUS:
            case STRING:
            case TRUE_LIT:
            	{
            		alt22=2;
            	}
                break;

            default:
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                ExceptionBaseType* ex = new ANTLR_Exception< GeoGenScriptParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                ex->set_decisionNum( 22 );
                ex->set_state( 0 );


                goto ruleinitExpressionEx;

            }

            switch (alt22)
            {
        	case 1:
        	    // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScript.g:119:5: 'var' IDENTIFIER '=' expression
        	    {
        	         this->matchToken(VAR, &FOLLOW_VAR_in_initExpression505);
        	        if  (this->hasException())
        	        {
        	            goto ruleinitExpressionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	         this->matchToken(IDENTIFIER, &FOLLOW_IDENTIFIER_in_initExpression507);
        	        if  (this->hasException())
        	        {
        	            goto ruleinitExpressionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	         this->matchToken(OPERATOR_ASSIGN, &FOLLOW_OPERATOR_ASSIGN_in_initExpression509);
        	        if  (this->hasException())
        	        {
        	            goto ruleinitExpressionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	        this->followPush(FOLLOW_expression_in_initExpression511);
        	        expression();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruleinitExpressionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 2:
        	    // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScript.g:120:5: expression
        	    {
        	        this->followPush(FOLLOW_expression_in_initExpression519);
        	        expression();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruleinitExpressionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;

            }
        }
    }
    // This is where rules clean up and exit
    //
    goto ruleinitExpressionEx; /* Prevent compiler warnings */
    ruleinitExpressionEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end initExpression */

/**
 * $ANTLR start ifStatement
 * D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScript.g:122:1: ifStatement : 'if' '(' expression ')' statement ( 'else' statement )? ;
 */
void
GeoGenScriptParser::ifStatement()
{
        GeoGenScriptParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScript.g:122:12: ( 'if' '(' expression ')' statement ( 'else' statement )? )
        // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScript.g:123:5: 'if' '(' expression ')' statement ( 'else' statement )?
        {
             this->matchToken(IF, &FOLLOW_IF_in_ifStatement530);
            if  (this->hasException())
            {
                goto ruleifStatementEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


             this->matchToken(LEFT_BRACKET, &FOLLOW_LEFT_BRACKET_in_ifStatement532);
            if  (this->hasException())
            {
                goto ruleifStatementEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_expression_in_ifStatement534);
            expression();

            this->followPop();
            if  (this->hasException())
            {
                goto ruleifStatementEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


             this->matchToken(RIGHT_BRACKET, &FOLLOW_RIGHT_BRACKET_in_ifStatement536);
            if  (this->hasException())
            {
                goto ruleifStatementEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_statement_in_ifStatement538);
            statement();

            this->followPop();
            if  (this->hasException())
            {
                goto ruleifStatementEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScript.g:124:5: ( 'else' statement )?
            {
                int alt23=2;
                switch ( this->LA(1) )
                {
                    case ELSE:
                    	{
                    		{
                    		    int LA23_1 = this->LA(2);
                    		    if ( (this->msynpred( antlr3::ClassForwarder<synpred34_GeoGenScript>() )))
                    		    {
                    		        alt23=1;
                    		    }
                    		}
                    	}
                        break;
                }

                switch (alt23)
                {
            	case 1:
            	    // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScript.g:124:6: 'else' statement
            	    {
            	         this->matchToken(ELSE, &FOLLOW_ELSE_in_ifStatement545);
            	        if  (this->hasException())
            	        {
            	            goto ruleifStatementEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        this->followPush(FOLLOW_statement_in_ifStatement547);
            	        statement();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleifStatementEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

        }

    }
    // This is where rules clean up and exit
    //
    goto ruleifStatementEx; /* Prevent compiler warnings */
    ruleifStatementEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end ifStatement */

/**
 * $ANTLR start switchStatement
 * D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScript.g:127:1: switchStatement : 'switch' '(' expression ')' '{' ( 'case' label ':' ( statement )* )* ( 'default' ':' ( statement )* )? '}' ;
 */
void
GeoGenScriptParser::switchStatement()
{
        GeoGenScriptParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScript.g:127:16: ( 'switch' '(' expression ')' '{' ( 'case' label ':' ( statement )* )* ( 'default' ':' ( statement )* )? '}' )
        // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScript.g:128:5: 'switch' '(' expression ')' '{' ( 'case' label ':' ( statement )* )* ( 'default' ':' ( statement )* )? '}'
        {
             this->matchToken(SWITCH, &FOLLOW_SWITCH_in_switchStatement561);
            if  (this->hasException())
            {
                goto ruleswitchStatementEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


             this->matchToken(LEFT_BRACKET, &FOLLOW_LEFT_BRACKET_in_switchStatement563);
            if  (this->hasException())
            {
                goto ruleswitchStatementEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_expression_in_switchStatement565);
            expression();

            this->followPop();
            if  (this->hasException())
            {
                goto ruleswitchStatementEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


             this->matchToken(RIGHT_BRACKET, &FOLLOW_RIGHT_BRACKET_in_switchStatement567);
            if  (this->hasException())
            {
                goto ruleswitchStatementEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


             this->matchToken(LEFT_CURLY_BRACKET, &FOLLOW_LEFT_CURLY_BRACKET_in_switchStatement569);
            if  (this->hasException())
            {
                goto ruleswitchStatementEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScript.g:129:9: ( 'case' label ':' ( statement )* )*

            for (;;)
            {
                int alt25=2;
                switch ( this->LA(1) )
                {
                case CASE:
                	{
                		alt25=1;
                	}
                    break;

                }

                switch (alt25)
                {
            	case 1:
            	    // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScript.g:129:10: 'case' label ':' ( statement )*
            	    {
            	         this->matchToken(CASE, &FOLLOW_CASE_in_switchStatement580);
            	        if  (this->hasException())
            	        {
            	            goto ruleswitchStatementEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        this->followPush(FOLLOW_label_in_switchStatement582);
            	        label();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleswitchStatementEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	         this->matchToken(COLON, &FOLLOW_COLON_in_switchStatement584);
            	        if  (this->hasException())
            	        {
            	            goto ruleswitchStatementEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScript.g:129:27: ( statement )*

            	        for (;;)
            	        {
            	            int alt24=2;
            	            switch ( this->LA(1) )
            	            {
            	            case AT:
            	            case BREAK:
            	            case CONTINUE:
            	            case FALSE_LIT:
            	            case FOR:
            	            case IDENTIFIER:
            	            case IF:
            	            case LEFT_BRACKET:
            	            case LEFT_CURLY_BRACKET:
            	            case LEFT_SQUARE_BRACKET:
            	            case NUMBER:
            	            case OPERATOR_DECREMENT:
            	            case OPERATOR_INCREMENT:
            	            case OPERATOR_MINUS:
            	            case OPERATOR_NOT:
            	            case OPERATOR_PLUS:
            	            case RETURN:
            	            case SEMICOLON:
            	            case STRING:
            	            case SWITCH:
            	            case TRUE_LIT:
            	            case VAR:
            	            case WHILE:
            	            case YIELD:
            	            	{
            	            		alt24=1;
            	            	}
            	                break;

            	            }

            	            switch (alt24)
            	            {
            	        	case 1:
            	        	    // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScript.g:129:27: statement
            	        	    {
            	        	        this->followPush(FOLLOW_statement_in_switchStatement586);
            	        	        statement();

            	        	        this->followPop();
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto ruleswitchStatementEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return ;
            	        	        }


            	        	    }
            	        	    break;

            	        	default:
            	        	    goto loop24;	/* break out of the loop */
            	        	    break;
            	            }
            	        }
            	        loop24: ; /* Jump out to here if this rule does not match */


            	    }
            	    break;

            	default:
            	    goto loop25;	/* break out of the loop */
            	    break;
                }
            }
            loop25: ; /* Jump out to here if this rule does not match */


            // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScript.g:130:9: ( 'default' ':' ( statement )* )?
            {
                int alt27=2;
                switch ( this->LA(1) )
                {
                    case DEFAULT:
                    	{
                    		alt27=1;
                    	}
                        break;
                }

                switch (alt27)
                {
            	case 1:
            	    // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScript.g:130:10: 'default' ':' ( statement )*
            	    {
            	         this->matchToken(DEFAULT, &FOLLOW_DEFAULT_in_switchStatement600);
            	        if  (this->hasException())
            	        {
            	            goto ruleswitchStatementEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	         this->matchToken(COLON, &FOLLOW_COLON_in_switchStatement602);
            	        if  (this->hasException())
            	        {
            	            goto ruleswitchStatementEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScript.g:130:25: ( statement )*

            	        for (;;)
            	        {
            	            int alt26=2;
            	            switch ( this->LA(1) )
            	            {
            	            case AT:
            	            case BREAK:
            	            case CONTINUE:
            	            case FALSE_LIT:
            	            case FOR:
            	            case IDENTIFIER:
            	            case IF:
            	            case LEFT_BRACKET:
            	            case LEFT_CURLY_BRACKET:
            	            case LEFT_SQUARE_BRACKET:
            	            case NUMBER:
            	            case OPERATOR_DECREMENT:
            	            case OPERATOR_INCREMENT:
            	            case OPERATOR_MINUS:
            	            case OPERATOR_NOT:
            	            case OPERATOR_PLUS:
            	            case RETURN:
            	            case SEMICOLON:
            	            case STRING:
            	            case SWITCH:
            	            case TRUE_LIT:
            	            case VAR:
            	            case WHILE:
            	            case YIELD:
            	            	{
            	            		alt26=1;
            	            	}
            	                break;

            	            }

            	            switch (alt26)
            	            {
            	        	case 1:
            	        	    // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScript.g:130:25: statement
            	        	    {
            	        	        this->followPush(FOLLOW_statement_in_switchStatement605);
            	        	        statement();

            	        	        this->followPop();
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto ruleswitchStatementEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return ;
            	        	        }


            	        	    }
            	        	    break;

            	        	default:
            	        	    goto loop26;	/* break out of the loop */
            	        	    break;
            	            }
            	        }
            	        loop26: ; /* Jump out to here if this rule does not match */


            	    }
            	    break;

                }
            }

             this->matchToken(RIGTH_CURLY_BRACKET, &FOLLOW_RIGTH_CURLY_BRACKET_in_switchStatement615);
            if  (this->hasException())
            {
                goto ruleswitchStatementEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleswitchStatementEx; /* Prevent compiler warnings */
    ruleswitchStatementEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end switchStatement */

/**
 * $ANTLR start expression
 * D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScript.g:134:1: expression : prio14Expression ;
 */
void
GeoGenScriptParser::expression()
{
        GeoGenScriptParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScript.g:134:11: ( prio14Expression )
        // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScript.g:135:5: prio14Expression
        {
            this->followPush(FOLLOW_prio14Expression_in_expression631);
            prio14Expression();

            this->followPop();
            if  (this->hasException())
            {
                goto ruleexpressionEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleexpressionEx; /* Prevent compiler warnings */
    ruleexpressionEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end expression */

/**
 * $ANTLR start prio14Operator
 * D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScript.g:137:1: prio14Operator : ( '=' | '+=' | '-=' | '*=' | '/=' | '%=' | '<<=' | '>>=' | '&=' | '^=' | 'is' );
 */
void
GeoGenScriptParser::prio14Operator()
{
        GeoGenScriptParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScript.g:137:15: ( '=' | '+=' | '-=' | '*=' | '/=' | '%=' | '<<=' | '>>=' | '&=' | '^=' | 'is' )
        // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScript.g:
        {
            if ( ((this->LA(1) >= OPERATOR_ASSIGN) && (this->LA(1) <= OPERATOR_ASSIGN_MODULO)) || ((this->LA(1) >= OPERATOR_ASSIGN_PLUS) && (this->LA(1) <= OPERATOR_ASSIGN_XOR)) || this->LA(1) == OPERATOR_IS )
            {
                this->consume();
                this->set_perror_recovery(false);
                 this->set_failedflag(false); 

            }
            else
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                new ANTLR_Exception< GeoGenScriptParserImplTraits, MISMATCHED_SET_EXCEPTION, StreamType>( this->get_rec(), "" );
                this->get_exception()->set_expectingSet(NULL);

                goto ruleprio14OperatorEx;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleprio14OperatorEx; /* Prevent compiler warnings */
    ruleprio14OperatorEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end prio14Operator */

/**
 * $ANTLR start prio14Expression
 * D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScript.g:138:1: prio14Expression : prio13Expression ( prio14Operator prio13Expression )* ;
 */
void
GeoGenScriptParser::prio14Expression()
{
        GeoGenScriptParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScript.g:138:17: ( prio13Expression ( prio14Operator prio13Expression )* )
        // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScript.g:138:19: prio13Expression ( prio14Operator prio13Expression )*
        {
            this->followPush(FOLLOW_prio13Expression_in_prio14Expression685);
            prio13Expression();

            this->followPop();
            if  (this->hasException())
            {
                goto ruleprio14ExpressionEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScript.g:138:36: ( prio14Operator prio13Expression )*

            for (;;)
            {
                int alt28=2;
                switch ( this->LA(1) )
                {
                case OPERATOR_ASSIGN:
                case OPERATOR_ASSIGN_AND:
                case OPERATOR_ASSIGN_DIVIDE:
                case OPERATOR_ASSIGN_LSHIFT:
                case OPERATOR_ASSIGN_MINUS:
                case OPERATOR_ASSIGN_MODULO:
                case OPERATOR_ASSIGN_PLUS:
                case OPERATOR_ASSIGN_RSHIFT:
                case OPERATOR_ASSIGN_TIMES:
                case OPERATOR_ASSIGN_XOR:
                case OPERATOR_IS:
                	{
                		alt28=1;
                	}
                    break;

                }

                switch (alt28)
                {
            	case 1:
            	    // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScript.g:138:37: prio14Operator prio13Expression
            	    {
            	        this->followPush(FOLLOW_prio14Operator_in_prio14Expression688);
            	        prio14Operator();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleprio14ExpressionEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        this->followPush(FOLLOW_prio13Expression_in_prio14Expression690);
            	        prio13Expression();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleprio14ExpressionEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

            	default:
            	    goto loop28;	/* break out of the loop */
            	    break;
                }
            }
            loop28: ; /* Jump out to here if this rule does not match */


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleprio14ExpressionEx; /* Prevent compiler warnings */
    ruleprio14ExpressionEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end prio14Expression */

/**
 * $ANTLR start prio13Expression
 * D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScript.g:140:1: prio13Expression : prio12Expression ( '?' prio12Expression ':' prio12Expression )* ;
 */
void
GeoGenScriptParser::prio13Expression()
{
        GeoGenScriptParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScript.g:140:17: ( prio12Expression ( '?' prio12Expression ':' prio12Expression )* )
        // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScript.g:140:19: prio12Expression ( '?' prio12Expression ':' prio12Expression )*
        {
            this->followPush(FOLLOW_prio12Expression_in_prio13Expression700);
            prio12Expression();

            this->followPop();
            if  (this->hasException())
            {
                goto ruleprio13ExpressionEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScript.g:140:36: ( '?' prio12Expression ':' prio12Expression )*

            for (;;)
            {
                int alt29=2;
                switch ( this->LA(1) )
                {
                case OPERATOR_EXPR_IF:
                	{
                		alt29=1;
                	}
                    break;

                }

                switch (alt29)
                {
            	case 1:
            	    // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScript.g:140:37: '?' prio12Expression ':' prio12Expression
            	    {
            	         this->matchToken(OPERATOR_EXPR_IF, &FOLLOW_OPERATOR_EXPR_IF_in_prio13Expression703);
            	        if  (this->hasException())
            	        {
            	            goto ruleprio13ExpressionEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        this->followPush(FOLLOW_prio12Expression_in_prio13Expression705);
            	        prio12Expression();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleprio13ExpressionEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	         this->matchToken(COLON, &FOLLOW_COLON_in_prio13Expression707);
            	        if  (this->hasException())
            	        {
            	            goto ruleprio13ExpressionEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        this->followPush(FOLLOW_prio12Expression_in_prio13Expression709);
            	        prio12Expression();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleprio13ExpressionEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

            	default:
            	    goto loop29;	/* break out of the loop */
            	    break;
                }
            }
            loop29: ; /* Jump out to here if this rule does not match */


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleprio13ExpressionEx; /* Prevent compiler warnings */
    ruleprio13ExpressionEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end prio13Expression */

/**
 * $ANTLR start prio12Operator
 * D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScript.g:142:1: prio12Operator : '||' ;
 */
void
GeoGenScriptParser::prio12Operator()
{
        GeoGenScriptParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScript.g:142:15: ( '||' )
        // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScript.g:142:17: '||'
        {
             this->matchToken(OPERATOR_REL_OR, &FOLLOW_OPERATOR_REL_OR_in_prio12Operator718);
            if  (this->hasException())
            {
                goto ruleprio12OperatorEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleprio12OperatorEx; /* Prevent compiler warnings */
    ruleprio12OperatorEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end prio12Operator */

/**
 * $ANTLR start prio12Expression
 * D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScript.g:143:1: prio12Expression : prio11Expression ( prio12Operator prio11Expression )* ;
 */
void
GeoGenScriptParser::prio12Expression()
{
        GeoGenScriptParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScript.g:143:17: ( prio11Expression ( prio12Operator prio11Expression )* )
        // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScript.g:143:19: prio11Expression ( prio12Operator prio11Expression )*
        {
            this->followPush(FOLLOW_prio11Expression_in_prio12Expression724);
            prio11Expression();

            this->followPop();
            if  (this->hasException())
            {
                goto ruleprio12ExpressionEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScript.g:143:36: ( prio12Operator prio11Expression )*

            for (;;)
            {
                int alt30=2;
                switch ( this->LA(1) )
                {
                case OPERATOR_REL_OR:
                	{
                		alt30=1;
                	}
                    break;

                }

                switch (alt30)
                {
            	case 1:
            	    // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScript.g:143:37: prio12Operator prio11Expression
            	    {
            	        this->followPush(FOLLOW_prio12Operator_in_prio12Expression727);
            	        prio12Operator();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleprio12ExpressionEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        this->followPush(FOLLOW_prio11Expression_in_prio12Expression729);
            	        prio11Expression();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleprio12ExpressionEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

            	default:
            	    goto loop30;	/* break out of the loop */
            	    break;
                }
            }
            loop30: ; /* Jump out to here if this rule does not match */


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleprio12ExpressionEx; /* Prevent compiler warnings */
    ruleprio12ExpressionEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end prio12Expression */

/**
 * $ANTLR start prio11Operator
 * D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScript.g:145:1: prio11Operator : '&&' ;
 */
void
GeoGenScriptParser::prio11Operator()
{
        GeoGenScriptParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScript.g:145:15: ( '&&' )
        // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScript.g:145:17: '&&'
        {
             this->matchToken(OPERATOR_REL_AND, &FOLLOW_OPERATOR_REL_AND_in_prio11Operator738);
            if  (this->hasException())
            {
                goto ruleprio11OperatorEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleprio11OperatorEx; /* Prevent compiler warnings */
    ruleprio11OperatorEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end prio11Operator */

/**
 * $ANTLR start prio11Expression
 * D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScript.g:146:1: prio11Expression : prio10Expression ( prio11Operator prio10Expression )* ;
 */
void
GeoGenScriptParser::prio11Expression()
{
        GeoGenScriptParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScript.g:146:17: ( prio10Expression ( prio11Operator prio10Expression )* )
        // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScript.g:146:19: prio10Expression ( prio11Operator prio10Expression )*
        {
            this->followPush(FOLLOW_prio10Expression_in_prio11Expression744);
            prio10Expression();

            this->followPop();
            if  (this->hasException())
            {
                goto ruleprio11ExpressionEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScript.g:146:36: ( prio11Operator prio10Expression )*

            for (;;)
            {
                int alt31=2;
                switch ( this->LA(1) )
                {
                case OPERATOR_REL_AND:
                	{
                		alt31=1;
                	}
                    break;

                }

                switch (alt31)
                {
            	case 1:
            	    // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScript.g:146:37: prio11Operator prio10Expression
            	    {
            	        this->followPush(FOLLOW_prio11Operator_in_prio11Expression747);
            	        prio11Operator();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleprio11ExpressionEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        this->followPush(FOLLOW_prio10Expression_in_prio11Expression749);
            	        prio10Expression();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleprio11ExpressionEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

            	default:
            	    goto loop31;	/* break out of the loop */
            	    break;
                }
            }
            loop31: ; /* Jump out to here if this rule does not match */


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleprio11ExpressionEx; /* Prevent compiler warnings */
    ruleprio11ExpressionEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end prio11Expression */

/**
 * $ANTLR start prio10Operator
 * D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScript.g:148:1: prio10Operator : '|' ;
 */
void
GeoGenScriptParser::prio10Operator()
{
        GeoGenScriptParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScript.g:148:15: ( '|' )
        // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScript.g:148:17: '|'
        {
             this->matchToken(OPERATOR_BIT_OR, &FOLLOW_OPERATOR_BIT_OR_in_prio10Operator758);
            if  (this->hasException())
            {
                goto ruleprio10OperatorEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleprio10OperatorEx; /* Prevent compiler warnings */
    ruleprio10OperatorEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end prio10Operator */

/**
 * $ANTLR start prio10Expression
 * D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScript.g:149:1: prio10Expression : prio9Expression ( prio10Operator prio9Expression )* ;
 */
void
GeoGenScriptParser::prio10Expression()
{
        GeoGenScriptParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScript.g:149:17: ( prio9Expression ( prio10Operator prio9Expression )* )
        // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScript.g:149:19: prio9Expression ( prio10Operator prio9Expression )*
        {
            this->followPush(FOLLOW_prio9Expression_in_prio10Expression764);
            prio9Expression();

            this->followPop();
            if  (this->hasException())
            {
                goto ruleprio10ExpressionEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScript.g:149:35: ( prio10Operator prio9Expression )*

            for (;;)
            {
                int alt32=2;
                switch ( this->LA(1) )
                {
                case OPERATOR_BIT_OR:
                	{
                		alt32=1;
                	}
                    break;

                }

                switch (alt32)
                {
            	case 1:
            	    // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScript.g:149:36: prio10Operator prio9Expression
            	    {
            	        this->followPush(FOLLOW_prio10Operator_in_prio10Expression767);
            	        prio10Operator();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleprio10ExpressionEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        this->followPush(FOLLOW_prio9Expression_in_prio10Expression769);
            	        prio9Expression();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleprio10ExpressionEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

            	default:
            	    goto loop32;	/* break out of the loop */
            	    break;
                }
            }
            loop32: ; /* Jump out to here if this rule does not match */


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleprio10ExpressionEx; /* Prevent compiler warnings */
    ruleprio10ExpressionEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end prio10Expression */

/**
 * $ANTLR start prio9Operator
 * D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScript.g:151:1: prio9Operator : '^' ;
 */
void
GeoGenScriptParser::prio9Operator()
{
        GeoGenScriptParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScript.g:151:14: ( '^' )
        // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScript.g:151:16: '^'
        {
             this->matchToken(OPERATOR_BIT_XOR, &FOLLOW_OPERATOR_BIT_XOR_in_prio9Operator778);
            if  (this->hasException())
            {
                goto ruleprio9OperatorEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleprio9OperatorEx; /* Prevent compiler warnings */
    ruleprio9OperatorEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end prio9Operator */

/**
 * $ANTLR start prio9Expression
 * D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScript.g:152:1: prio9Expression : prio8Expression ( prio9Operator prio8Expression )* ;
 */
void
GeoGenScriptParser::prio9Expression()
{
        GeoGenScriptParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScript.g:152:16: ( prio8Expression ( prio9Operator prio8Expression )* )
        // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScript.g:152:18: prio8Expression ( prio9Operator prio8Expression )*
        {
            this->followPush(FOLLOW_prio8Expression_in_prio9Expression784);
            prio8Expression();

            this->followPop();
            if  (this->hasException())
            {
                goto ruleprio9ExpressionEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScript.g:152:34: ( prio9Operator prio8Expression )*

            for (;;)
            {
                int alt33=2;
                switch ( this->LA(1) )
                {
                case OPERATOR_BIT_XOR:
                	{
                		alt33=1;
                	}
                    break;

                }

                switch (alt33)
                {
            	case 1:
            	    // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScript.g:152:35: prio9Operator prio8Expression
            	    {
            	        this->followPush(FOLLOW_prio9Operator_in_prio9Expression787);
            	        prio9Operator();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleprio9ExpressionEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        this->followPush(FOLLOW_prio8Expression_in_prio9Expression789);
            	        prio8Expression();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleprio9ExpressionEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

            	default:
            	    goto loop33;	/* break out of the loop */
            	    break;
                }
            }
            loop33: ; /* Jump out to here if this rule does not match */


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleprio9ExpressionEx; /* Prevent compiler warnings */
    ruleprio9ExpressionEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end prio9Expression */

/**
 * $ANTLR start prio8Operator
 * D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScript.g:154:1: prio8Operator : '&' ;
 */
void
GeoGenScriptParser::prio8Operator()
{
        GeoGenScriptParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScript.g:154:14: ( '&' )
        // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScript.g:154:16: '&'
        {
             this->matchToken(OPERATOR_BIT_AND, &FOLLOW_OPERATOR_BIT_AND_in_prio8Operator798);
            if  (this->hasException())
            {
                goto ruleprio8OperatorEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleprio8OperatorEx; /* Prevent compiler warnings */
    ruleprio8OperatorEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end prio8Operator */

/**
 * $ANTLR start prio8Expression
 * D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScript.g:155:1: prio8Expression : prio7Expression ( prio8Operator prio7Expression )* ;
 */
void
GeoGenScriptParser::prio8Expression()
{
        GeoGenScriptParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScript.g:155:16: ( prio7Expression ( prio8Operator prio7Expression )* )
        // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScript.g:155:18: prio7Expression ( prio8Operator prio7Expression )*
        {
            this->followPush(FOLLOW_prio7Expression_in_prio8Expression804);
            prio7Expression();

            this->followPop();
            if  (this->hasException())
            {
                goto ruleprio8ExpressionEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScript.g:155:34: ( prio8Operator prio7Expression )*

            for (;;)
            {
                int alt34=2;
                switch ( this->LA(1) )
                {
                case OPERATOR_BIT_AND:
                	{
                		alt34=1;
                	}
                    break;

                }

                switch (alt34)
                {
            	case 1:
            	    // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScript.g:155:35: prio8Operator prio7Expression
            	    {
            	        this->followPush(FOLLOW_prio8Operator_in_prio8Expression807);
            	        prio8Operator();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleprio8ExpressionEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        this->followPush(FOLLOW_prio7Expression_in_prio8Expression809);
            	        prio7Expression();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleprio8ExpressionEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

            	default:
            	    goto loop34;	/* break out of the loop */
            	    break;
                }
            }
            loop34: ; /* Jump out to here if this rule does not match */


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleprio8ExpressionEx; /* Prevent compiler warnings */
    ruleprio8ExpressionEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end prio8Expression */

/**
 * $ANTLR start prio7Operator
 * D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScript.g:157:1: prio7Operator : ( '==' | '!=' );
 */
void
GeoGenScriptParser::prio7Operator()
{
        GeoGenScriptParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScript.g:157:14: ( '==' | '!=' )
        // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScript.g:
        {
            if ( this->LA(1) == OPERATOR_EQUAL_TO || this->LA(1) == OPERATOR_NOT_EQUAL_TO )
            {
                this->consume();
                this->set_perror_recovery(false);
                 this->set_failedflag(false); 

            }
            else
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                new ANTLR_Exception< GeoGenScriptParserImplTraits, MISMATCHED_SET_EXCEPTION, StreamType>( this->get_rec(), "" );
                this->get_exception()->set_expectingSet(NULL);

                goto ruleprio7OperatorEx;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleprio7OperatorEx; /* Prevent compiler warnings */
    ruleprio7OperatorEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end prio7Operator */

/**
 * $ANTLR start prio7Expression
 * D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScript.g:158:1: prio7Expression : prio6Expression ( prio7Operator prio6Expression )* ;
 */
void
GeoGenScriptParser::prio7Expression()
{
        GeoGenScriptParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScript.g:158:16: ( prio6Expression ( prio7Operator prio6Expression )* )
        // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScript.g:158:18: prio6Expression ( prio7Operator prio6Expression )*
        {
            this->followPush(FOLLOW_prio6Expression_in_prio7Expression828);
            prio6Expression();

            this->followPop();
            if  (this->hasException())
            {
                goto ruleprio7ExpressionEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScript.g:158:34: ( prio7Operator prio6Expression )*

            for (;;)
            {
                int alt35=2;
                switch ( this->LA(1) )
                {
                case OPERATOR_EQUAL_TO:
                case OPERATOR_NOT_EQUAL_TO:
                	{
                		alt35=1;
                	}
                    break;

                }

                switch (alt35)
                {
            	case 1:
            	    // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScript.g:158:35: prio7Operator prio6Expression
            	    {
            	        this->followPush(FOLLOW_prio7Operator_in_prio7Expression831);
            	        prio7Operator();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleprio7ExpressionEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        this->followPush(FOLLOW_prio6Expression_in_prio7Expression833);
            	        prio6Expression();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleprio7ExpressionEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

            	default:
            	    goto loop35;	/* break out of the loop */
            	    break;
                }
            }
            loop35: ; /* Jump out to here if this rule does not match */


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleprio7ExpressionEx; /* Prevent compiler warnings */
    ruleprio7ExpressionEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end prio7Expression */

/**
 * $ANTLR start prio6Operator
 * D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScript.g:160:1: prio6Operator : ( '<' | '<=' | '>' | '>=' );
 */
void
GeoGenScriptParser::prio6Operator()
{
        GeoGenScriptParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScript.g:160:14: ( '<' | '<=' | '>' | '>=' )
        // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScript.g:
        {
            if ( ((this->LA(1) >= OPERATOR_GREATER_THAN) && (this->LA(1) <= OPERATOR_GREATER_THAN_OR_EQUAL_TO)) || ((this->LA(1) >= OPERATOR_LESS_THAN) && (this->LA(1) <= OPERATOR_LESS_THAN_OR_EQUAL_TO)) )
            {
                this->consume();
                this->set_perror_recovery(false);
                 this->set_failedflag(false); 

            }
            else
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                new ANTLR_Exception< GeoGenScriptParserImplTraits, MISMATCHED_SET_EXCEPTION, StreamType>( this->get_rec(), "" );
                this->get_exception()->set_expectingSet(NULL);

                goto ruleprio6OperatorEx;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleprio6OperatorEx; /* Prevent compiler warnings */
    ruleprio6OperatorEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end prio6Operator */

/**
 * $ANTLR start prio6Expression
 * D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScript.g:161:1: prio6Expression : prio5Expression ( prio6Operator prio5Expression )* ;
 */
void
GeoGenScriptParser::prio6Expression()
{
        GeoGenScriptParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScript.g:161:16: ( prio5Expression ( prio6Operator prio5Expression )* )
        // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScript.g:161:18: prio5Expression ( prio6Operator prio5Expression )*
        {
            this->followPush(FOLLOW_prio5Expression_in_prio6Expression860);
            prio5Expression();

            this->followPop();
            if  (this->hasException())
            {
                goto ruleprio6ExpressionEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScript.g:161:34: ( prio6Operator prio5Expression )*

            for (;;)
            {
                int alt36=2;
                switch ( this->LA(1) )
                {
                case OPERATOR_GREATER_THAN:
                case OPERATOR_GREATER_THAN_OR_EQUAL_TO:
                case OPERATOR_LESS_THAN:
                case OPERATOR_LESS_THAN_OR_EQUAL_TO:
                	{
                		alt36=1;
                	}
                    break;

                }

                switch (alt36)
                {
            	case 1:
            	    // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScript.g:161:35: prio6Operator prio5Expression
            	    {
            	        this->followPush(FOLLOW_prio6Operator_in_prio6Expression863);
            	        prio6Operator();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleprio6ExpressionEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        this->followPush(FOLLOW_prio5Expression_in_prio6Expression865);
            	        prio5Expression();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleprio6ExpressionEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

            	default:
            	    goto loop36;	/* break out of the loop */
            	    break;
                }
            }
            loop36: ; /* Jump out to here if this rule does not match */


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleprio6ExpressionEx; /* Prevent compiler warnings */
    ruleprio6ExpressionEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end prio6Expression */

/**
 * $ANTLR start prio5Operator
 * D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScript.g:163:1: prio5Operator : ( '<<' | '>>' );
 */
void
GeoGenScriptParser::prio5Operator()
{
        GeoGenScriptParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScript.g:163:14: ( '<<' | '>>' )
        // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScript.g:
        {
            if ( this->LA(1) == OPERATOR_LSHIFT || this->LA(1) == OPERATOR_RSHIFT )
            {
                this->consume();
                this->set_perror_recovery(false);
                 this->set_failedflag(false); 

            }
            else
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                new ANTLR_Exception< GeoGenScriptParserImplTraits, MISMATCHED_SET_EXCEPTION, StreamType>( this->get_rec(), "" );
                this->get_exception()->set_expectingSet(NULL);

                goto ruleprio5OperatorEx;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleprio5OperatorEx; /* Prevent compiler warnings */
    ruleprio5OperatorEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end prio5Operator */

/**
 * $ANTLR start prio5Expression
 * D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScript.g:164:1: prio5Expression : prio4Expression ( prio5Operator prio4Expression )* ;
 */
void
GeoGenScriptParser::prio5Expression()
{
        GeoGenScriptParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScript.g:164:16: ( prio4Expression ( prio5Operator prio4Expression )* )
        // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScript.g:164:18: prio4Expression ( prio5Operator prio4Expression )*
        {
            this->followPush(FOLLOW_prio4Expression_in_prio5Expression884);
            prio4Expression();

            this->followPop();
            if  (this->hasException())
            {
                goto ruleprio5ExpressionEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScript.g:164:34: ( prio5Operator prio4Expression )*

            for (;;)
            {
                int alt37=2;
                switch ( this->LA(1) )
                {
                case OPERATOR_LSHIFT:
                case OPERATOR_RSHIFT:
                	{
                		alt37=1;
                	}
                    break;

                }

                switch (alt37)
                {
            	case 1:
            	    // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScript.g:164:35: prio5Operator prio4Expression
            	    {
            	        this->followPush(FOLLOW_prio5Operator_in_prio5Expression887);
            	        prio5Operator();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleprio5ExpressionEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        this->followPush(FOLLOW_prio4Expression_in_prio5Expression889);
            	        prio4Expression();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleprio5ExpressionEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

            	default:
            	    goto loop37;	/* break out of the loop */
            	    break;
                }
            }
            loop37: ; /* Jump out to here if this rule does not match */


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleprio5ExpressionEx; /* Prevent compiler warnings */
    ruleprio5ExpressionEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end prio5Expression */

/**
 * $ANTLR start prio4Operator
 * D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScript.g:166:1: prio4Operator : ( '+' | '-' );
 */
void
GeoGenScriptParser::prio4Operator()
{
        GeoGenScriptParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScript.g:166:14: ( '+' | '-' )
        // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScript.g:
        {
            if ( this->LA(1) == OPERATOR_MINUS || this->LA(1) == OPERATOR_PLUS )
            {
                this->consume();
                this->set_perror_recovery(false);
                 this->set_failedflag(false); 

            }
            else
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                new ANTLR_Exception< GeoGenScriptParserImplTraits, MISMATCHED_SET_EXCEPTION, StreamType>( this->get_rec(), "" );
                this->get_exception()->set_expectingSet(NULL);

                goto ruleprio4OperatorEx;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleprio4OperatorEx; /* Prevent compiler warnings */
    ruleprio4OperatorEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end prio4Operator */

/**
 * $ANTLR start prio4Expression
 * D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScript.g:167:1: prio4Expression : prio3Expression ( prio4Operator prio3Expression )* ;
 */
void
GeoGenScriptParser::prio4Expression()
{
        GeoGenScriptParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScript.g:167:16: ( prio3Expression ( prio4Operator prio3Expression )* )
        // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScript.g:167:18: prio3Expression ( prio4Operator prio3Expression )*
        {
            this->followPush(FOLLOW_prio3Expression_in_prio4Expression908);
            prio3Expression();

            this->followPop();
            if  (this->hasException())
            {
                goto ruleprio4ExpressionEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScript.g:167:34: ( prio4Operator prio3Expression )*

            for (;;)
            {
                int alt38=2;
                switch ( this->LA(1) )
                {
                case OPERATOR_MINUS:
                case OPERATOR_PLUS:
                	{
                		{
                		   /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
                		    */
                		    int LA38_18 = this->LA(2);
                		    if ( (this->msynpred( antlr3::ClassForwarder<synpred65_GeoGenScript>() )))
                		    {
                		        alt38=1;
                		    }

                		}
                	}
                    break;

                }

                switch (alt38)
                {
            	case 1:
            	    // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScript.g:167:35: prio4Operator prio3Expression
            	    {
            	        this->followPush(FOLLOW_prio4Operator_in_prio4Expression911);
            	        prio4Operator();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleprio4ExpressionEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        this->followPush(FOLLOW_prio3Expression_in_prio4Expression913);
            	        prio3Expression();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleprio4ExpressionEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

            	default:
            	    goto loop38;	/* break out of the loop */
            	    break;
                }
            }
            loop38: ; /* Jump out to here if this rule does not match */


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleprio4ExpressionEx; /* Prevent compiler warnings */
    ruleprio4ExpressionEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end prio4Expression */

/**
 * $ANTLR start prio3Operator
 * D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScript.g:169:1: prio3Operator : ( '*' | '/' | '%' );
 */
void
GeoGenScriptParser::prio3Operator()
{
        GeoGenScriptParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScript.g:169:14: ( '*' | '/' | '%' )
        // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScript.g:
        {
            if ( this->LA(1) == OPERATOR_DIVIDE || this->LA(1) == OPERATOR_MODULO || this->LA(1) == OPERATOR_TIMES )
            {
                this->consume();
                this->set_perror_recovery(false);
                 this->set_failedflag(false); 

            }
            else
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                new ANTLR_Exception< GeoGenScriptParserImplTraits, MISMATCHED_SET_EXCEPTION, StreamType>( this->get_rec(), "" );
                this->get_exception()->set_expectingSet(NULL);

                goto ruleprio3OperatorEx;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleprio3OperatorEx; /* Prevent compiler warnings */
    ruleprio3OperatorEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end prio3Operator */

/**
 * $ANTLR start prio3Expression
 * D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScript.g:170:1: prio3Expression : prio2Expression ( prio3Operator prio2Expression )* ;
 */
void
GeoGenScriptParser::prio3Expression()
{
        GeoGenScriptParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScript.g:170:16: ( prio2Expression ( prio3Operator prio2Expression )* )
        // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScript.g:170:18: prio2Expression ( prio3Operator prio2Expression )*
        {
            this->followPush(FOLLOW_prio2Expression_in_prio3Expression936);
            prio2Expression();

            this->followPop();
            if  (this->hasException())
            {
                goto ruleprio3ExpressionEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScript.g:170:34: ( prio3Operator prio2Expression )*

            for (;;)
            {
                int alt39=2;
                switch ( this->LA(1) )
                {
                case OPERATOR_DIVIDE:
                case OPERATOR_MODULO:
                case OPERATOR_TIMES:
                	{
                		alt39=1;
                	}
                    break;

                }

                switch (alt39)
                {
            	case 1:
            	    // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScript.g:170:35: prio3Operator prio2Expression
            	    {
            	        this->followPush(FOLLOW_prio3Operator_in_prio3Expression939);
            	        prio3Operator();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleprio3ExpressionEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        this->followPush(FOLLOW_prio2Expression_in_prio3Expression941);
            	        prio2Expression();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleprio3ExpressionEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

            	default:
            	    goto loop39;	/* break out of the loop */
            	    break;
                }
            }
            loop39: ; /* Jump out to here if this rule does not match */


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleprio3ExpressionEx; /* Prevent compiler warnings */
    ruleprio3ExpressionEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end prio3Expression */

/**
 * $ANTLR start prio2PrefixOperator
 * D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScript.g:172:1: prio2PrefixOperator : ( '++' | '--' | '!' | '+' | '-' );
 */
void
GeoGenScriptParser::prio2PrefixOperator()
{
        GeoGenScriptParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScript.g:172:20: ( '++' | '--' | '!' | '+' | '-' )
        // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScript.g:
        {
            if ( this->LA(1) == OPERATOR_DECREMENT || this->LA(1) == OPERATOR_INCREMENT || this->LA(1) == OPERATOR_MINUS || this->LA(1) == OPERATOR_NOT || this->LA(1) == OPERATOR_PLUS )
            {
                this->consume();
                this->set_perror_recovery(false);
                 this->set_failedflag(false); 

            }
            else
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                new ANTLR_Exception< GeoGenScriptParserImplTraits, MISMATCHED_SET_EXCEPTION, StreamType>( this->get_rec(), "" );
                this->get_exception()->set_expectingSet(NULL);

                goto ruleprio2PrefixOperatorEx;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleprio2PrefixOperatorEx; /* Prevent compiler warnings */
    ruleprio2PrefixOperatorEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end prio2PrefixOperator */

/**
 * $ANTLR start prio2PostfixOperator
 * D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScript.g:173:1: prio2PostfixOperator : ( '++' | '--' );
 */
void
GeoGenScriptParser::prio2PostfixOperator()
{
        GeoGenScriptParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScript.g:173:21: ( '++' | '--' )
        // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScript.g:
        {
            if ( this->LA(1) == OPERATOR_DECREMENT || this->LA(1) == OPERATOR_INCREMENT )
            {
                this->consume();
                this->set_perror_recovery(false);
                 this->set_failedflag(false); 

            }
            else
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                new ANTLR_Exception< GeoGenScriptParserImplTraits, MISMATCHED_SET_EXCEPTION, StreamType>( this->get_rec(), "" );
                this->get_exception()->set_expectingSet(NULL);

                goto ruleprio2PostfixOperatorEx;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleprio2PostfixOperatorEx; /* Prevent compiler warnings */
    ruleprio2PostfixOperatorEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end prio2PostfixOperator */

/**
 * $ANTLR start prio2Expression
 * D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScript.g:174:1: prio2Expression : ( prio2PrefixOperator )* prio1Expression ( prio2PostfixOperator )* ;
 */
void
GeoGenScriptParser::prio2Expression()
{
        GeoGenScriptParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScript.g:174:16: ( ( prio2PrefixOperator )* prio1Expression ( prio2PostfixOperator )* )
        // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScript.g:174:18: ( prio2PrefixOperator )* prio1Expression ( prio2PostfixOperator )*
        {
            // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScript.g:174:18: ( prio2PrefixOperator )*

            for (;;)
            {
                int alt40=2;
                switch ( this->LA(1) )
                {
                case OPERATOR_DECREMENT:
                case OPERATOR_INCREMENT:
                case OPERATOR_MINUS:
                case OPERATOR_NOT:
                case OPERATOR_PLUS:
                	{
                		alt40=1;
                	}
                    break;

                }

                switch (alt40)
                {
            	case 1:
            	    // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScript.g:174:18: prio2PrefixOperator
            	    {
            	        this->followPush(FOLLOW_prio2PrefixOperator_in_prio2Expression982);
            	        prio2PrefixOperator();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleprio2ExpressionEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

            	default:
            	    goto loop40;	/* break out of the loop */
            	    break;
                }
            }
            loop40: ; /* Jump out to here if this rule does not match */


            this->followPush(FOLLOW_prio1Expression_in_prio2Expression985);
            prio1Expression();

            this->followPop();
            if  (this->hasException())
            {
                goto ruleprio2ExpressionEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScript.g:174:55: ( prio2PostfixOperator )*

            for (;;)
            {
                int alt41=2;
                switch ( this->LA(1) )
                {
                case OPERATOR_DECREMENT:
                case OPERATOR_INCREMENT:
                	{
                		{
                		   /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
                		    */
                		    int LA41_2 = this->LA(2);
                		    if ( (this->msynpred( antlr3::ClassForwarder<synpred75_GeoGenScript>() )))
                		    {
                		        alt41=1;
                		    }

                		}
                	}
                    break;

                }

                switch (alt41)
                {
            	case 1:
            	    // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScript.g:174:55: prio2PostfixOperator
            	    {
            	        this->followPush(FOLLOW_prio2PostfixOperator_in_prio2Expression987);
            	        prio2PostfixOperator();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleprio2ExpressionEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

            	default:
            	    goto loop41;	/* break out of the loop */
            	    break;
                }
            }
            loop41: ; /* Jump out to here if this rule does not match */


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleprio2ExpressionEx; /* Prevent compiler warnings */
    ruleprio2ExpressionEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end prio2Expression */

/**
 * $ANTLR start prio1Expression
 * D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScript.g:176:1: prio1Expression : prio0Expression ( '.' prio0Expression | '(' ( expression ( ',' expression )* )? ')' | '[' expression ( ',' expression )* ']' )* ;
 */
void
GeoGenScriptParser::prio1Expression()
{
        GeoGenScriptParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScript.g:176:16: ( prio0Expression ( '.' prio0Expression | '(' ( expression ( ',' expression )* )? ')' | '[' expression ( ',' expression )* ']' )* )
        // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScript.g:177:5: prio0Expression ( '.' prio0Expression | '(' ( expression ( ',' expression )* )? ')' | '[' expression ( ',' expression )* ']' )*
        {
            this->followPush(FOLLOW_prio0Expression_in_prio1Expression1002);
            prio0Expression();

            this->followPop();
            if  (this->hasException())
            {
                goto ruleprio1ExpressionEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScript.g:177:21: ( '.' prio0Expression | '(' ( expression ( ',' expression )* )? ')' | '[' expression ( ',' expression )* ']' )*

            for (;;)
            {
                int alt45=4;
                switch ( this->LA(1) )
                {
                case LEFT_SQUARE_BRACKET:
                	{
                		{
                		   /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
                		    */
                		    int LA45_25 = this->LA(2);
                		    if ( (this->msynpred( antlr3::ClassForwarder<synpred81_GeoGenScript>() )))
                		    {
                		        alt45=3;
                		    }

                		}
                	}
                    break;
                case LEFT_BRACKET:
                	{
                		{
                		   /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
                		    */
                		    int LA45_27 = this->LA(2);
                		    if ( (this->msynpred( antlr3::ClassForwarder<synpred79_GeoGenScript>() )))
                		    {
                		        alt45=2;
                		    }

                		}
                	}
                    break;
                case OPERATOR_DOT:
                	{
                		alt45=1;
                	}
                    break;

                }

                switch (alt45)
                {
            	case 1:
            	    // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScript.g:178:9: '.' prio0Expression
            	    {
            	         this->matchToken(OPERATOR_DOT, &FOLLOW_OPERATOR_DOT_in_prio1Expression1014);
            	        if  (this->hasException())
            	        {
            	            goto ruleprio1ExpressionEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        this->followPush(FOLLOW_prio0Expression_in_prio1Expression1016);
            	        prio0Expression();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleprio1ExpressionEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;
            	case 2:
            	    // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScript.g:179:9: '(' ( expression ( ',' expression )* )? ')'
            	    {
            	         this->matchToken(LEFT_BRACKET, &FOLLOW_LEFT_BRACKET_in_prio1Expression1028);
            	        if  (this->hasException())
            	        {
            	            goto ruleprio1ExpressionEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScript.g:179:13: ( expression ( ',' expression )* )?
            	        {
            	            int alt43=2;
            	            switch ( this->LA(1) )
            	            {
            	                case AT:
            	                case FALSE_LIT:
            	                case IDENTIFIER:
            	                case LEFT_BRACKET:
            	                case LEFT_CURLY_BRACKET:
            	                case LEFT_SQUARE_BRACKET:
            	                case NUMBER:
            	                case OPERATOR_DECREMENT:
            	                case OPERATOR_INCREMENT:
            	                case OPERATOR_MINUS:
            	                case OPERATOR_NOT:
            	                case OPERATOR_PLUS:
            	                case STRING:
            	                case TRUE_LIT:
            	                	{
            	                		alt43=1;
            	                	}
            	                    break;
            	            }

            	            switch (alt43)
            	            {
            	        	case 1:
            	        	    // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScript.g:179:14: expression ( ',' expression )*
            	        	    {
            	        	        this->followPush(FOLLOW_expression_in_prio1Expression1031);
            	        	        expression();

            	        	        this->followPop();
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto ruleprio1ExpressionEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return ;
            	        	        }


            	        	        // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScript.g:179:25: ( ',' expression )*

            	        	        for (;;)
            	        	        {
            	        	            int alt42=2;
            	        	            switch ( this->LA(1) )
            	        	            {
            	        	            case COMMA:
            	        	            	{
            	        	            		alt42=1;
            	        	            	}
            	        	                break;

            	        	            }

            	        	            switch (alt42)
            	        	            {
            	        	        	case 1:
            	        	        	    // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScript.g:179:26: ',' expression
            	        	        	    {
            	        	        	         this->matchToken(COMMA, &FOLLOW_COMMA_in_prio1Expression1034);
            	        	        	        if  (this->hasException())
            	        	        	        {
            	        	        	            goto ruleprio1ExpressionEx;
            	        	        	        }
            	        	        	        if (this->hasFailed())
            	        	        	        {
            	        	        	            return ;
            	        	        	        }


            	        	        	        this->followPush(FOLLOW_expression_in_prio1Expression1036);
            	        	        	        expression();

            	        	        	        this->followPop();
            	        	        	        if  (this->hasException())
            	        	        	        {
            	        	        	            goto ruleprio1ExpressionEx;
            	        	        	        }
            	        	        	        if (this->hasFailed())
            	        	        	        {
            	        	        	            return ;
            	        	        	        }


            	        	        	    }
            	        	        	    break;

            	        	        	default:
            	        	        	    goto loop42;	/* break out of the loop */
            	        	        	    break;
            	        	            }
            	        	        }
            	        	        loop42: ; /* Jump out to here if this rule does not match */


            	        	    }
            	        	    break;

            	            }
            	        }

            	         this->matchToken(RIGHT_BRACKET, &FOLLOW_RIGHT_BRACKET_in_prio1Expression1042);
            	        if  (this->hasException())
            	        {
            	            goto ruleprio1ExpressionEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;
            	case 3:
            	    // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScript.g:180:9: '[' expression ( ',' expression )* ']'
            	    {
            	         this->matchToken(LEFT_SQUARE_BRACKET, &FOLLOW_LEFT_SQUARE_BRACKET_in_prio1Expression1054);
            	        if  (this->hasException())
            	        {
            	            goto ruleprio1ExpressionEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        this->followPush(FOLLOW_expression_in_prio1Expression1056);
            	        expression();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto ruleprio1ExpressionEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScript.g:180:24: ( ',' expression )*

            	        for (;;)
            	        {
            	            int alt44=2;
            	            switch ( this->LA(1) )
            	            {
            	            case COMMA:
            	            	{
            	            		alt44=1;
            	            	}
            	                break;

            	            }

            	            switch (alt44)
            	            {
            	        	case 1:
            	        	    // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScript.g:180:25: ',' expression
            	        	    {
            	        	         this->matchToken(COMMA, &FOLLOW_COMMA_in_prio1Expression1059);
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto ruleprio1ExpressionEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return ;
            	        	        }


            	        	        this->followPush(FOLLOW_expression_in_prio1Expression1061);
            	        	        expression();

            	        	        this->followPop();
            	        	        if  (this->hasException())
            	        	        {
            	        	            goto ruleprio1ExpressionEx;
            	        	        }
            	        	        if (this->hasFailed())
            	        	        {
            	        	            return ;
            	        	        }


            	        	    }
            	        	    break;

            	        	default:
            	        	    goto loop44;	/* break out of the loop */
            	        	    break;
            	            }
            	        }
            	        loop44: ; /* Jump out to here if this rule does not match */


            	         this->matchToken(RIGHT_SQUARE_BRACKET, &FOLLOW_RIGHT_SQUARE_BRACKET_in_prio1Expression1065);
            	        if  (this->hasException())
            	        {
            	            goto ruleprio1ExpressionEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

            	default:
            	    goto loop45;	/* break out of the loop */
            	    break;
                }
            }
            loop45: ; /* Jump out to here if this rule does not match */


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleprio1ExpressionEx; /* Prevent compiler warnings */
    ruleprio1ExpressionEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end prio1Expression */

/**
 * $ANTLR start prio0Expression
 * D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScript.g:183:1: prio0Expression : ( IDENTIFIER | collectionLiteral | coordinateLiteral | literal | '(' expression ')' );
 */
void
GeoGenScriptParser::prio0Expression()
{
        GeoGenScriptParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        {
            //  D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScript.g:183:16: ( IDENTIFIER | collectionLiteral | coordinateLiteral | literal | '(' expression ')' )

            ANTLR_UINT32 alt46;

            alt46=5;

            switch ( this->LA(1) )
            {
            case IDENTIFIER:
            	{
            		alt46=1;
            	}
                break;
            case LEFT_CURLY_BRACKET:
            	{
            		alt46=2;
            	}
                break;
            case AT:
            case LEFT_SQUARE_BRACKET:
            	{
            		alt46=3;
            	}
                break;
            case FALSE_LIT:
            case NUMBER:
            case STRING:
            case TRUE_LIT:
            	{
            		alt46=4;
            	}
                break;
            case LEFT_BRACKET:
            	{
            		alt46=5;
            	}
                break;

            default:
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                ExceptionBaseType* ex = new ANTLR_Exception< GeoGenScriptParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                ex->set_decisionNum( 46 );
                ex->set_state( 0 );


                goto ruleprio0ExpressionEx;

            }

            switch (alt46)
            {
        	case 1:
        	    // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScript.g:184:5: IDENTIFIER
        	    {
        	         this->matchToken(IDENTIFIER, &FOLLOW_IDENTIFIER_in_prio0Expression1084);
        	        if  (this->hasException())
        	        {
        	            goto ruleprio0ExpressionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 2:
        	    // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScript.g:185:5: collectionLiteral
        	    {
        	        this->followPush(FOLLOW_collectionLiteral_in_prio0Expression1092);
        	        collectionLiteral();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruleprio0ExpressionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 3:
        	    // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScript.g:186:5: coordinateLiteral
        	    {
        	        this->followPush(FOLLOW_coordinateLiteral_in_prio0Expression1100);
        	        coordinateLiteral();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruleprio0ExpressionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 4:
        	    // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScript.g:187:5: literal
        	    {
        	        this->followPush(FOLLOW_literal_in_prio0Expression1108);
        	        literal();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruleprio0ExpressionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 5:
        	    // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScript.g:188:5: '(' expression ')'
        	    {
        	         this->matchToken(LEFT_BRACKET, &FOLLOW_LEFT_BRACKET_in_prio0Expression1116);
        	        if  (this->hasException())
        	        {
        	            goto ruleprio0ExpressionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	        this->followPush(FOLLOW_expression_in_prio0Expression1118);
        	        expression();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto ruleprio0ExpressionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	         this->matchToken(RIGHT_BRACKET, &FOLLOW_RIGHT_BRACKET_in_prio0Expression1120);
        	        if  (this->hasException())
        	        {
        	            goto ruleprio0ExpressionEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;

            }
        }
    }
    // This is where rules clean up and exit
    //
    goto ruleprio0ExpressionEx; /* Prevent compiler warnings */
    ruleprio0ExpressionEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end prio0Expression */

/**
 * $ANTLR start collectionLiteral
 * D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScript.g:191:1: collectionLiteral : ( keyValueCollection | unkeyedCollectionLiteral );
 */
void
GeoGenScriptParser::collectionLiteral()
{
        GeoGenScriptParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        {
            //  D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScript.g:191:18: ( keyValueCollection | unkeyedCollectionLiteral )

            ANTLR_UINT32 alt47;

            alt47=2;

            switch ( this->LA(1) )
            {
            case LEFT_CURLY_BRACKET:
            	{
            		switch ( this->LA(2) )
            		{
            		case IDENTIFIER:
            			{
            				switch ( this->LA(3) )
            				{
            				case COLON:
            					{
            						alt47=1;
            					}
            				    break;
            				case AT:
            				case COMMA:
            				case FALSE_LIT:
            				case IDENTIFIER:
            				case LEFT_BRACKET:
            				case LEFT_CURLY_BRACKET:
            				case LEFT_SQUARE_BRACKET:
            				case NUMBER:
            				case OPERATOR_ASSIGN:
            				case OPERATOR_ASSIGN_AND:
            				case OPERATOR_ASSIGN_DIVIDE:
            				case OPERATOR_ASSIGN_LSHIFT:
            				case OPERATOR_ASSIGN_MINUS:
            				case OPERATOR_ASSIGN_MODULO:
            				case OPERATOR_ASSIGN_PLUS:
            				case OPERATOR_ASSIGN_RSHIFT:
            				case OPERATOR_ASSIGN_TIMES:
            				case OPERATOR_ASSIGN_XOR:
            				case OPERATOR_BIT_AND:
            				case OPERATOR_BIT_OR:
            				case OPERATOR_BIT_XOR:
            				case OPERATOR_DECREMENT:
            				case OPERATOR_DIVIDE:
            				case OPERATOR_DOT:
            				case OPERATOR_EQUAL_TO:
            				case OPERATOR_EXPR_IF:
            				case OPERATOR_GREATER_THAN:
            				case OPERATOR_GREATER_THAN_OR_EQUAL_TO:
            				case OPERATOR_INCREMENT:
            				case OPERATOR_IS:
            				case OPERATOR_LESS_THAN:
            				case OPERATOR_LESS_THAN_OR_EQUAL_TO:
            				case OPERATOR_LSHIFT:
            				case OPERATOR_MINUS:
            				case OPERATOR_MODULO:
            				case OPERATOR_NOT:
            				case OPERATOR_NOT_EQUAL_TO:
            				case OPERATOR_PLUS:
            				case OPERATOR_REL_AND:
            				case OPERATOR_REL_OR:
            				case OPERATOR_RSHIFT:
            				case OPERATOR_TIMES:
            				case RIGTH_CURLY_BRACKET:
            				case STRING:
            				case TRUE_LIT:
            					{
            						alt47=2;
            					}
            				    break;

            				default:
            				    if (this->get_backtracking()>0)
            				    {
            				        this->set_failedflag( true );
            				        return ;
            				    }

            				    ExceptionBaseType* ex = new ANTLR_Exception< GeoGenScriptParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
            				    ex->set_decisionNum( 47 );
            				    ex->set_state( 2 );


            				    goto rulecollectionLiteralEx;

            				}

            			}
            		    break;
            		case AT:
            			{
            				switch ( this->LA(3) )
            				{
            				case NUMBER:
            					{
            						alt47=1;
            					}
            				    break;
            				case LEFT_SQUARE_BRACKET:
            					{
            						alt47=2;
            					}
            				    break;

            				default:
            				    if (this->get_backtracking()>0)
            				    {
            				        this->set_failedflag( true );
            				        return ;
            				    }

            				    ExceptionBaseType* ex = new ANTLR_Exception< GeoGenScriptParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
            				    ex->set_decisionNum( 47 );
            				    ex->set_state( 3 );


            				    goto rulecollectionLiteralEx;

            				}

            			}
            		    break;
            		case NUMBER:
            			{
            				switch ( this->LA(3) )
            				{
            				case COLON:
            					{
            						alt47=1;
            					}
            				    break;
            				case AT:
            				case COMMA:
            				case FALSE_LIT:
            				case IDENTIFIER:
            				case LEFT_BRACKET:
            				case LEFT_CURLY_BRACKET:
            				case LEFT_SQUARE_BRACKET:
            				case NUMBER:
            				case OPERATOR_ASSIGN:
            				case OPERATOR_ASSIGN_AND:
            				case OPERATOR_ASSIGN_DIVIDE:
            				case OPERATOR_ASSIGN_LSHIFT:
            				case OPERATOR_ASSIGN_MINUS:
            				case OPERATOR_ASSIGN_MODULO:
            				case OPERATOR_ASSIGN_PLUS:
            				case OPERATOR_ASSIGN_RSHIFT:
            				case OPERATOR_ASSIGN_TIMES:
            				case OPERATOR_ASSIGN_XOR:
            				case OPERATOR_BIT_AND:
            				case OPERATOR_BIT_OR:
            				case OPERATOR_BIT_XOR:
            				case OPERATOR_DECREMENT:
            				case OPERATOR_DIVIDE:
            				case OPERATOR_DOT:
            				case OPERATOR_EQUAL_TO:
            				case OPERATOR_EXPR_IF:
            				case OPERATOR_GREATER_THAN:
            				case OPERATOR_GREATER_THAN_OR_EQUAL_TO:
            				case OPERATOR_INCREMENT:
            				case OPERATOR_IS:
            				case OPERATOR_LESS_THAN:
            				case OPERATOR_LESS_THAN_OR_EQUAL_TO:
            				case OPERATOR_LSHIFT:
            				case OPERATOR_MINUS:
            				case OPERATOR_MODULO:
            				case OPERATOR_NOT:
            				case OPERATOR_NOT_EQUAL_TO:
            				case OPERATOR_PLUS:
            				case OPERATOR_REL_AND:
            				case OPERATOR_REL_OR:
            				case OPERATOR_RSHIFT:
            				case OPERATOR_TIMES:
            				case RIGTH_CURLY_BRACKET:
            				case STRING:
            				case TRUE_LIT:
            					{
            						alt47=2;
            					}
            				    break;

            				default:
            				    if (this->get_backtracking()>0)
            				    {
            				        this->set_failedflag( true );
            				        return ;
            				    }

            				    ExceptionBaseType* ex = new ANTLR_Exception< GeoGenScriptParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
            				    ex->set_decisionNum( 47 );
            				    ex->set_state( 4 );


            				    goto rulecollectionLiteralEx;

            				}

            			}
            		    break;
            		case RIGTH_CURLY_BRACKET:
            			{
            				alt47=1;
            			}
            		    break;
            		case FALSE_LIT:
            		case LEFT_BRACKET:
            		case LEFT_CURLY_BRACKET:
            		case LEFT_SQUARE_BRACKET:
            		case OPERATOR_DECREMENT:
            		case OPERATOR_INCREMENT:
            		case OPERATOR_MINUS:
            		case OPERATOR_NOT:
            		case OPERATOR_PLUS:
            		case STRING:
            		case TRUE_LIT:
            			{
            				alt47=2;
            			}
            		    break;

            		default:
            		    if (this->get_backtracking()>0)
            		    {
            		        this->set_failedflag( true );
            		        return ;
            		    }

            		    ExceptionBaseType* ex = new ANTLR_Exception< GeoGenScriptParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
            		    ex->set_decisionNum( 47 );
            		    ex->set_state( 1 );


            		    goto rulecollectionLiteralEx;

            		}

            	}
                break;

            default:
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                ExceptionBaseType* ex = new ANTLR_Exception< GeoGenScriptParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                ex->set_decisionNum( 47 );
                ex->set_state( 0 );


                goto rulecollectionLiteralEx;

            }

            switch (alt47)
            {
        	case 1:
        	    // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScript.g:192:5: keyValueCollection
        	    {
        	        this->followPush(FOLLOW_keyValueCollection_in_collectionLiteral1133);
        	        keyValueCollection();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulecollectionLiteralEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;
        	case 2:
        	    // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScript.g:193:5: unkeyedCollectionLiteral
        	    {
        	        this->followPush(FOLLOW_unkeyedCollectionLiteral_in_collectionLiteral1141);
        	        unkeyedCollectionLiteral();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulecollectionLiteralEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;

            }
        }
    }
    // This is where rules clean up and exit
    //
    goto rulecollectionLiteralEx; /* Prevent compiler warnings */
    rulecollectionLiteralEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end collectionLiteral */

/**
 * $ANTLR start unkeyedCollectionLiteral
 * D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScript.g:195:1: unkeyedCollectionLiteral : '{' ( ( expression )+ ( ',' expression )* ) '}' ;
 */
void
GeoGenScriptParser::unkeyedCollectionLiteral()
{
        GeoGenScriptParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScript.g:195:25: ( '{' ( ( expression )+ ( ',' expression )* ) '}' )
        // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScript.g:196:5: '{' ( ( expression )+ ( ',' expression )* ) '}'
        {
             this->matchToken(LEFT_CURLY_BRACKET, &FOLLOW_LEFT_CURLY_BRACKET_in_unkeyedCollectionLiteral1152);
            if  (this->hasException())
            {
                goto ruleunkeyedCollectionLiteralEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScript.g:196:9: ( ( expression )+ ( ',' expression )* )
            // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScript.g:196:10: ( expression )+ ( ',' expression )*
            {
                // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScript.g:196:10: ( expression )+
                {
                    int cnt48=0;

                    for (;;)
                    {
                        int alt48=2;
                	switch ( this->LA(1) )
                	{
                	case AT:
                	case FALSE_LIT:
                	case IDENTIFIER:
                	case LEFT_BRACKET:
                	case LEFT_CURLY_BRACKET:
                	case LEFT_SQUARE_BRACKET:
                	case NUMBER:
                	case OPERATOR_DECREMENT:
                	case OPERATOR_INCREMENT:
                	case OPERATOR_MINUS:
                	case OPERATOR_NOT:
                	case OPERATOR_PLUS:
                	case STRING:
                	case TRUE_LIT:
                		{
                			alt48=1;
                		}
                	    break;

                	}

                	switch (alt48)
                	{
                	    case 1:
                	        // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScript.g:196:10: expression
                	        {
                	            this->followPush(FOLLOW_expression_in_unkeyedCollectionLiteral1155);
                	            expression();

                	            this->followPop();
                	            if  (this->hasException())
                	            {
                	                goto ruleunkeyedCollectionLiteralEx;
                	            }
                	            if (this->hasFailed())
                	            {
                	                return ;
                	            }


                	        }
                	        break;

                	    default:

                		if ( cnt48 >= 1 )
                		{
                		    goto loop48;
                		}
                		if (this->get_backtracking()>0)
                		{
                		    this->set_failedflag( true );
                		    return ;
                		}

                		/* mismatchedSetEx()
                		 */
                		new ANTLR_Exception< GeoGenScriptParserImplTraits, EARLY_EXIT_EXCEPTION, StreamType>( this->get_rec(), "" );


                		goto ruleunkeyedCollectionLiteralEx;
                	}
                	cnt48++;
                    }
                    loop48: ;	/* Jump to here if this rule does not match */
                }

                // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScript.g:196:23: ( ',' expression )*

                for (;;)
                {
                    int alt49=2;
                    switch ( this->LA(1) )
                    {
                    case COMMA:
                    	{
                    		alt49=1;
                    	}
                        break;

                    }

                    switch (alt49)
                    {
                	case 1:
                	    // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScript.g:196:24: ',' expression
                	    {
                	         this->matchToken(COMMA, &FOLLOW_COMMA_in_unkeyedCollectionLiteral1160);
                	        if  (this->hasException())
                	        {
                	            goto ruleunkeyedCollectionLiteralEx;
                	        }
                	        if (this->hasFailed())
                	        {
                	            return ;
                	        }


                	        this->followPush(FOLLOW_expression_in_unkeyedCollectionLiteral1162);
                	        expression();

                	        this->followPop();
                	        if  (this->hasException())
                	        {
                	            goto ruleunkeyedCollectionLiteralEx;
                	        }
                	        if (this->hasFailed())
                	        {
                	            return ;
                	        }


                	    }
                	    break;

                	default:
                	    goto loop49;	/* break out of the loop */
                	    break;
                    }
                }
                loop49: ; /* Jump out to here if this rule does not match */


            }


             this->matchToken(RIGTH_CURLY_BRACKET, &FOLLOW_RIGTH_CURLY_BRACKET_in_unkeyedCollectionLiteral1167);
            if  (this->hasException())
            {
                goto ruleunkeyedCollectionLiteralEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleunkeyedCollectionLiteralEx; /* Prevent compiler warnings */
    ruleunkeyedCollectionLiteralEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end unkeyedCollectionLiteral */

/**
 * $ANTLR start coordinateLiteral
 * D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScript.g:198:1: coordinateLiteral : ( '@' )? '[' expression ( ',' expression )* ']' ;
 */
void
GeoGenScriptParser::coordinateLiteral()
{
        GeoGenScriptParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScript.g:198:18: ( ( '@' )? '[' expression ( ',' expression )* ']' )
        // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScript.g:199:5: ( '@' )? '[' expression ( ',' expression )* ']'
        {
            // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScript.g:199:5: ( '@' )?
            {
                int alt50=2;
                switch ( this->LA(1) )
                {
                    case AT:
                    	{
                    		alt50=1;
                    	}
                        break;
                }

                switch (alt50)
                {
            	case 1:
            	    // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScript.g:199:5: '@'
            	    {
            	         this->matchToken(AT, &FOLLOW_AT_in_coordinateLiteral1178);
            	        if  (this->hasException())
            	        {
            	            goto rulecoordinateLiteralEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

                }
            }

             this->matchToken(LEFT_SQUARE_BRACKET, &FOLLOW_LEFT_SQUARE_BRACKET_in_coordinateLiteral1181);
            if  (this->hasException())
            {
                goto rulecoordinateLiteralEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            this->followPush(FOLLOW_expression_in_coordinateLiteral1183);
            expression();

            this->followPop();
            if  (this->hasException())
            {
                goto rulecoordinateLiteralEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


            // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScript.g:199:25: ( ',' expression )*

            for (;;)
            {
                int alt51=2;
                switch ( this->LA(1) )
                {
                case COMMA:
                	{
                		alt51=1;
                	}
                    break;

                }

                switch (alt51)
                {
            	case 1:
            	    // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScript.g:199:26: ',' expression
            	    {
            	         this->matchToken(COMMA, &FOLLOW_COMMA_in_coordinateLiteral1186);
            	        if  (this->hasException())
            	        {
            	            goto rulecoordinateLiteralEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	        this->followPush(FOLLOW_expression_in_coordinateLiteral1188);
            	        expression();

            	        this->followPop();
            	        if  (this->hasException())
            	        {
            	            goto rulecoordinateLiteralEx;
            	        }
            	        if (this->hasFailed())
            	        {
            	            return ;
            	        }


            	    }
            	    break;

            	default:
            	    goto loop51;	/* break out of the loop */
            	    break;
                }
            }
            loop51: ; /* Jump out to here if this rule does not match */


             this->matchToken(RIGHT_SQUARE_BRACKET, &FOLLOW_RIGHT_SQUARE_BRACKET_in_coordinateLiteral1192);
            if  (this->hasException())
            {
                goto rulecoordinateLiteralEx;
            }
            if (this->hasFailed())
            {
                return ;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto rulecoordinateLiteralEx; /* Prevent compiler warnings */
    rulecoordinateLiteralEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end coordinateLiteral */

/**
 * $ANTLR start label
 * D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScript.g:201:1: label : ( IDENTIFIER ( '.' IDENTIFIER )* | literal );
 */
void
GeoGenScriptParser::label()
{
        GeoGenScriptParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        {
            //  D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScript.g:201:6: ( IDENTIFIER ( '.' IDENTIFIER )* | literal )

            ANTLR_UINT32 alt53;

            alt53=2;

            switch ( this->LA(1) )
            {
            case IDENTIFIER:
            	{
            		alt53=1;
            	}
                break;
            case FALSE_LIT:
            case NUMBER:
            case STRING:
            case TRUE_LIT:
            	{
            		alt53=2;
            	}
                break;

            default:
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                ExceptionBaseType* ex = new ANTLR_Exception< GeoGenScriptParserImplTraits, NO_VIABLE_ALT_EXCEPTION, StreamType>( this->get_rec(), "" );
                ex->set_decisionNum( 53 );
                ex->set_state( 0 );


                goto rulelabelEx;

            }

            switch (alt53)
            {
        	case 1:
        	    // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScript.g:202:2: IDENTIFIER ( '.' IDENTIFIER )*
        	    {
        	         this->matchToken(IDENTIFIER, &FOLLOW_IDENTIFIER_in_label1208);
        	        if  (this->hasException())
        	        {
        	            goto rulelabelEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	        // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScript.g:202:13: ( '.' IDENTIFIER )*

        	        for (;;)
        	        {
        	            int alt52=2;
        	            switch ( this->LA(1) )
        	            {
        	            case OPERATOR_DOT:
        	            	{
        	            		alt52=1;
        	            	}
        	                break;

        	            }

        	            switch (alt52)
        	            {
        	        	case 1:
        	        	    // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScript.g:202:14: '.' IDENTIFIER
        	        	    {
        	        	         this->matchToken(OPERATOR_DOT, &FOLLOW_OPERATOR_DOT_in_label1211);
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulelabelEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	         this->matchToken(IDENTIFIER, &FOLLOW_IDENTIFIER_in_label1213);
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulelabelEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	    }
        	        	    break;

        	        	default:
        	        	    goto loop52;	/* break out of the loop */
        	        	    break;
        	            }
        	        }
        	        loop52: ; /* Jump out to here if this rule does not match */


        	    }
        	    break;
        	case 2:
        	    // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScript.g:203:2: literal
        	    {
        	        this->followPush(FOLLOW_literal_in_label1220);
        	        literal();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulelabelEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;

            }
        }
    }
    // This is where rules clean up and exit
    //
    goto rulelabelEx; /* Prevent compiler warnings */
    rulelabelEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end label */

/**
 * $ANTLR start literal
 * D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScript.g:205:1: literal : ( 'true' | 'false' | NUMBER | STRING );
 */
void
GeoGenScriptParser::literal()
{
        GeoGenScriptParserImplTraits::RuleReturnValueType _antlr_rule_exit(this);
      

    /* Initialize rule variables
     */


 
    {
        // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScript.g:205:8: ( 'true' | 'false' | NUMBER | STRING )
        // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScript.g:
        {
            if ( this->LA(1) == FALSE_LIT || this->LA(1) == NUMBER || this->LA(1) == STRING || this->LA(1) == TRUE_LIT )
            {
                this->consume();
                this->set_perror_recovery(false);
                 this->set_failedflag(false); 

            }
            else
            {
                if (this->get_backtracking()>0)
                {
                    this->set_failedflag( true );
                    return ;
                }

                new ANTLR_Exception< GeoGenScriptParserImplTraits, MISMATCHED_SET_EXCEPTION, StreamType>( this->get_rec(), "" );
                this->get_exception()->set_expectingSet(NULL);

                goto ruleliteralEx;
            }


        }

    }
    // This is where rules clean up and exit
    //
    goto ruleliteralEx; /* Prevent compiler warnings */
    ruleliteralEx: ;


    	if (this->hasException())
        {
            this->preporterror();
            this->precover();
        }
    return ;
}
/* $ANTLR end literal */

// $ANTLR start synpred1_GeoGenScript
void GeoGenScriptParser::msynpred1_GeoGenScript_fragment(  )
{
    // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScript.g:66:9: ( declaration )
    // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScript.g:66:9: declaration
    {
        this->followPush(FOLLOW_declaration_in_synpred1_GeoGenScript80);
        declaration();

        this->followPop();
        if  (this->hasException())
        {
            goto rulesynpred1_GeoGenScriptEx;
        }
        if (this->hasFailed())
        {
            return ;
        }


    }

// This is where rules clean up and exit
//
goto rulesynpred1_GeoGenScriptEx; /* Prevent compiler warnings */
rulesynpred1_GeoGenScriptEx: ;

}
// $ANTLR end synpred1_GeoGenScript

// $ANTLR start synpred9_GeoGenScript
void GeoGenScriptParser::msynpred9_GeoGenScript_fragment(  )
{
    // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScript.g:74:16: ( expression )
    // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScript.g:74:16: expression
    {
        this->followPush(FOLLOW_expression_in_synpred9_GeoGenScript164);
        expression();

        this->followPop();
        if  (this->hasException())
        {
            goto rulesynpred9_GeoGenScriptEx;
        }
        if (this->hasFailed())
        {
            return ;
        }


    }

// This is where rules clean up and exit
//
goto rulesynpred9_GeoGenScriptEx; /* Prevent compiler warnings */
rulesynpred9_GeoGenScriptEx: ;

}
// $ANTLR end synpred9_GeoGenScript

// $ANTLR start synpred20_GeoGenScript
void GeoGenScriptParser::msynpred20_GeoGenScript_fragment(  )
{
    // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScript.g:95:5: ( expression ';' )
    // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScript.g:95:5: expression ';'
    {
        this->followPush(FOLLOW_expression_in_synpred20_GeoGenScript319);
        expression();

        this->followPop();
        if  (this->hasException())
        {
            goto rulesynpred20_GeoGenScriptEx;
        }
        if (this->hasFailed())
        {
            return ;
        }


         this->matchToken(SEMICOLON, &FOLLOW_SEMICOLON_in_synpred20_GeoGenScript321);
        if  (this->hasException())
        {
            goto rulesynpred20_GeoGenScriptEx;
        }
        if (this->hasFailed())
        {
            return ;
        }


    }

// This is where rules clean up and exit
//
goto rulesynpred20_GeoGenScriptEx; /* Prevent compiler warnings */
rulesynpred20_GeoGenScriptEx: ;

}
// $ANTLR end synpred20_GeoGenScript

// $ANTLR start synpred27_GeoGenScript
void GeoGenScriptParser::msynpred27_GeoGenScript_fragment(  )
{
    // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScript.g:102:5: ( block )
    // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScript.g:102:5: block
    {
        this->followPush(FOLLOW_block_in_synpred27_GeoGenScript385);
        block();

        this->followPop();
        if  (this->hasException())
        {
            goto rulesynpred27_GeoGenScriptEx;
        }
        if (this->hasFailed())
        {
            return ;
        }


    }

// This is where rules clean up and exit
//
goto rulesynpred27_GeoGenScriptEx; /* Prevent compiler warnings */
rulesynpred27_GeoGenScriptEx: ;

}
// $ANTLR end synpred27_GeoGenScript

// $ANTLR start synpred29_GeoGenScript
void GeoGenScriptParser::msynpred29_GeoGenScript_fragment(  )
{
    // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScript.g:108:5: ( 'yield' expression 'as' STRING )
    // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScript.g:108:5: 'yield' expression 'as' STRING
    {
         this->matchToken(YIELD, &FOLLOW_YIELD_in_synpred29_GeoGenScript425);
        if  (this->hasException())
        {
            goto rulesynpred29_GeoGenScriptEx;
        }
        if (this->hasFailed())
        {
            return ;
        }


        this->followPush(FOLLOW_expression_in_synpred29_GeoGenScript427);
        expression();

        this->followPop();
        if  (this->hasException())
        {
            goto rulesynpred29_GeoGenScriptEx;
        }
        if (this->hasFailed())
        {
            return ;
        }


         this->matchToken(AS, &FOLLOW_AS_in_synpred29_GeoGenScript429);
        if  (this->hasException())
        {
            goto rulesynpred29_GeoGenScriptEx;
        }
        if (this->hasFailed())
        {
            return ;
        }


         this->matchToken(STRING, &FOLLOW_STRING_in_synpred29_GeoGenScript431);
        if  (this->hasException())
        {
            goto rulesynpred29_GeoGenScriptEx;
        }
        if (this->hasFailed())
        {
            return ;
        }


    }

// This is where rules clean up and exit
//
goto rulesynpred29_GeoGenScriptEx; /* Prevent compiler warnings */
rulesynpred29_GeoGenScriptEx: ;

}
// $ANTLR end synpred29_GeoGenScript

// $ANTLR start synpred34_GeoGenScript
void GeoGenScriptParser::msynpred34_GeoGenScript_fragment(  )
{
    // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScript.g:124:6: ( 'else' statement )
    // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScript.g:124:6: 'else' statement
    {
         this->matchToken(ELSE, &FOLLOW_ELSE_in_synpred34_GeoGenScript545);
        if  (this->hasException())
        {
            goto rulesynpred34_GeoGenScriptEx;
        }
        if (this->hasFailed())
        {
            return ;
        }


        this->followPush(FOLLOW_statement_in_synpred34_GeoGenScript547);
        statement();

        this->followPop();
        if  (this->hasException())
        {
            goto rulesynpred34_GeoGenScriptEx;
        }
        if (this->hasFailed())
        {
            return ;
        }


    }

// This is where rules clean up and exit
//
goto rulesynpred34_GeoGenScriptEx; /* Prevent compiler warnings */
rulesynpred34_GeoGenScriptEx: ;

}
// $ANTLR end synpred34_GeoGenScript

// $ANTLR start synpred65_GeoGenScript
void GeoGenScriptParser::msynpred65_GeoGenScript_fragment(  )
{
    // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScript.g:167:35: ( prio4Operator prio3Expression )
    // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScript.g:167:35: prio4Operator prio3Expression
    {
        this->followPush(FOLLOW_prio4Operator_in_synpred65_GeoGenScript911);
        prio4Operator();

        this->followPop();
        if  (this->hasException())
        {
            goto rulesynpred65_GeoGenScriptEx;
        }
        if (this->hasFailed())
        {
            return ;
        }


        this->followPush(FOLLOW_prio3Expression_in_synpred65_GeoGenScript913);
        prio3Expression();

        this->followPop();
        if  (this->hasException())
        {
            goto rulesynpred65_GeoGenScriptEx;
        }
        if (this->hasFailed())
        {
            return ;
        }


    }

// This is where rules clean up and exit
//
goto rulesynpred65_GeoGenScriptEx; /* Prevent compiler warnings */
rulesynpred65_GeoGenScriptEx: ;

}
// $ANTLR end synpred65_GeoGenScript

// $ANTLR start synpred75_GeoGenScript
void GeoGenScriptParser::msynpred75_GeoGenScript_fragment(  )
{
    // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScript.g:174:55: ( prio2PostfixOperator )
    // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScript.g:174:55: prio2PostfixOperator
    {
        this->followPush(FOLLOW_prio2PostfixOperator_in_synpred75_GeoGenScript987);
        prio2PostfixOperator();

        this->followPop();
        if  (this->hasException())
        {
            goto rulesynpred75_GeoGenScriptEx;
        }
        if (this->hasFailed())
        {
            return ;
        }


    }

// This is where rules clean up and exit
//
goto rulesynpred75_GeoGenScriptEx; /* Prevent compiler warnings */
rulesynpred75_GeoGenScriptEx: ;

}
// $ANTLR end synpred75_GeoGenScript

// $ANTLR start synpred79_GeoGenScript
void GeoGenScriptParser::msynpred79_GeoGenScript_fragment(  )
{
    // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScript.g:179:9: ( '(' ( expression ( ',' expression )* )? ')' )
    // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScript.g:179:9: '(' ( expression ( ',' expression )* )? ')'
    {
         this->matchToken(LEFT_BRACKET, &FOLLOW_LEFT_BRACKET_in_synpred79_GeoGenScript1028);
        if  (this->hasException())
        {
            goto rulesynpred79_GeoGenScriptEx;
        }
        if (this->hasFailed())
        {
            return ;
        }


        // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScript.g:179:13: ( expression ( ',' expression )* )?
        {
            int alt59=2;
            switch ( this->LA(1) )
            {
                case AT:
                case FALSE_LIT:
                case IDENTIFIER:
                case LEFT_BRACKET:
                case LEFT_CURLY_BRACKET:
                case LEFT_SQUARE_BRACKET:
                case NUMBER:
                case OPERATOR_DECREMENT:
                case OPERATOR_INCREMENT:
                case OPERATOR_MINUS:
                case OPERATOR_NOT:
                case OPERATOR_PLUS:
                case STRING:
                case TRUE_LIT:
                	{
                		alt59=1;
                	}
                    break;
            }

            switch (alt59)
            {
        	case 1:
        	    // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScript.g:179:14: expression ( ',' expression )*
        	    {
        	        this->followPush(FOLLOW_expression_in_synpred79_GeoGenScript1031);
        	        expression();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulesynpred79_GeoGenScriptEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	        // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScript.g:179:25: ( ',' expression )*

        	        for (;;)
        	        {
        	            int alt58=2;
        	            switch ( this->LA(1) )
        	            {
        	            case COMMA:
        	            	{
        	            		alt58=1;
        	            	}
        	                break;

        	            }

        	            switch (alt58)
        	            {
        	        	case 1:
        	        	    // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScript.g:179:26: ',' expression
        	        	    {
        	        	         this->matchToken(COMMA, &FOLLOW_COMMA_in_synpred79_GeoGenScript1034);
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulesynpred79_GeoGenScriptEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	        this->followPush(FOLLOW_expression_in_synpred79_GeoGenScript1036);
        	        	        expression();

        	        	        this->followPop();
        	        	        if  (this->hasException())
        	        	        {
        	        	            goto rulesynpred79_GeoGenScriptEx;
        	        	        }
        	        	        if (this->hasFailed())
        	        	        {
        	        	            return ;
        	        	        }


        	        	    }
        	        	    break;

        	        	default:
        	        	    goto loop58;	/* break out of the loop */
        	        	    break;
        	            }
        	        }
        	        loop58: ; /* Jump out to here if this rule does not match */


        	    }
        	    break;

            }
        }

         this->matchToken(RIGHT_BRACKET, &FOLLOW_RIGHT_BRACKET_in_synpred79_GeoGenScript1042);
        if  (this->hasException())
        {
            goto rulesynpred79_GeoGenScriptEx;
        }
        if (this->hasFailed())
        {
            return ;
        }


    }

// This is where rules clean up and exit
//
goto rulesynpred79_GeoGenScriptEx; /* Prevent compiler warnings */
rulesynpred79_GeoGenScriptEx: ;

}
// $ANTLR end synpred79_GeoGenScript

// $ANTLR start synpred81_GeoGenScript
void GeoGenScriptParser::msynpred81_GeoGenScript_fragment(  )
{
    // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScript.g:180:9: ( '[' expression ( ',' expression )* ']' )
    // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScript.g:180:9: '[' expression ( ',' expression )* ']'
    {
         this->matchToken(LEFT_SQUARE_BRACKET, &FOLLOW_LEFT_SQUARE_BRACKET_in_synpred81_GeoGenScript1054);
        if  (this->hasException())
        {
            goto rulesynpred81_GeoGenScriptEx;
        }
        if (this->hasFailed())
        {
            return ;
        }


        this->followPush(FOLLOW_expression_in_synpred81_GeoGenScript1056);
        expression();

        this->followPop();
        if  (this->hasException())
        {
            goto rulesynpred81_GeoGenScriptEx;
        }
        if (this->hasFailed())
        {
            return ;
        }


        // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScript.g:180:24: ( ',' expression )*

        for (;;)
        {
            int alt60=2;
            switch ( this->LA(1) )
            {
            case COMMA:
            	{
            		alt60=1;
            	}
                break;

            }

            switch (alt60)
            {
        	case 1:
        	    // D:\\Users\\Matej\\Desktop\\GeoGen GGS\\src\\GeoGen\\Grammar\\GeoGenScript.g:180:25: ',' expression
        	    {
        	         this->matchToken(COMMA, &FOLLOW_COMMA_in_synpred81_GeoGenScript1059);
        	        if  (this->hasException())
        	        {
        	            goto rulesynpred81_GeoGenScriptEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	        this->followPush(FOLLOW_expression_in_synpred81_GeoGenScript1061);
        	        expression();

        	        this->followPop();
        	        if  (this->hasException())
        	        {
        	            goto rulesynpred81_GeoGenScriptEx;
        	        }
        	        if (this->hasFailed())
        	        {
        	            return ;
        	        }


        	    }
        	    break;

        	default:
        	    goto loop60;	/* break out of the loop */
        	    break;
            }
        }
        loop60: ; /* Jump out to here if this rule does not match */


         this->matchToken(RIGHT_SQUARE_BRACKET, &FOLLOW_RIGHT_SQUARE_BRACKET_in_synpred81_GeoGenScript1065);
        if  (this->hasException())
        {
            goto rulesynpred81_GeoGenScriptEx;
        }
        if (this->hasFailed())
        {
            return ;
        }


    }

// This is where rules clean up and exit
//
goto rulesynpred81_GeoGenScriptEx; /* Prevent compiler warnings */
rulesynpred81_GeoGenScriptEx: ;

}
// $ANTLR end synpred81_GeoGenScript
/* End of parsing rules
 * ==============================================
 */

/* ==============================================
 * Syntactic predicates
 */
bool GeoGenScriptParser::msynpred( antlr3::ClassForwarder< synpred1_GeoGenScript >  )
{
    ANTLR_MARKER   start;
    bool  success;

    this->inc_backtracking();
    start	= this->mark();
    this->msynpred1_GeoGenScript_fragment();	    // can never throw exception
    success	= !( this->get_failedflag() );
    this->rewind(start);
    this->dec_backtracking();
    this->set_failedflag(false);
    return success;
}

bool GeoGenScriptParser::msynpred( antlr3::ClassForwarder< synpred29_GeoGenScript >  )
{
    ANTLR_MARKER   start;
    bool  success;

    this->inc_backtracking();
    start	= this->mark();
    this->msynpred29_GeoGenScript_fragment();	    // can never throw exception
    success	= !( this->get_failedflag() );
    this->rewind(start);
    this->dec_backtracking();
    this->set_failedflag(false);
    return success;
}

bool GeoGenScriptParser::msynpred( antlr3::ClassForwarder< synpred81_GeoGenScript >  )
{
    ANTLR_MARKER   start;
    bool  success;

    this->inc_backtracking();
    start	= this->mark();
    this->msynpred81_GeoGenScript_fragment();	    // can never throw exception
    success	= !( this->get_failedflag() );
    this->rewind(start);
    this->dec_backtracking();
    this->set_failedflag(false);
    return success;
}

bool GeoGenScriptParser::msynpred( antlr3::ClassForwarder< synpred65_GeoGenScript >  )
{
    ANTLR_MARKER   start;
    bool  success;

    this->inc_backtracking();
    start	= this->mark();
    this->msynpred65_GeoGenScript_fragment();	    // can never throw exception
    success	= !( this->get_failedflag() );
    this->rewind(start);
    this->dec_backtracking();
    this->set_failedflag(false);
    return success;
}

bool GeoGenScriptParser::msynpred( antlr3::ClassForwarder< synpred20_GeoGenScript >  )
{
    ANTLR_MARKER   start;
    bool  success;

    this->inc_backtracking();
    start	= this->mark();
    this->msynpred20_GeoGenScript_fragment();	    // can never throw exception
    success	= !( this->get_failedflag() );
    this->rewind(start);
    this->dec_backtracking();
    this->set_failedflag(false);
    return success;
}

bool GeoGenScriptParser::msynpred( antlr3::ClassForwarder< synpred79_GeoGenScript >  )
{
    ANTLR_MARKER   start;
    bool  success;

    this->inc_backtracking();
    start	= this->mark();
    this->msynpred79_GeoGenScript_fragment();	    // can never throw exception
    success	= !( this->get_failedflag() );
    this->rewind(start);
    this->dec_backtracking();
    this->set_failedflag(false);
    return success;
}

bool GeoGenScriptParser::msynpred( antlr3::ClassForwarder< synpred9_GeoGenScript >  )
{
    ANTLR_MARKER   start;
    bool  success;

    this->inc_backtracking();
    start	= this->mark();
    this->msynpred9_GeoGenScript_fragment();	    // can never throw exception
    success	= !( this->get_failedflag() );
    this->rewind(start);
    this->dec_backtracking();
    this->set_failedflag(false);
    return success;
}

bool GeoGenScriptParser::msynpred( antlr3::ClassForwarder< synpred34_GeoGenScript >  )
{
    ANTLR_MARKER   start;
    bool  success;

    this->inc_backtracking();
    start	= this->mark();
    this->msynpred34_GeoGenScript_fragment();	    // can never throw exception
    success	= !( this->get_failedflag() );
    this->rewind(start);
    this->dec_backtracking();
    this->set_failedflag(false);
    return success;
}

bool GeoGenScriptParser::msynpred( antlr3::ClassForwarder< synpred27_GeoGenScript >  )
{
    ANTLR_MARKER   start;
    bool  success;

    this->inc_backtracking();
    start	= this->mark();
    this->msynpred27_GeoGenScript_fragment();	    // can never throw exception
    success	= !( this->get_failedflag() );
    this->rewind(start);
    this->dec_backtracking();
    this->set_failedflag(false);
    return success;
}

bool GeoGenScriptParser::msynpred( antlr3::ClassForwarder< synpred75_GeoGenScript >  )
{
    ANTLR_MARKER   start;
    bool  success;

    this->inc_backtracking();
    start	= this->mark();
    this->msynpred75_GeoGenScript_fragment();	    // can never throw exception
    success	= !( this->get_failedflag() );
    this->rewind(start);
    this->dec_backtracking();
    this->set_failedflag(false);
    return success;
}

/* End of syntactic predicates
 * ==============================================
 */

	}


/* End of code
 * =============================================================================
 */
