#pragma once

#include <vector>

#include "../String.hpp"
#include "CodeBlock.hpp"
#include "MetadataKeyValueCollection.hpp"
#include "../corelib/CoreLibrary.hpp"
#include "ScriptParameters.hpp"
#include "../Configuration.hpp"

namespace geogen 
{
	namespace runtime
	{
		class TypeDefinition;
		class VariableDefinition;
		class FunctionDefinition;
		class Library;

		/// A compiled script.
		class CompiledScript : public Serializable
		{
			private:	
				Configuration configuration;

				SymbolDefinitionTable<VariableDefinition> globalVariableDefinitions;
				SymbolDefinitionTable<FunctionDefinition> globalFunctionDefinitions;
				SymbolDefinitionTable<TypeDefinition> typeDefinitions;

				std::vector<FunctionDefinition*> ownedFunctionDefinitions;
				std::vector<TypeDefinition*> ownedTypeDefinitions;

				MetadataKeyValueCollection metadata;

				std::vector<String> supportedMaps;

				corelib::CoreLibrary coreLibrary;

				String code;
			public:
				/// Name of the main function.
				static const String MAIN_FUNCTION_NAME;

				/// Constructor.
				/// @param code The script code.
				CompiledScript(String code);

				/// Destructor.
				~CompiledScript();

				/// Sets configuration.
				/// @param configuration The configuration.
				void SetConfiguration(Configuration configuration) { this->configuration = configuration; }

				/// Gets the configuration.
				/// @return The configuration.
				Configuration const& GetConfiguration() const { return this->configuration; }

				/// Gets the code.
				/// @return The code.
				inline String GetCode() const { return this->code; }

				/// Creates a script parameters object based on the script metadata.
				/// @return The script parameters.
				ScriptParameters CreateScriptParameters() const;

				/// Gets the script metadata tree.
				/// @return The metadata tree.
				inline MetadataKeyValueCollection const& GetMetadata() const { return this->metadata; }

				/// Gets the script metadata tree.
				/// @return The metadata tree.
				inline MetadataKeyValueCollection& GetMetadata() { return this->metadata; }

				/// Gets global variable definitions.
				/// @return The global variable definitions.
				inline SymbolDefinitionTable<VariableDefinition> const& GetGlobalVariableDefinitions() const { return this->globalVariableDefinitions; }
				//inline SymbolDefinitionTable<VariableDefinition>& GetGlobalVariableDefinitions() { return this->globalVariableDefinitions; }

				/// Gets global function definitions.
				/// @return The global function definitions.
				inline SymbolDefinitionTable<FunctionDefinition> const& GetGlobalFunctionDefinitions() const { return this->globalFunctionDefinitions; }
				//inline SymbolDefinitionTable<FunctionDefinition>& GetGlobalFunctionDefinitions() { return this->globalFunctionDefinitions; }

				/// Gets type definitions.
				/// @return The type definitions.
				inline SymbolDefinitionTable<TypeDefinition> const& GetTypeDefinitions() const { return this->typeDefinitions; }
				//inline SymbolDefinitionTable<TypeDefinition>& GetTypeDefinitions() { return this->typeDefinitions; }

				/*inline CodeBlock& GetRootCodeBlock() { return this->rootCodeBlock; }
				inline CodeBlock const& GetRootCodeBlock() const { return this->rootCodeBlock; }*/

				/*inline CodeBlock& GetInitializationCodeBlock() { return this->initializationCodeBlock; }
				inline CodeBlock const& GetInitializationCodeBlock() const { return this->initializationCodeBlock; }*/

				/// Adds a global function definition.
				/// @param functionDefintion The function definition. The compiler script will not take ownership of this pointer.
				/// @return True if the function is successfully added.
				bool AddGlobalFunctionDefinition(FunctionDefinition* functionDefintion);

				/// Adds a type definition.
				/// @param typeDefintion The type definition. The compiler script will not take ownership of this pointer.
				/// @return True if the type is successfully added.
				bool AddTypeDefinition(TypeDefinition* typeDefinition);

				/// Gets a list of map names that can be generated by this script.
				/// @return The supported maps.
				std::vector<String>& GetSupportedMaps() { return this->supportedMaps; }
				
				/// Gets a list of map names that can be generated by this script.
				/// @return The supported maps.
				std::vector<String> const& GetSupportedMaps() const { return this->supportedMaps; }

				/// Adds an entire library to the script.
				/// @param library The library.
				void AddLibrary(Library const* library);

				virtual void Serialize(IOStream& stream) const;
		};
	}
}